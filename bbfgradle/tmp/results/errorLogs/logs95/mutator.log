2021-03-12 07:53:33,913 [main:66] - Compilation checking started
2021-03-12 07:53:35,060 [main:50] - replacing var state : Int Int
2021-03-12 07:53:35,061 [main:54] - Getting value of type Int
2021-03-12 07:53:35,201 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:35,203 [main:58] - GENERATED VALUE OF TYPE Int = 186621890
2021-03-12 07:53:35,203 [main:61] - GENERATED IS CALL =false
2021-03-12 07:53:35,819 [main:67] - randomType = Double
2021-03-12 07:53:35,966 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:53:36,117 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@6a12316c]
2021-03-12 07:53:36,237 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:53:36,238 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@62f7e5f9]
2021-03-12 07:53:36,389 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:36,392 [main:78] - Generated call from random type = (0.06087674450095926).compareTo(-62).ushr(-1164530179)
2021-03-12 07:53:36,393 [main:33] - Trying to replace Element(VALUE_PARAMETER) on Element(VALUE_PARAMETER)
2021-03-12 07:53:36,394 [main:66] - Compilation checking started
2021-03-12 07:53:36,891 [main:53] - Result = true
Text:
class Foo(
        var state : Int = 186621890,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}
2021-03-12 07:53:36,892 [main:50] - replacing val f : (Int) -> Int Function1<Int, Int>
2021-03-12 07:53:36,892 [main:54] - Getting value of type Function1<Int, Int>
2021-03-12 07:53:37,017 [main:302] - generating value of type = Function1<Int, Int> false depth = 0
2021-03-12 07:53:37,017 [main:302] - generating value of type = Int true depth = 1
2021-03-12 07:53:37,018 [main:58] - GENERATED VALUE OF TYPE Function1<Int, Int> = {a: Int -> 1735283883}
2021-03-12 07:53:37,019 [main:61] - GENERATED IS CALL =false
2021-03-12 07:53:37,022 [main:67] - randomType = Foo
2021-03-12 07:53:37,160 [main:302] - generating value of type = Foo false depth = 0
2021-03-12 07:53:37,160 [main:112] - generating klass Foo text = class Foo(
        var state : Int = 186621890,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}
2021-03-12 07:53:37,299 [main:194] - Type params = []
2021-03-12 07:53:37,446 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:53:37,447 [main:302] - generating value of type = Function1<Int, Int> false depth = 2
2021-03-12 07:53:37,447 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:53:37,474 [main:78] - Generated call from random type = (Foo(1405075037, {a: Int -> 1410597205})).f
2021-03-12 07:53:37,489 [main:106] - GETTING Function1<Int, Int> from Int
2021-03-12 07:53:37,572 [main:33] - Trying to replace Element(VALUE_PARAMETER) on Element(VALUE_PARAMETER)
2021-03-12 07:53:37,573 [main:66] - Compilation checking started
2021-03-12 07:53:38,094 [main:53] - Result = true
Text:
class Foo(
        var state : Int = 186621890,
        val f : (Int) -> Int = (Foo(1405075037, {a: Int -> 1410597205})).f){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}
2021-03-12 07:53:38,327 [main:112] - generating klass Foo text = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}
2021-03-12 07:53:38,424 [main:194] - Type params = []
2021-03-12 07:53:38,538 [main:302] - generating value of type = Int true depth = 1
2021-03-12 07:53:38,538 [main:302] - generating value of type = Function1<Int, Int> false depth = 1
2021-03-12 07:53:38,538 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:53:38,813 [main:45] - Trying to change 18 nodes
2021-03-12 07:53:38,815 [main:53] - replacing ({x -> 2 * x}, Function1<Int, Int>)
2021-03-12 07:53:38,816 [main:50] - replacing {x -> 2 * x} Function1<Int, Int>
2021-03-12 07:53:38,816 [main:54] - Getting value of type Function1<Int, Int>
2021-03-12 07:53:38,926 [main:302] - generating value of type = Function1<Int, Int> false depth = 0
2021-03-12 07:53:38,927 [main:302] - generating value of type = Int true depth = 1
2021-03-12 07:53:38,927 [main:58] - GENERATED VALUE OF TYPE Function1<Int, Int> = {a: Int -> 1101108231}
2021-03-12 07:53:38,928 [main:61] - GENERATED IS CALL =false
2021-03-12 07:53:39,250 [main:67] - randomType = Set<Collection<Foo>>?
2021-03-12 07:53:39,250 [main:106] - GETTING Function1<Int, Int> from Function1<Int, Int>
2021-03-12 07:53:39,264 [main:61] - replacement of {x -> 2 * x} of type Function1<Int, Int> is {a: Int -> 1101108231}
2021-03-12 07:53:39,349 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 07:53:39,349 [main:66] - Compilation checking started
2021-03-12 07:53:39,699 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {a: Int -> 1101108231})
    return if (f.next() == 46) "OK" else "fail"
}
2021-03-12 07:53:39,700 [main:53] - replacing (x, Int)
2021-03-12 07:53:39,700 [main:50] - replacing x Int
2021-03-12 07:53:39,700 [main:54] - Getting value of type Int
2021-03-12 07:53:39,806 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:39,807 [main:58] - GENERATED VALUE OF TYPE Int = -1602427211
2021-03-12 07:53:39,807 [main:61] - GENERATED IS CALL =false
2021-03-12 07:53:39,896 [main:67] - randomType = Byte
2021-03-12 07:53:39,978 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:53:40,049 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:53:40,049 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@77d252d6]
2021-03-12 07:53:40,051 [main:78] - Generated call from random type = (-22).toInt().shr(Foo(-361314941, {a: Int -> 77545550}).next())
2021-03-12 07:53:40,054 [main:106] - GETTING Int from Function1<Int, Int>
2021-03-12 07:53:40,075 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49], public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@63d279b5]]
2021-03-12 07:53:40,075 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49]
2021-03-12 07:53:40,076 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@63d279b5]
2021-03-12 07:53:40,077 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).f).invoke(Foo(-361314941, {a: Int -> 77545550}).state).and(Foo(-361314941, {a: Int -> 77545550}).next())
2021-03-12 07:53:40,077 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3833da6f]]
2021-03-12 07:53:40,077 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49]
2021-03-12 07:53:40,078 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3833da6f]
2021-03-12 07:53:40,157 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:53:40,158 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).f).invoke(Foo(-361314941, {a: Int -> 77545550}).next()).rem(37)
2021-03-12 07:53:40,159 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49], public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16107de0]]
2021-03-12 07:53:40,159 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49]
2021-03-12 07:53:40,159 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16107de0]
2021-03-12 07:53:40,160 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).f).invoke(Foo(-361314941, {a: Int -> 77545550}).next()).toInt()
2021-03-12 07:53:40,160 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49], public fun kotlin.Int.coerceAtMost(maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@741f1e49]]
2021-03-12 07:53:40,160 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49]
2021-03-12 07:53:40,161 [main:149] - GENERATING call of type public fun kotlin.Int.coerceAtMost(maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@741f1e49]
2021-03-12 07:53:40,249 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:40,251 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).f).invoke(Foo(-361314941, {a: Int -> 77545550}).next()).coerceAtMost(572091931)
2021-03-12 07:53:40,251 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49], public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@62f7e5f9]]
2021-03-12 07:53:40,251 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49]
2021-03-12 07:53:40,251 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@62f7e5f9]
2021-03-12 07:53:40,253 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).f).invoke(Foo(-361314941, {a: Int -> 77545550}).state).ushr(Foo(-361314941, {a: Int -> 77545550}).state)
2021-03-12 07:53:40,253 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49], public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3495fc12]]
2021-03-12 07:53:40,253 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49]
2021-03-12 07:53:40,253 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3495fc12]
2021-03-12 07:53:40,337 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:53:40,338 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).f).invoke(Foo(-361314941, {a: Int -> 77545550}).state).times(8)
2021-03-12 07:53:40,340 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@36ee2e3a]]
2021-03-12 07:53:40,340 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49]
2021-03-12 07:53:40,419 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:40,420 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@36ee2e3a]
2021-03-12 07:53:40,420 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).f).invoke(392726721).takeLowestOneBit()
2021-03-12 07:53:40,421 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@5fefc31]]
2021-03-12 07:53:40,421 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49]
2021-03-12 07:53:40,503 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:40,503 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@5fefc31]
2021-03-12 07:53:40,504 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).f).invoke(1833823429).countOneBits()
2021-03-12 07:53:40,504 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@529bf692]]
2021-03-12 07:53:40,505 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49]
2021-03-12 07:53:40,597 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:40,598 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@529bf692]
2021-03-12 07:53:40,686 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:53:40,687 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).f).invoke(-1262854715).minus(-77)
2021-03-12 07:53:40,688 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeHighestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@393adb37]]
2021-03-12 07:53:40,688 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49]
2021-03-12 07:53:40,688 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeHighestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@393adb37]
2021-03-12 07:53:40,689 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).f).invoke(Foo(-361314941, {a: Int -> 77545550}).state).takeHighestOneBit()
2021-03-12 07:53:40,689 [main:61] - replacement of x of type Int is (Foo(-361314941, {a: Int -> 77545550}).f).invoke(1833823429).countOneBits()
2021-03-12 07:53:40,773 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:53:40,775 [main:53] - replacing ("OK", String)
2021-03-12 07:53:40,775 [main:50] - replacing "OK" String
2021-03-12 07:53:40,775 [main:54] - Getting value of type String
2021-03-12 07:53:40,884 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:53:40,886 [main:58] - GENERATED VALUE OF TYPE String = "hjxna"
2021-03-12 07:53:40,886 [main:61] - GENERATED IS CALL =false
2021-03-12 07:53:40,887 [main:67] - randomType = Foo
2021-03-12 07:53:40,973 [main:302] - generating value of type = Foo false depth = 0
2021-03-12 07:53:40,973 [main:112] - generating klass Foo text = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}
2021-03-12 07:53:41,054 [main:194] - Type params = []
2021-03-12 07:53:41,133 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:53:41,134 [main:302] - generating value of type = Function1<Int, Int> false depth = 2
2021-03-12 07:53:41,134 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:53:41,143 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@b7c3b07]
2021-03-12 07:53:41,143 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:53:41,144 [main:78] - Generated call from random type = (Foo(-1476740223, {a: Int -> 1855819873})).next().toString(Foo(-361314941, {a: Int -> 77545550}).state)
2021-03-12 07:53:41,146 [main:106] - GETTING String from Function1<Int, Int>
2021-03-12 07:53:41,159 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:53:41,159 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@46871c49]
2021-03-12 07:53:41,308 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:41,310 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:53:41,312 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).f).invoke(-57870430).toString(Foo(-361314941, {a: Int -> 77545550}).next())
2021-03-12 07:53:41,312 [main:61] - replacement of "OK" of type String is (Foo(-361314941, {a: Int -> 77545550}).f).invoke(-57870430).toString(Foo(-361314941, {a: Int -> 77545550}).next())
2021-03-12 07:53:41,412 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:53:41,413 [main:66] - Compilation checking started
2021-03-12 07:53:41,808 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {a: Int -> 1101108231})
    return if (f.next() == 46) (Foo(-361314941, {a: Int -> 77545550}).f).invoke(-57870430).toString(Foo(-361314941, {a: Int -> 77545550}).next()) else "fail"
}
2021-03-12 07:53:41,809 [main:53] - replacing (state, Int)
2021-03-12 07:53:41,809 [main:50] - replacing state Int
2021-03-12 07:53:41,809 [main:54] - Getting value of type Int
2021-03-12 07:53:41,907 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:41,908 [main:58] - GENERATED VALUE OF TYPE Int = -919780392
2021-03-12 07:53:41,908 [main:61] - GENERATED IS CALL =false
2021-03-12 07:53:41,909 [main:67] - randomType = Boolean
2021-03-12 07:53:41,998 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:53:42,020 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:53:42,110 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:53:42,111 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@7921f7e4]
2021-03-12 07:53:42,112 [main:78] - Generated call from random type = (false).compareTo(true).countLeadingZeroBits()
2021-03-12 07:53:42,112 [main:106] - GETTING Int from Int
2021-03-12 07:53:42,169 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4f0e977a]]
2021-03-12 07:53:42,169 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:53:42,170 [main:149] - GENERATING call of type public final infix fun shl(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4f0e977a]
2021-03-12 07:53:42,258 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:42,259 [main:117] - GENERATED CALL = (nextState).toInt().shl(197547182)
2021-03-12 07:53:42,259 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4fa2ec50]]
2021-03-12 07:53:42,259 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:53:42,260 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4fa2ec50]
2021-03-12 07:53:42,260 [main:117] - GENERATED CALL = (nextState).compareTo(nextState).unaryMinus()
2021-03-12 07:53:42,260 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toRawBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@62f6c22e]]
2021-03-12 07:53:42,260 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 07:53:42,261 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toRawBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@62f6c22e]
2021-03-12 07:53:42,261 [main:117] - GENERATED CALL = (nextState).toFloat().toRawBits()
2021-03-12 07:53:42,261 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a00dab7]]
2021-03-12 07:53:42,261 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:53:42,261 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a00dab7]
2021-03-12 07:53:42,262 [main:117] - GENERATED CALL = (nextState).toShort().unaryMinus()
2021-03-12 07:53:42,262 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@206be60b]]
2021-03-12 07:53:42,262 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:53:42,262 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@206be60b]
2021-03-12 07:53:42,263 [main:117] - GENERATED CALL = (nextState).toInt().rotateRight(Foo(-361314941, {a: Int -> 77545550}).next())
2021-03-12 07:53:42,263 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@77d252d6]]
2021-03-12 07:53:42,263 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:53:42,264 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@77d252d6]
2021-03-12 07:53:42,357 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:42,358 [main:117] - GENERATED CALL = (nextState).compareTo(Foo(-361314941, {a: Int -> 77545550}).next()).shr(441753501)
2021-03-12 07:53:42,358 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@6674a40b]]
2021-03-12 07:53:42,358 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:53:42,358 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@6674a40b]
2021-03-12 07:53:42,359 [main:117] - GENERATED CALL = (nextState).toShort().unaryPlus()
2021-03-12 07:53:42,359 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@62f7e5f9]]
2021-03-12 07:53:42,359 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:53:42,359 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@62f7e5f9]
2021-03-12 07:53:42,360 [main:117] - GENERATED CALL = (nextState).toInt().ushr(nextState)
2021-03-12 07:53:42,360 [main:113] - Case = [public final operator fun div(other: kotlin.Float): kotlin.Float defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7c909fea], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@2a6d0fb3]]
2021-03-12 07:53:42,360 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Float): kotlin.Float defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7c909fea]
2021-03-12 07:53:42,448 [main:302] - generating value of type = Float true depth = 0
2021-03-12 07:53:42,449 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@2a6d0fb3]
2021-03-12 07:53:42,449 [main:117] - GENERATED CALL = (nextState).div(0.033902705f).toBits()
2021-03-12 07:53:42,449 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3495fc12]]
2021-03-12 07:53:42,450 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:53:42,548 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:42,549 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3495fc12]
2021-03-12 07:53:42,643 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:53:42,644 [main:117] - GENERATED CALL = (nextState).compareTo(-980747357).times(61)
2021-03-12 07:53:42,644 [main:61] - replacement of state of type Int is (nextState).toFloat().toRawBits()
2021-03-12 07:53:42,730 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:53:42,731 [main:66] - Compilation checking started
2021-03-12 07:53:42,973 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f((nextState).toFloat().toRawBits())
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {a: Int -> 1101108231})
    return if (f.next() == 46) (Foo(-361314941, {a: Int -> 77545550}).f).invoke(-57870430).toString(Foo(-361314941, {a: Int -> 77545550}).next()) else "fail"
}
2021-03-12 07:53:42,974 [main:53] - replacing (x, Int)
2021-03-12 07:53:42,974 [main:50] - replacing x Int
2021-03-12 07:53:42,974 [main:54] - Getting value of type Int
2021-03-12 07:53:43,065 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:43,065 [main:58] - GENERATED VALUE OF TYPE Int = 1889394968
2021-03-12 07:53:43,066 [main:61] - GENERATED IS CALL =false
2021-03-12 07:53:43,464 [main:67] - randomType = Sequence<Float?>?
2021-03-12 07:53:43,464 [main:106] - GETTING Int from Int
2021-03-12 07:53:43,523 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3495fc12]]
2021-03-12 07:53:43,523 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:53:43,524 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3495fc12]
2021-03-12 07:53:43,608 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:53:43,609 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).toInt().times(-60)
2021-03-12 07:53:43,609 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4d2af299]]
2021-03-12 07:53:43,609 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 07:53:43,694 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:53:43,695 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4d2af299]
2021-03-12 07:53:43,695 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).div(5093496416915222926).countTrailingZeroBits()
2021-03-12 07:53:43,695 [main:113] - Case = [public final operator fun div(other: kotlin.Float): kotlin.Float defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7c909fea], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toRawBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@62f6c22e]]
2021-03-12 07:53:43,695 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Float): kotlin.Float defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7c909fea]
2021-03-12 07:53:43,811 [main:302] - generating value of type = Float true depth = 0
2021-03-12 07:53:43,812 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toRawBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@62f6c22e]
2021-03-12 07:53:43,813 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).div(0.18203735f).toRawBits()
2021-03-12 07:53:43,813 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7bf4ba17]]
2021-03-12 07:53:43,813 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:53:43,813 [main:149] - GENERATING call of type public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7bf4ba17]
2021-03-12 07:53:43,814 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).toInt().inv()
2021-03-12 07:53:43,814 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7bf4ba17]]
2021-03-12 07:53:43,814 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:53:43,918 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:43,919 [main:149] - GENERATING call of type public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7bf4ba17]
2021-03-12 07:53:43,920 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).compareTo(1748138523).inv()
2021-03-12 07:53:43,920 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], public open fun toInt(): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@47962bfd]]
2021-03-12 07:53:43,920 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:53:43,921 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@47962bfd]
2021-03-12 07:53:43,921 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).toLong().toInt()
2021-03-12 07:53:43,921 [main:113] - Case = [public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@75eb3fad]]
2021-03-12 07:53:43,922 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@75eb3fad]
2021-03-12 07:53:43,922 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).inc()
2021-03-12 07:53:43,922 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16107de0]]
2021-03-12 07:53:43,923 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:53:43,923 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16107de0]
2021-03-12 07:53:43,923 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).toInt().toInt()
2021-03-12 07:53:43,924 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4aa16b76]]
2021-03-12 07:53:43,924 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:53:43,924 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4aa16b76]
2021-03-12 07:53:43,925 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).toLong().countOneBits()
2021-03-12 07:53:43,925 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public final fun toInt(): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@60c69660]]
2021-03-12 07:53:43,925 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:53:43,925 [main:149] - GENERATING call of type public final fun toInt(): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@60c69660]
2021-03-12 07:53:43,926 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).toChar().toInt()
2021-03-12 07:53:43,926 [main:61] - replacement of x of type Int is (Foo(-361314941, {a: Int -> 77545550}).state).inc()
2021-03-12 07:53:44,024 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:53:44,026 [main:53] - replacing (2, Int)
2021-03-12 07:53:44,026 [main:50] - replacing 2 Int
2021-03-12 07:53:44,026 [main:54] - Getting value of type Int
2021-03-12 07:53:44,117 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:44,117 [main:58] - GENERATED VALUE OF TYPE Int = -402146877
2021-03-12 07:53:44,117 [main:61] - GENERATED IS CALL =false
2021-03-12 07:53:44,206 [main:67] - randomType = Short
2021-03-12 07:53:44,290 [main:302] - generating value of type = Short true depth = 0
2021-03-12 07:53:44,336 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@4d097e4e]
2021-03-12 07:53:44,437 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:53:44,438 [main:78] - Generated call from random type = (-9717).plus(77)
2021-03-12 07:53:44,438 [main:106] - GETTING Int from Int
2021-03-12 07:53:44,510 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@7921f7e4]]
2021-03-12 07:53:44,510 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:53:44,511 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@7921f7e4]
2021-03-12 07:53:44,512 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).toInt().countLeadingZeroBits()
2021-03-12 07:53:44,512 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@522e238c]]
2021-03-12 07:53:44,512 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:53:44,512 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@522e238c]
2021-03-12 07:53:44,603 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:53:44,604 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).toByte().plus(23)
2021-03-12 07:53:44,604 [main:113] - Case = [public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@55e60c72]]
2021-03-12 07:53:44,604 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@55e60c72]
2021-03-12 07:53:44,695 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:53:44,696 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).div(52)
2021-03-12 07:53:44,696 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3495fc12]]
2021-03-12 07:53:44,696 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:53:44,697 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3495fc12]
2021-03-12 07:53:44,794 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:53:44,796 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).compareTo(Foo(-361314941, {a: Int -> 77545550}).next()).times(-18)
2021-03-12 07:53:44,796 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@27d8f15e]]
2021-03-12 07:53:44,796 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:53:44,796 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@27d8f15e]
2021-03-12 07:53:44,797 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).toByte().countLeadingZeroBits()
2021-03-12 07:53:44,797 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@6078e75b]]
2021-03-12 07:53:44,797 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 07:53:44,894 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:53:44,895 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@6078e75b]
2021-03-12 07:53:44,896 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).div(-6983576797181815630).countLeadingZeroBits()
2021-03-12 07:53:44,896 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@5fefc31]]
2021-03-12 07:53:44,896 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@5fefc31]
2021-03-12 07:53:44,897 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).countOneBits()
2021-03-12 07:53:44,897 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public final fun toInt(): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@60c69660]]
2021-03-12 07:53:44,897 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:53:44,897 [main:149] - GENERATING call of type public final fun toInt(): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@60c69660]
2021-03-12 07:53:44,898 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).toChar().toInt()
2021-03-12 07:53:44,898 [main:113] - Case = [@kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3833da6f]]
2021-03-12 07:53:44,898 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3833da6f]
2021-03-12 07:53:45,007 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:53:45,008 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).rem(46)
2021-03-12 07:53:45,009 [main:113] - Case = [public final operator fun div(other: kotlin.Float): kotlin.Float defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7c909fea], @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toRawBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@62f6c22e]]
2021-03-12 07:53:45,009 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Float): kotlin.Float defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7c909fea]
2021-03-12 07:53:45,112 [main:302] - generating value of type = Float true depth = 0
2021-03-12 07:53:45,113 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.js.library public fun kotlin.Float.toRawBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@62f6c22e]
2021-03-12 07:53:45,113 [main:117] - GENERATED CALL = (Foo(-361314941, {a: Int -> 77545550}).state).div(0.11744034f).toRawBits()
2021-03-12 07:53:45,113 [main:61] - replacement of 2 of type Int is (Foo(-361314941, {a: Int -> 77545550}).state).toByte().plus(23)
2021-03-12 07:53:45,218 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:53:45,220 [main:53] - replacing (f(state), Int)
2021-03-12 07:53:45,220 [main:50] - replacing f(state) Int
2021-03-12 07:53:45,220 [main:54] - Getting value of type Int
2021-03-12 07:53:45,311 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:45,312 [main:58] - GENERATED VALUE OF TYPE Int = 138141598
2021-03-12 07:53:45,312 [main:61] - GENERATED IS CALL =false
2021-03-12 07:53:45,313 [main:67] - randomType = Foo
2021-03-12 07:53:45,411 [main:302] - generating value of type = Foo false depth = 0
2021-03-12 07:53:45,411 [main:112] - generating klass Foo text = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}
2021-03-12 07:53:45,508 [main:194] - Type params = []
2021-03-12 07:53:45,601 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:53:45,601 [main:302] - generating value of type = Function1<Int, Int> false depth = 2
2021-03-12 07:53:45,602 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:53:45,620 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@b7c3b07]
2021-03-12 07:53:45,621 [main:149] - GENERATING call of type public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7bf4ba17]
2021-03-12 07:53:45,621 [main:78] - Generated call from random type = (Foo(1836552843, {a: Int -> -850583422})).next().inv()
2021-03-12 07:53:45,622 [main:106] - GETTING Int from Int
2021-03-12 07:53:45,681 [main:113] - Case = [public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4fa2ec50]]
2021-03-12 07:53:45,681 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4fa2ec50]
2021-03-12 07:53:45,682 [main:117] - GENERATED CALL = (nextState).unaryMinus()
2021-03-12 07:53:45,683 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public val kotlin.Int.absoluteValue: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@918d98b]]
2021-03-12 07:53:45,683 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:53:45,683 [main:117] - GENERATED CALL = (nextState).toInt().absoluteValue
2021-03-12 07:53:45,683 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7bf4ba17]]
2021-03-12 07:53:45,683 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:53:45,683 [main:149] - GENERATING call of type public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7bf4ba17]
2021-03-12 07:53:45,684 [main:117] - GENERATED CALL = (nextState).toInt().inv()
2021-03-12 07:53:45,684 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@35d0f108]]
2021-03-12 07:53:45,684 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:53:45,684 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@35d0f108]
2021-03-12 07:53:45,684 [main:117] - GENERATED CALL = (nextState).compareTo(nextState).unaryPlus()
2021-03-12 07:53:45,684 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7bf4ba17]]
2021-03-12 07:53:45,684 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:53:45,685 [main:149] - GENERATING call of type public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7bf4ba17]
2021-03-12 07:53:45,685 [main:117] - GENERATED CALL = (nextState).compareTo(nextState).inv()
2021-03-12 07:53:45,685 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4735e7d9]]
2021-03-12 07:53:45,685 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:53:45,685 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@4735e7d9]
2021-03-12 07:53:45,774 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:53:45,775 [main:117] - GENERATED CALL = (nextState).toLong().compareTo(-122)
2021-03-12 07:53:45,775 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@55e60c72]]
2021-03-12 07:53:45,776 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:53:45,869 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:45,870 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@55e60c72]
2021-03-12 07:53:45,975 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:53:45,976 [main:117] - GENERATED CALL = (nextState).compareTo(642934179).div(-53)
2021-03-12 07:53:45,976 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4b5951a3]]
2021-03-12 07:53:45,976 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:53:45,977 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4b5951a3]
2021-03-12 07:53:45,977 [main:117] - GENERATED CALL = (nextState).toShort().countTrailingZeroBits()
2021-03-12 07:53:45,977 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@7921f7e4]]
2021-03-12 07:53:45,977 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@7921f7e4]
2021-03-12 07:53:45,978 [main:117] - GENERATED CALL = (nextState).countLeadingZeroBits()
2021-03-12 07:53:45,978 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public final operator fun minus(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@63d3006a]]
2021-03-12 07:53:45,978 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:53:45,978 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@63d3006a]
2021-03-12 07:53:46,091 [main:302] - generating value of type = Char true depth = 0
2021-03-12 07:53:46,093 [main:117] - GENERATED CALL = (nextState).toChar().minus('')
2021-03-12 07:53:46,093 [main:61] - replacement of f(state) of type Int is 138141598
2021-03-12 07:53:46,195 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-12 07:53:46,195 [main:66] - Compilation checking started
2021-03-12 07:53:46,516 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = 138141598
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {a: Int -> 1101108231})
    return if (f.next() == 46) (Foo(-361314941, {a: Int -> 77545550}).f).invoke(-57870430).toString(Foo(-361314941, {a: Int -> 77545550}).next()) else "fail"
}
2021-03-12 07:53:46,517 [main:53] - replacing (f, Function1<Int, Int>)
2021-03-12 07:53:46,517 [main:50] - replacing f Function1<Int, Int>
2021-03-12 07:53:46,517 [main:54] - Getting value of type Function1<Int, Int>
2021-03-12 07:53:46,600 [main:302] - generating value of type = Function1<Int, Int> false depth = 0
2021-03-12 07:53:46,600 [main:302] - generating value of type = Int true depth = 1
2021-03-12 07:53:46,600 [main:58] - GENERATED VALUE OF TYPE Function1<Int, Int> = {a: Int -> 1280627097}
2021-03-12 07:53:46,601 [main:61] - GENERATED IS CALL =false
2021-03-12 07:53:46,602 [main:67] - randomType = Foo
2021-03-12 07:53:46,688 [main:302] - generating value of type = Foo false depth = 0
2021-03-12 07:53:46,688 [main:112] - generating klass Foo text = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = 138141598
        state = nextState
        return state
    }
}
2021-03-12 07:53:46,767 [main:194] - Type params = []
2021-03-12 07:53:46,850 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:53:46,850 [main:302] - generating value of type = Function1<Int, Int> false depth = 2
2021-03-12 07:53:46,850 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:53:46,862 [main:78] - Generated call from random type = (Foo(-129122996, {a: Int -> -1037683124})).f
2021-03-12 07:53:46,864 [main:106] - GETTING Function1<Int, Int> from Int
2021-03-12 07:53:46,923 [main:106] - GETTING Function1<Int, Int> from Int
2021-03-12 07:53:46,923 [main:106] - GETTING Function1<Int, Int> from Function1<Int, Int>
2021-03-12 07:53:46,937 [main:61] - replacement of f of type Function1<Int, Int> is Foo(-361314941, {a: Int -> 77545550}).f
2021-03-12 07:53:47,017 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:53:47,100 [main:119] - TRYING TO REPLACE CONSTANT 1101108231
2021-03-12 07:53:47,181 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(PREFIX_EXPRESSION)
2021-03-12 07:53:47,181 [main:66] - Compilation checking started
2021-03-12 07:53:47,549 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = 138141598
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {a: Int -> -361314941})
    return if (f.next() == 46) (Foo(-361314941, {a: Int -> 77545550}).f).invoke(-57870430).toString(Foo(-361314941, {a: Int -> 77545550}).next()) else "fail"
}
2021-03-12 07:53:47,549 [main:119] - TRYING TO REPLACE CONSTANT 57870430
2021-03-12 07:53:47,636 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:53:47,636 [main:66] - Compilation checking started
2021-03-12 07:53:48,001 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = 138141598
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {a: Int -> -361314941})
    return if (f.next() == 46) (Foo(-361314941, {a: Int -> 77545550}).f).invoke(Foo(-361314941, {a: Int -> 77545550}).state).toString(Foo(-361314941, {a: Int -> 77545550}).next()) else "fail"
}
2021-03-12 07:53:48,001 [main:119] - TRYING TO REPLACE CONSTANT 361314941
2021-03-12 07:53:48,102 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(REFERENCE_EXPRESSION)
2021-03-12 07:53:48,103 [main:66] - Compilation checking started
2021-03-12 07:53:48,309 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = 138141598
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {a: Int -> -361314941})
    return if (f.next() == 46) (Foo(state, {a: Int -> 77545550}).f).invoke(Foo(-361314941, {a: Int -> 77545550}).state).toString(Foo(-361314941, {a: Int -> 77545550}).next()) else "fail"
}
2021-03-12 07:53:48,310 [main:119] - TRYING TO REPLACE CONSTANT 361314941
2021-03-12 07:53:48,422 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:53:48,423 [main:66] - Compilation checking started
2021-03-12 07:53:48,785 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = 138141598
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {a: Int -> -361314941})
    return if (f.next() == 46) (Foo(-361314941, {a: Int -> 77545550}).f).invoke(Foo(-361314941, {a: Int -> 77545550}).state).toString(Foo((Foo(-361314941, {a: Int -> 77545550}).f).invoke(Foo(-361314941, {a: Int -> 77545550}).state), {a: Int -> 77545550}).next()) else "fail"
}
2021-03-12 07:53:48,785 [main:119] - TRYING TO REPLACE CONSTANT 77545550
2021-03-12 07:53:48,889 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:53:48,889 [main:66] - Compilation checking started
2021-03-12 07:53:49,225 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = 138141598
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {a: Int -> -361314941})
    return if (f.next() == 46) (Foo(-361314941, {a: Int -> Foo(-361314941, {a: Int -> 77545550}).state}).f).invoke(Foo(-361314941, {a: Int -> 77545550}).state).toString(Foo((Foo(-361314941, {a: Int -> 77545550}).f).invoke(Foo(-361314941, {a: Int -> 77545550}).state), {a: Int -> 77545550}).next()) else "fail"
}
2021-03-12 07:53:49,225 [main:119] - TRYING TO REPLACE CONSTANT 77545550
2021-03-12 07:53:49,314 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-12 07:53:49,314 [main:66] - Compilation checking started
2021-03-12 07:53:49,652 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = 138141598
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {a: Int -> -361314941})
    return if (f.next() == 46) (Foo(-361314941, {a: Int -> Foo(-361314941, {a: Int -> 77545550}).state}).f).invoke(Foo(-361314941, {a: Int -> 77545550}).state).toString(Foo((Foo(-361314941, {a: Int -> 77545550}).f).invoke(Foo(-361314941, {a: Int -> 77545550}).state), {a: Int -> 1101108231}).next()) else "fail"
}
2021-03-12 07:53:49,681 [main:41] - AFTER TRY 0 res = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}
2021-03-12 07:53:49,831 [main:112] - generating klass Foo text = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}
2021-03-12 07:53:49,906 [main:194] - Type params = []
2021-03-12 07:53:49,980 [main:302] - generating value of type = Int true depth = 1
2021-03-12 07:53:49,981 [main:302] - generating value of type = Function1<Int, Int> false depth = 1
2021-03-12 07:53:49,981 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:53:50,155 [main:43] - Try 0
2021-03-12 07:53:54,873 [main:69] - Trying to insert override fun fu1(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }
2021-03-12 07:53:55,045 [main:66] - Compilation checking started
2021-03-12 07:53:55,846 [main:103] - Trying to change 136 nodes
2021-03-12 07:53:55,847 [main:107] - replacing (fu1(), Boolean)
2021-03-12 07:53:55,849 [main:50] - replacing fu1() Boolean
2021-03-12 07:53:55,849 [main:54] - Getting value of type Boolean
2021-03-12 07:53:55,974 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:53:55,975 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:53:55,975 [main:61] - GENERATED IS CALL =false
2021-03-12 07:53:55,977 [main:67] - randomType = Boolean
2021-03-12 07:53:56,101 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:53:56,115 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:53:56,248 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:53:56,249 [main:78] - Generated call from random type = (false).equals("iwafi")
2021-03-12 07:53:56,250 [main:106] - GETTING Boolean from Int
2021-03-12 07:53:56,309 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7b609fa2]]
2021-03-12 07:53:56,309 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:53:56,310 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7b609fa2]
2021-03-12 07:53:56,474 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:53:56,475 [main:117] - GENERATED CALL = (f.next()).toShort().equals("xsiho")
2021-03-12 07:53:56,475 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2c57ad81]]
2021-03-12 07:53:56,475 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:53:56,475 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2c57ad81]
2021-03-12 07:53:56,619 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:53:56,619 [main:117] - GENERATED CALL = (f.next()).toByte().equals("uavvs")
2021-03-12 07:53:56,620 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4e3e340b]]
2021-03-12 07:53:56,620 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:53:56,620 [main:149] - GENERATING call of type public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4e3e340b]
2021-03-12 07:53:56,621 [main:117] - GENERATED CALL = (f.next()).toChar().isLetter()
2021-03-12 07:53:56,621 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@559f74f6]]
2021-03-12 07:53:56,621 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:53:56,621 [main:149] - GENERATING call of type public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@559f74f6]
2021-03-12 07:53:56,621 [main:117] - GENERATED CALL = (f.next()).toChar().isLowerCase()
2021-03-12 07:53:56,621 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@39e29b5e]]
2021-03-12 07:53:56,621 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:53:56,621 [main:149] - GENERATING call of type public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@39e29b5e]
2021-03-12 07:53:56,622 [main:117] - GENERATED CALL = (f.next()).toChar().isISOControl()
2021-03-12 07:53:56,622 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3260af05]]
2021-03-12 07:53:56,622 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:53:56,622 [main:149] - GENERATING call of type public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3260af05]
2021-03-12 07:53:56,622 [main:117] - GENERATED CALL = (f.next()).toChar().isLowSurrogate()
2021-03-12 07:53:56,622 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3bbcbd00]]
2021-03-12 07:53:56,622 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:53:56,623 [main:149] - GENERATING call of type public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3bbcbd00]
2021-03-12 07:53:56,749 [main:302] - generating value of type = Char true depth = 0
2021-03-12 07:53:56,872 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:53:56,873 [main:117] - GENERATED CALL = (f.next()).toChar().equals('', false)
2021-03-12 07:53:56,874 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:53:56,874 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:53:57,003 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:53:57,003 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:53:57,129 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:53:57,130 [main:117] - GENERATED CALL = (f.next()).equals("bmfay").equals("prbax")
2021-03-12 07:53:57,130 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7], public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@a67e46]]
2021-03-12 07:53:57,130 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 07:53:57,130 [main:149] - GENERATING call of type public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@a67e46]
2021-03-12 07:53:57,131 [main:117] - GENERATED CALL = (f.next()).toFloat().isInfinite()
2021-03-12 07:53:57,131 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@273e47e2]]
2021-03-12 07:53:57,131 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:53:57,131 [main:149] - GENERATING call of type public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@273e47e2]
2021-03-12 07:53:57,131 [main:117] - GENERATED CALL = (f.next()).toChar().isTitleCase()
2021-03-12 07:53:57,131 [main:114] - replacement of fu1() of type Boolean is (f.next()).toChar().isLetter()
2021-03-12 07:53:57,262 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:53:57,263 [main:66] - Compilation checking started
2021-03-12 07:53:57,568 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus("localAnonymousFunction", v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return prope1.newInstance() as Kla0
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if (prope1.fu4()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.(f.next()).toChar().isLetter()) return "FAIL 4"
    if (!prope1.fu3()) return "FAIL 5"
    try {
        prope1.fu2()
        return "FAIL 6"
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:53:57,570 [main:107] - replacing ({ prope2 = true; true }, Function0<Boolean>)
2021-03-12 07:53:57,571 [main:50] - replacing { prope2 = true; true } Function0<Boolean>
2021-03-12 07:53:57,571 [main:54] - Getting value of type Function0<Boolean>
2021-03-12 07:53:57,734 [main:302] - generating value of type = Function0<Boolean> false depth = 0
2021-03-12 07:53:57,735 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 07:53:57,736 [main:58] - GENERATED VALUE OF TYPE Function0<Boolean> = { true}
2021-03-12 07:53:57,737 [main:61] - GENERATED IS CALL =false
2021-03-12 07:53:57,740 [main:67] - randomType = Kla0
2021-03-12 07:53:57,741 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:53:57,795 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:53:57,796 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:53:57,809 [main:106] - GETTING Function0<Boolean> from Function1<Int, Int>
2021-03-12 07:53:57,823 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:53:57,823 [main:114] - replacement of { prope2 = true; true } of type Function0<Boolean> is { true}
2021-03-12 07:53:57,957 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 07:53:57,957 [main:66] - Compilation checking started
2021-03-12 07:53:58,477 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus("localAnonymousFunction", v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return prope1.newInstance() as Kla0
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if (prope1.fu4()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if (!prope1.fu3()) return "FAIL 5"
    try {
        prope1.fu2()
        return "FAIL 6"
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:53:58,478 [main:107] - replacing ("localAnonymousFunction", String)
2021-03-12 07:53:58,479 [main:50] - replacing "localAnonymousFunction" String
2021-03-12 07:53:58,479 [main:54] - Getting value of type String
2021-03-12 07:53:58,600 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:53:58,601 [main:58] - GENERATED VALUE OF TYPE String = "yghds"
2021-03-12 07:53:58,601 [main:61] - GENERATED IS CALL =false
2021-03-12 07:53:58,858 [main:67] - randomType = Short?
2021-03-12 07:53:58,985 [main:302] - generating value of type = Short true depth = 0
2021-03-12 07:53:59,065 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@1627e0c1]
2021-03-12 07:53:59,190 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:53:59,191 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:53:59,192 [main:78] - Generated call from random type = (-15826)?.div(-352596171495466664).toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:53:59,193 [main:106] - GETTING String from Int
2021-03-12 07:53:59,236 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:53:59,236 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:53:59,236 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:53:59,237 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toLong().toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:53:59,237 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 07:53:59,237 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:53:59,237 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:53:59,237 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toShort().toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:53:59,238 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 07:53:59,238 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:53:59,238 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 07:53:59,238 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().lowercase()
2021-03-12 07:53:59,238 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:53:59,238 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:53:59,238 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:53:59,239 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toByte().toString(f.next())
2021-03-12 07:53:59,239 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:53:59,239 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:53:59,239 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:53:59,344 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:53:59,345 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toInt().toString(-1911580769)
2021-03-12 07:53:59,345 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 07:53:59,346 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:53:59,346 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 07:53:59,346 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().titlecase()
2021-03-12 07:53:59,346 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:53:59,346 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:53:59,346 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:53:59,347 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).compareTo(Foo(-655341081, {a: Int -> 120045518}).next()).toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:53:59,347 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:53:59,347 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:53:59,347 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:53:59,348 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:53:59,348 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 07:53:59,462 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:53:59,463 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:53:59,464 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).div(-8197284177866237019).toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:53:59,464 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 07:53:59,464 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:53:59,464 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 07:53:59,573 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:53:59,575 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx")
2021-03-12 07:53:59,575 [main:114] - replacement of "localAnonymousFunction" of type String is (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx")
2021-03-12 07:53:59,680 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:53:59,681 [main:66] - Compilation checking started
2021-03-12 07:54:00,179 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return prope1.newInstance() as Kla0
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if (prope1.fu4()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if (!prope1.fu3()) return "FAIL 5"
    try {
        prope1.fu2()
        return "FAIL 6"
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:00,181 [main:107] - replacing ("FAIL 5", String)
2021-03-12 07:54:00,181 [main:50] - replacing "FAIL 5" String
2021-03-12 07:54:00,181 [main:54] - Getting value of type String
2021-03-12 07:54:00,318 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:54:00,320 [main:58] - GENERATED VALUE OF TYPE String = "wexjk"
2021-03-12 07:54:00,320 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:00,475 [main:67] - randomType = Short
2021-03-12 07:54:00,588 [main:302] - generating value of type = Short true depth = 0
2021-03-12 07:54:00,635 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@64829fc5]
2021-03-12 07:54:00,635 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:54:00,636 [main:78] - Generated call from random type = (-11951).toByte().toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:54:00,637 [main:106] - GETTING String from Int
2021-03-12 07:54:00,667 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 07:54:00,667 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:54:00,667 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:54:00,788 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:54:00,790 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toShort().toString(-1366515425)
2021-03-12 07:54:00,790 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:54:00,790 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:54:00,790 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:54:00,790 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(f.next()).toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:54:00,791 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 07:54:00,791 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:00,791 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 07:54:00,909 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:54:00,911 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toChar().plus("jbajw")
2021-03-12 07:54:00,911 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:54:00,911 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:54:00,911 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:54:00,912 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toInt().toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:54:00,912 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:54:00,912 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:54:01,034 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:54:01,036 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toString(-921272205)
2021-03-12 07:54:01,036 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]]
2021-03-12 07:54:01,036 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:01,036 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]
2021-03-12 07:54:01,036 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toChar().uppercase()
2021-03-12 07:54:01,036 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 07:54:01,036 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:01,037 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 07:54:01,037 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toChar().lowercase()
2021-03-12 07:54:01,037 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:54:01,037 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 07:54:01,161 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:54:01,162 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:54:01,163 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).div(1722036161618760515).toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:54:01,163 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:54:01,163 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:54:01,163 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:54:01,163 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toByte().toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:54:01,164 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:54:01,164 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:54:01,164 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:54:01,275 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:54:01,277 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toLong().toString(-1919215517)
2021-03-12 07:54:01,277 [main:114] - replacement of "FAIL 5" of type String is "wexjk"
2021-03-12 07:54:01,384 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(STRING_TEMPLATE)
2021-03-12 07:54:01,384 [main:66] - Compilation checking started
2021-03-12 07:54:01,951 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return prope1.newInstance() as Kla0
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if (prope1.fu4()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if (!prope1.fu3()) return "wexjk"
    try {
        prope1.fu2()
        return "FAIL 6"
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:01,953 [main:107] - replacing ("BOOYA", String)
2021-03-12 07:54:01,955 [main:50] - replacing "BOOYA" String
2021-03-12 07:54:01,955 [main:54] - Getting value of type String
2021-03-12 07:54:02,114 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:54:02,116 [main:58] - GENERATED VALUE OF TYPE String = "xnwmg"
2021-03-12 07:54:02,116 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:02,679 [main:67] - randomType = Triple<Pair<Kla0, Kla1>, Byte, Kla0>
2021-03-12 07:54:02,790 [main:302] - generating value of type = Triple<Pair<Kla0, Kla1>, Byte, Kla0> false depth = 0
2021-03-12 07:54:02,912 [main:43] - GENERATING CALL OF fun <A, B, C> Triple(first: Pair<Kla0, Kla1>, second: Byte, third: Kla0): Triple<Pair<Kla0, Kla1>, Byte, Kla0> = TODO()
2021-03-12 07:54:02,915 [main:61] - WITHOUT TYPE PARAMS = fun <A, B, C> Triple(first: Pair<Kla0, Kla1>, second: Byte, third: Kla0): Triple<Pair<Kla0, Kla1>, Byte, Kla0> = TODO()
2021-03-12 07:54:03,040 [main:302] - generating value of type = Pair<Kla0, Kla1> false depth = 3
2021-03-12 07:54:03,214 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Kla0, second: Kla1): Pair<Kla0, Kla1> = TODO()
2021-03-12 07:54:03,218 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Kla0, second: Kla1): Pair<Kla0, Kla1> = TODO()
2021-03-12 07:54:03,354 [main:302] - generating value of type = Kla0 false depth = 6
2021-03-12 07:54:03,355 [main:112] - generating klass Kla0 text = interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}
2021-03-12 07:54:03,583 [main:302] - generating value of type = Kla1 false depth = 8
2021-03-12 07:54:03,584 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}
2021-03-12 07:54:03,585 [main:302] - generating value of type = Kla1 false depth = 6
2021-03-12 07:54:03,586 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}
2021-03-12 07:54:03,586 [main:95] - GENERATED = Pair<Kla0, Kla1>(Kla1(), Kla1())
2021-03-12 07:54:03,586 [main:302] - generating value of type = Byte true depth = 3
2021-03-12 07:54:03,587 [main:302] - generating value of type = Kla0 false depth = 3
2021-03-12 07:54:03,589 [main:112] - generating klass Kla0 text = interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}
2021-03-12 07:54:03,819 [main:302] - generating value of type = Kla1 false depth = 5
2021-03-12 07:54:03,821 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}
2021-03-12 07:54:03,821 [main:95] - GENERATED = Triple<Pair<Kla0, Kla1>, Byte, Kla0>(Pair<Kla0, Kla1>(Kla1(), Kla1()), 74, Kla1())
2021-03-12 07:54:03,847 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:54:03,848 [main:78] - Generated call from random type = (Triple<Pair<Kla0, Kla1>, Byte, Kla0>(Pair<Kla0, Kla1>(Kla1(), Kla1()), 74, Kla1())).second.toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:54:03,850 [main:106] - GETTING String from Foo
2021-03-12 07:54:03,863 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@2882549a], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:54:03,864 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@2882549a]
2021-03-12 07:54:03,864 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:54:03,865 [main:117] - GENERATED CALL = (f).next().toString(f.next())
2021-03-12 07:54:03,865 [main:114] - replacement of "BOOYA" of type String is (f).next().toString(f.next())
2021-03-12 07:54:04,005 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:04,006 [main:66] - Compilation checking started
2021-03-12 07:54:04,477 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { (f).next().toString(f.next()) }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return prope1.newInstance() as Kla0
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if (prope1.fu4()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if (!prope1.fu3()) return "wexjk"
    try {
        prope1.fu2()
        return "FAIL 6"
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:04,479 [main:107] - replacing (prope1.fu4(), Boolean)
2021-03-12 07:54:04,479 [main:50] - replacing prope1.fu4() Boolean
2021-03-12 07:54:04,479 [main:54] - Getting value of type Boolean
2021-03-12 07:54:04,621 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:04,622 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:54:04,622 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:04,625 [main:67] - randomType = String
2021-03-12 07:54:04,736 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:54:04,771 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@778d9f3d]
2021-03-12 07:54:04,771 [main:149] - GENERATING call of type public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@39e29b5e]
2021-03-12 07:54:04,771 [main:78] - Generated call from random type = ("wkovx").get(f.next()).isISOControl()
2021-03-12 07:54:04,773 [main:106] - GETTING Boolean from Int
2021-03-12 07:54:04,831 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8], public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@37c34207]]
2021-03-12 07:54:04,831 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8]
2021-03-12 07:54:04,949 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:54:04,951 [main:149] - GENERATING call of type public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@37c34207]
2021-03-12 07:54:04,951 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).rangeTo(-16).isEmpty()
2021-03-12 07:54:04,951 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7], public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@54d06bc6]]
2021-03-12 07:54:04,951 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 07:54:04,951 [main:149] - GENERATING call of type public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@54d06bc6]
2021-03-12 07:54:04,951 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()
2021-03-12 07:54:04,952 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]]
2021-03-12 07:54:04,952 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:54:04,952 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]
2021-03-12 07:54:04,952 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toDouble().isInfinite()
2021-03-12 07:54:04,952 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:54:04,952 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:05,067 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:05,067 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:54:05,179 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:05,181 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).equals("osyli").xor(true)
2021-03-12 07:54:05,181 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@546bdc1a]]
2021-03-12 07:54:05,181 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8]
2021-03-12 07:54:05,321 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:54:05,324 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@546bdc1a]
2021-03-12 07:54:05,474 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).rangeTo(0).equals(null)
2021-03-12 07:54:05,475 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@48d86ac1]]
2021-03-12 07:54:05,475 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:05,475 [main:149] - GENERATING call of type public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@48d86ac1]
2021-03-12 07:54:05,475 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toChar().isSurrogate()
2021-03-12 07:54:05,475 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]]
2021-03-12 07:54:05,475 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f]
2021-03-12 07:54:05,596 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:54:05,597 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]
2021-03-12 07:54:05,598 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).div(0.17863765972828738).isFinite()
2021-03-12 07:54:05,598 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4e3e340b]]
2021-03-12 07:54:05,598 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:05,598 [main:149] - GENERATING call of type public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4e3e340b]
2021-03-12 07:54:05,598 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toChar().isLetter()
2021-03-12 07:54:05,598 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:54:05,598 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:05,702 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:05,702 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:54:05,812 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:05,813 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).equals("irqwb").equals("nhbmh")
2021-03-12 07:54:05,813 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@273e47e2]]
2021-03-12 07:54:05,813 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:05,813 [main:149] - GENERATING call of type public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@273e47e2]
2021-03-12 07:54:05,813 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toChar().isTitleCase()
2021-03-12 07:54:05,813 [main:114] - replacement of prope1.fu4() of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()
2021-03-12 07:54:05,956 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:05,957 [main:66] - Compilation checking started
2021-03-12 07:54:06,521 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { (f).next().toString(f.next()) }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return prope1.newInstance() as Kla0
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if (!prope1.fu3()) return "wexjk"
    try {
        prope1.fu2()
        return "FAIL 6"
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:06,524 [main:107] - replacing (true, Boolean)
2021-03-12 07:54:06,525 [main:50] - replacing true Boolean
2021-03-12 07:54:06,526 [main:54] - Getting value of type Boolean
2021-03-12 07:54:06,678 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:06,680 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:54:06,680 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:06,683 [main:67] - randomType = Boolean
2021-03-12 07:54:06,790 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:06,802 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:54:06,920 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:06,923 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:07,034 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:07,034 [main:78] - Generated call from random type = (true).compareTo(true).equals("eljmm")
2021-03-12 07:54:07,034 [main:114] - replacement of true of type Boolean is (true).compareTo(true).equals("eljmm")
2021-03-12 07:54:07,164 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:07,165 [main:66] - Compilation checking started
2021-03-12 07:54:07,650 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { (f).next().toString(f.next()) }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return prope1.newInstance() as Kla0
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if (!prope1.fu3()) return "wexjk"
    try {
        prope1.fu2()
        return "FAIL 6"
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:07,651 [main:107] - replacing (prope2, Boolean)
2021-03-12 07:54:07,652 [main:50] - replacing prope2 Boolean
2021-03-12 07:54:07,653 [main:54] - Getting value of type Boolean
2021-03-12 07:54:07,777 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:07,778 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:54:07,778 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:07,784 [main:67] - randomType = Foo
2021-03-12 07:54:07,898 [main:302] - generating value of type = Foo false depth = 0
2021-03-12 07:54:07,899 [main:112] - generating klass Foo text = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}
2021-03-12 07:54:08,018 [main:194] - Type params = []
2021-03-12 07:54:08,130 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:54:08,132 [main:302] - generating value of type = Function1<Int, Int> false depth = 2
2021-03-12 07:54:08,133 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:54:08,158 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@192c0c82]
2021-03-12 07:54:08,264 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:08,265 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:54:08,265 [main:78] - Generated call from random type = (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
2021-03-12 07:54:08,265 [main:114] - replacement of prope2 of type Boolean is (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
2021-03-12 07:54:08,374 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:08,374 [main:66] - Compilation checking started
2021-03-12 07:54:08,859 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { (f).next().toString(f.next()) }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return prope1.newInstance() as Kla0
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if (!prope1.fu3()) return "wexjk"
    try {
        prope1.fu2()
        return "FAIL 6"
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:08,862 [main:107] - replacing (prope1.newInstance() as Kla0, Kla0)
2021-03-12 07:54:08,863 [main:50] - replacing prope1.newInstance() as Kla0 Kla0
2021-03-12 07:54:08,863 [main:54] - Getting value of type Kla0
2021-03-12 07:54:08,975 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 07:54:08,976 [main:112] - generating klass Kla0 text = interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}
2021-03-12 07:54:09,201 [main:302] - generating value of type = Kla1 false depth = 2
2021-03-12 07:54:09,203 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}
2021-03-12 07:54:09,203 [main:58] - GENERATED VALUE OF TYPE Kla0 = Kla1()
2021-03-12 07:54:09,203 [main:61] - GENERATED IS CALL =true
2021-03-12 07:54:09,206 [main:67] - randomType = Boolean
2021-03-12 07:54:09,341 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:09,357 [main:106] - GETTING Kla0 from Int
2021-03-12 07:54:09,414 [main:106] - GETTING Kla0 from Foo
2021-03-12 07:54:09,426 [main:106] - GETTING Kla0 from Int
2021-03-12 07:54:09,427 [main:106] - GETTING Kla0 from Int
2021-03-12 07:54:09,427 [main:106] - GETTING Kla0 from Function1<Int, Int>
2021-03-12 07:54:09,440 [main:114] - replacement of prope1.newInstance() as Kla0 of type Kla0 is Kla1()
2021-03-12 07:54:09,568 [main:33] - Trying to replace Element(BINARY_WITH_TYPE) on Element(CALL_EXPRESSION)
2021-03-12 07:54:09,568 [main:66] - Compilation checking started
2021-03-12 07:54:10,052 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { (f).next().toString(f.next()) }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if (!prope1.fu3()) return "wexjk"
    try {
        prope1.fu2()
        return "FAIL 6"
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:10,054 [main:107] - replacing (prope2, Boolean)
2021-03-12 07:54:10,054 [main:50] - replacing prope2 Boolean
2021-03-12 07:54:10,054 [main:54] - Getting value of type Boolean
2021-03-12 07:54:10,163 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:10,164 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:54:10,164 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:10,560 [main:67] - randomType = HashMap<HashMap<Boolean, Char>, String?>
2021-03-12 07:54:10,677 [main:302] - generating value of type = HashMap<HashMap<Boolean, Char>, String?> false depth = 0
2021-03-12 07:54:10,788 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(): HashMap<HashMap<Boolean, Char>, Strg?> = TODO()
2021-03-12 07:54:10,791 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(): HashMap<HashMap<Boolean, Char>, Strg?> = TODO()
2021-03-12 07:54:10,910 [main:95] - GENERATED = linkedMapOf<HashMap<Boolean, Char>, String?>()
2021-03-12 07:54:11,122 [main:149] - GENERATING call of type public abstract fun add(element: kotlin.String?): kotlin.Boolean defined in kotlin.collections.MutableCollection[DeserializedSimpleFunctionDescriptor@2a234ae]
2021-03-12 07:54:11,259 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:54:11,261 [main:78] - Generated call from random type = (linkedMapOf<HashMap<Boolean, Char>, String?>()).values.add("baoqf")
2021-03-12 07:54:11,262 [main:106] - GETTING Boolean from Function1<Int, Int>
2021-03-12 07:54:11,277 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:54:11,277 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:11,385 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:11,386 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:54:11,386 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("ocoxt").not()
2021-03-12 07:54:11,386 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]]
2021-03-12 07:54:11,386 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:11,520 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:11,521 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("qugae")
2021-03-12 07:54:11,521 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:54:11,521 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:11,636 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:11,637 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:54:11,769 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:11,772 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("huboe").or(true)
2021-03-12 07:54:11,772 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:54:11,772 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:11,882 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:11,882 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:54:11,993 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:11,995 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("hmkbk").xor(true)
2021-03-12 07:54:11,995 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:54:11,995 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:12,113 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:12,113 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:54:12,239 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:12,240 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("bhcbg").equals("rebsh")
2021-03-12 07:54:12,240 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:54:12,240 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:12,350 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:12,350 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:54:12,522 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:12,524 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("vgnhd").and(true)
2021-03-12 07:54:12,525 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:54:12,525 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13]
2021-03-12 07:54:12,669 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:54:12,671 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:12,787 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:12,788 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).invoke(-2090344343).equals("ycmia")
2021-03-12 07:54:12,955 [main:114] - replacement of prope2 of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).f).equals("hmkbk").xor(true)
2021-03-12 07:54:13,063 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:13,064 [main:66] - Compilation checking started
2021-03-12 07:54:13,401 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { (Foo(-655341081, {a: Int -> 120045518}).f).equals("hmkbk").xor(true) = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { (f).next().toString(f.next()) }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if (!prope1.fu3()) return "wexjk"
    try {
        prope1.fu2()
        return "FAIL 6"
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:13,403 [main:107] - replacing (!prope1.fu3(), Boolean)
2021-03-12 07:54:13,403 [main:50] - replacing !prope1.fu3() Boolean
2021-03-12 07:54:13,403 [main:54] - Getting value of type Boolean
2021-03-12 07:54:13,516 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:13,517 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:54:13,517 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:13,520 [main:67] - randomType = String
2021-03-12 07:54:13,647 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:54:13,674 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:13,785 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:13,785 [main:78] - Generated call from random type = ("twpxj").length.equals("nrcee")
2021-03-12 07:54:13,786 [main:106] - GETTING Boolean from Function1<Int, Int>
2021-03-12 07:54:13,800 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:54:13,800 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13]
2021-03-12 07:54:13,800 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:13,907 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:13,908 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).invoke(Foo(-655341081, {a: Int -> 120045518}).state).equals("bvtqp")
2021-03-12 07:54:13,908 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:54:13,908 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:14,011 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:14,012 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:54:14,129 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:14,131 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("ylqyh").and(true)
2021-03-12 07:54:14,131 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:54:14,131 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:14,242 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:14,242 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:54:14,353 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:14,355 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("yqozn").xor(true)
2021-03-12 07:54:14,355 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]]
2021-03-12 07:54:14,355 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:14,479 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:14,479 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("gcznv")
2021-03-12 07:54:14,479 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:54:14,479 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:14,596 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:14,597 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:54:14,700 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:14,701 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("ipmqx").equals("nivxo")
2021-03-12 07:54:14,701 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:54:14,701 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:14,807 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:54:14,917 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:14,919 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals(null).or(false)
2021-03-12 07:54:14,919 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:54:14,919 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:15,026 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:15,026 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:54:15,026 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()
2021-03-12 07:54:15,027 [main:114] - replacement of !prope1.fu3() of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()
2021-03-12 07:54:15,127 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:15,127 [main:66] - Compilation checking started
2021-03-12 07:54:15,602 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { (f).next().toString(f.next()) }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return "FAIL 6"
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:15,604 [main:107] - replacing ({ "BOOYA" }, Function0<String>)
2021-03-12 07:54:15,605 [main:50] - replacing { "BOOYA" } Function0<String>
2021-03-12 07:54:15,605 [main:54] - Getting value of type Function0<String>
2021-03-12 07:54:15,722 [main:302] - generating value of type = Function0<String> false depth = 0
2021-03-12 07:54:15,724 [main:302] - generating value of type = String true depth = 1
2021-03-12 07:54:15,725 [main:58] - GENERATED VALUE OF TYPE Function0<String> = { "meyol"}
2021-03-12 07:54:15,725 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:15,861 [main:67] - randomType = HashSet<Int>
2021-03-12 07:54:15,964 [main:302] - generating value of type = HashSet<Int> false depth = 0
2021-03-12 07:54:16,073 [main:43] - GENERATING CALL OF fun <T> linkedSetOf(elements: Int): HashSet<Int> = TODO()
2021-03-12 07:54:16,076 [main:61] - WITHOUT TYPE PARAMS = fun <T> linkedSetOf(elements: Int): HashSet<Int> = TODO()
2021-03-12 07:54:16,184 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:54:16,186 [main:95] - GENERATED = linkedSetOf<Int>(-874970007)
2021-03-12 07:54:16,341 [main:106] - GETTING Function0<String> from Foo
2021-03-12 07:54:16,353 [main:106] - GETTING Function0<String> from Int
2021-03-12 07:54:16,409 [main:106] - GETTING Function0<String> from Int
2021-03-12 07:54:16,410 [main:106] - GETTING Function0<String> from Function1<Int, Int>
2021-03-12 07:54:16,424 [main:106] - GETTING Function0<String> from Int
2021-03-12 07:54:16,424 [main:114] - replacement of { "BOOYA" } of type Function0<String> is { "meyol"}
2021-03-12 07:54:16,548 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 07:54:16,549 [main:66] - Compilation checking started
2021-03-12 07:54:16,998 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { (f).next().toString(f.next()) }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return "FAIL 6"
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:17,000 [main:107] - replacing ("FAIL 6", String)
2021-03-12 07:54:17,000 [main:50] - replacing "FAIL 6" String
2021-03-12 07:54:17,001 [main:54] - Getting value of type String
2021-03-12 07:54:17,110 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:54:17,111 [main:58] - GENERATED VALUE OF TYPE String = "nfsmj"
2021-03-12 07:54:17,111 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:17,359 [main:67] - randomType = UByte?
2021-03-12 07:54:17,468 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 07:54:17,511 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@8a48ecb]
2021-03-12 07:54:17,511 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:54:17,512 [main:78] - Generated call from random type = (78.toUByte())?.toByte().toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:54:17,513 [main:106] - GETTING String from Int
2021-03-12 07:54:17,566 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 07:54:17,566 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:17,567 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 07:54:17,567 [main:117] - GENERATED CALL = (f.next()).toChar().lowercase()
2021-03-12 07:54:17,567 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:54:17,567 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:54:17,567 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:54:17,567 [main:117] - GENERATED CALL = (f.next()).toLong().toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:54:17,567 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 07:54:17,567 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:54:17,568 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:54:17,669 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:54:17,670 [main:117] - GENERATED CALL = (f.next()).toShort().toString(-1219843953)
2021-03-12 07:54:17,671 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:54:17,671 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 07:54:17,796 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:54:17,798 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:54:17,798 [main:117] - GENERATED CALL = (f.next()).div(4775979485786854000).toString(f.next())
2021-03-12 07:54:17,798 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:54:17,798 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:54:17,799 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:54:17,799 [main:117] - GENERATED CALL = (f.next()).toInt().toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:54:17,799 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:54:17,799 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:54:17,900 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:54:17,901 [main:117] - GENERATED CALL = (f.next()).toString(-908035683)
2021-03-12 07:54:17,901 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]]
2021-03-12 07:54:17,901 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:17,901 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]
2021-03-12 07:54:17,902 [main:117] - GENERATED CALL = (f.next()).toChar().uppercase()
2021-03-12 07:54:17,902 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 07:54:17,902 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:17,902 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 07:54:18,009 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:54:18,011 [main:117] - GENERATED CALL = (f.next()).toChar().plus("xywfn")
2021-03-12 07:54:18,011 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:54:18,011 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:54:18,011 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:54:18,011 [main:117] - GENERATED CALL = (f.next()).toByte().toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:54:18,011 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 07:54:18,011 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:18,012 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 07:54:18,012 [main:117] - GENERATED CALL = (f.next()).toChar().titlecase()
2021-03-12 07:54:18,012 [main:114] - replacement of "FAIL 6" of type String is (f.next()).toChar().uppercase()
2021-03-12 07:54:18,118 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:18,118 [main:66] - Compilation checking started
2021-03-12 07:54:18,556 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { (f).next().toString(f.next()) }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:18,559 [main:107] - replacing (prope3, Function0<Boolean>)
2021-03-12 07:54:18,559 [main:50] - replacing prope3 Function0<Boolean>
2021-03-12 07:54:18,559 [main:54] - Getting value of type Function0<Boolean>
2021-03-12 07:54:18,671 [main:302] - generating value of type = Function0<Boolean> false depth = 0
2021-03-12 07:54:18,672 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 07:54:18,673 [main:58] - GENERATED VALUE OF TYPE Function0<Boolean> = { true}
2021-03-12 07:54:18,674 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:18,679 [main:67] - randomType = Foo
2021-03-12 07:54:18,780 [main:302] - generating value of type = Foo false depth = 0
2021-03-12 07:54:18,782 [main:112] - generating klass Foo text = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}
2021-03-12 07:54:18,903 [main:194] - Type params = []
2021-03-12 07:54:19,007 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:54:19,009 [main:302] - generating value of type = Function1<Int, Int> false depth = 2
2021-03-12 07:54:19,010 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:54:19,020 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:54:19,050 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:54:19,058 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:54:19,059 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:54:19,060 [main:106] - GETTING Function0<Boolean> from Function1<Int, Int>
2021-03-12 07:54:19,071 [main:114] - replacement of prope3 of type Function0<Boolean> is { true}
2021-03-12 07:54:19,173 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 07:54:19,174 [main:66] - Compilation checking started
2021-03-12 07:54:19,632 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { (f).next().toString(f.next()) }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:19,635 [main:107] - replacing (prope2, Boolean)
2021-03-12 07:54:19,636 [main:50] - replacing prope2 Boolean
2021-03-12 07:54:19,636 [main:54] - Getting value of type Boolean
2021-03-12 07:54:19,758 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:19,760 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:54:19,760 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:20,001 [main:67] - randomType = UShort?
2021-03-12 07:54:20,122 [main:302] - generating value of type = UShort true depth = 0
2021-03-12 07:54:20,167 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@562a88ef]
2021-03-12 07:54:20,274 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:20,274 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:54:20,389 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:20,391 [main:78] - Generated call from random type = (11290.toUShort())?.equals("lmsmc").or(false)
2021-03-12 07:54:20,392 [main:106] - GETTING Boolean from Function1<Int, Int>
2021-03-12 07:54:20,405 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:54:20,406 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:20,514 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:20,514 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:54:20,628 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:20,630 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("affil").xor(false)
2021-03-12 07:54:20,630 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:54:20,630 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:20,739 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:20,739 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:54:20,850 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:20,850 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("pthfj").equals("ocfjc")
2021-03-12 07:54:20,850 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:54:20,850 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:20,956 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:20,956 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:54:20,956 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("rhtue").not()
2021-03-12 07:54:20,956 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:54:20,956 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:21,060 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:21,060 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:54:21,183 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:21,185 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
2021-03-12 07:54:21,185 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:54:21,185 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13]
2021-03-12 07:54:21,292 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:54:21,294 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:21,398 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:21,399 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).invoke(2064802303).equals("xujic")
2021-03-12 07:54:21,399 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]]
2021-03-12 07:54:21,399 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:21,502 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:21,502 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("dovuv")
2021-03-12 07:54:21,502 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:54:21,502 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:21,606 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:21,606 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:54:21,708 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:21,710 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("lwqaj").or(true)
2021-03-12 07:54:21,710 [main:114] - replacement of prope2 of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
2021-03-12 07:54:21,814 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:21,815 [main:66] - Compilation checking started
2021-03-12 07:54:22,272 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { (f).next().toString(f.next()) }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:22,274 [main:107] - replacing (true, Boolean)
2021-03-12 07:54:22,274 [main:50] - replacing true Boolean
2021-03-12 07:54:22,274 [main:54] - Getting value of type Boolean
2021-03-12 07:54:22,395 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:22,396 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:54:22,396 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:22,522 [main:67] - randomType = Kla0?
2021-03-12 07:54:22,523 [main:106] - GETTING Boolean from Int
2021-03-12 07:54:22,560 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@559f74f6]]
2021-03-12 07:54:22,561 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:22,561 [main:149] - GENERATING call of type public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@559f74f6]
2021-03-12 07:54:22,561 [main:117] - GENERATED CALL = (f.next()).toChar().isLowerCase()
2021-03-12 07:54:22,561 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.IntRange.contains(element: kotlin.Int?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@2ae1e7e0]]
2021-03-12 07:54:22,561 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8]
2021-03-12 07:54:22,666 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:54:22,668 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.IntRange.contains(element: kotlin.Int?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@2ae1e7e0]
2021-03-12 07:54:22,773 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:54:22,775 [main:117] - GENERATED CALL = (f.next()).rangeTo(112).contains(-1627669397)
2021-03-12 07:54:22,775 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:54:22,775 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:54:22,775 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:22,885 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:22,885 [main:117] - GENERATED CALL = (f.next()).toInt().equals("cxric")
2021-03-12 07:54:22,885 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:54:22,885 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:22,994 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:22,994 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:54:22,995 [main:117] - GENERATED CALL = (f.next()).equals("mcdzm").not()
2021-03-12 07:54:22,995 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:54:22,995 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:23,103 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:23,103 [main:117] - GENERATED CALL = (f.next()).equals("euyuw")
2021-03-12 07:54:23,103 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@4e4fe7ba]]
2021-03-12 07:54:23,103 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 07:54:23,103 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@4e4fe7ba]
2021-03-12 07:54:23,213 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:23,214 [main:117] - GENERATED CALL = (f.next()).toFloat().equals("hfgrp")
2021-03-12 07:54:23,214 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@9f659]]
2021-03-12 07:54:23,214 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:23,214 [main:149] - GENERATING call of type public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@9f659]
2021-03-12 07:54:23,214 [main:117] - GENERATED CALL = (f.next()).toChar().isDefined()
2021-03-12 07:54:23,214 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8], public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@37c34207]]
2021-03-12 07:54:23,214 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8]
2021-03-12 07:54:23,319 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:54:23,320 [main:149] - GENERATING call of type public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@37c34207]
2021-03-12 07:54:23,320 [main:117] - GENERATED CALL = (f.next()).rangeTo(75).isEmpty()
2021-03-12 07:54:23,321 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]]
2021-03-12 07:54:23,321 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:54:23,321 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]
2021-03-12 07:54:23,321 [main:117] - GENERATED CALL = (f.next()).toDouble().isFinite()
2021-03-12 07:54:23,321 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@273e47e2]]
2021-03-12 07:54:23,321 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:23,321 [main:149] - GENERATING call of type public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@273e47e2]
2021-03-12 07:54:23,321 [main:117] - GENERATED CALL = (f.next()).toChar().isTitleCase()
2021-03-12 07:54:23,321 [main:114] - replacement of true of type Boolean is (f.next()).toChar().isDefined()
2021-03-12 07:54:23,446 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:23,446 [main:66] - Compilation checking started
2021-03-12 07:54:23,887 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { (f).next().toString(f.next()) }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:23,889 [main:107] - replacing (prope2, Boolean)
2021-03-12 07:54:23,889 [main:50] - replacing prope2 Boolean
2021-03-12 07:54:23,889 [main:54] - Getting value of type Boolean
2021-03-12 07:54:24,005 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:24,006 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:54:24,007 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:24,013 [main:67] - randomType = Kla1
2021-03-12 07:54:24,125 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 07:54:24,127 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}
2021-03-12 07:54:24,137 [main:149] - GENERATING call of type public open fun fu1(): kotlin.Boolean defined in Kla1[SimpleFunctionDescriptorImpl@2e68b592]
2021-03-12 07:54:24,137 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:54:24,248 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:24,250 [main:78] - Generated call from random type = (Kla1()).fu1().and(false)
2021-03-12 07:54:24,251 [main:106] - GETTING Boolean from Int
2021-03-12 07:54:24,306 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:54:24,306 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:24,418 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:24,418 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:54:24,532 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:24,534 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("qwzrz").and(false)
2021-03-12 07:54:24,534 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2c57ad81]]
2021-03-12 07:54:24,535 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:54:24,535 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2c57ad81]
2021-03-12 07:54:24,648 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:24,649 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toByte().equals("nomoh")
2021-03-12 07:54:24,649 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55530794]]
2021-03-12 07:54:24,649 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:24,649 [main:149] - GENERATING call of type public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55530794]
2021-03-12 07:54:24,649 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isUpperCase()
2021-03-12 07:54:24,649 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@4e4fe7ba]]
2021-03-12 07:54:24,649 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 07:54:24,649 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@4e4fe7ba]
2021-03-12 07:54:24,754 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:24,754 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toFloat().equals("mymsh")
2021-03-12 07:54:24,754 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@48d86ac1]]
2021-03-12 07:54:24,754 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:24,755 [main:149] - GENERATING call of type public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@48d86ac1]
2021-03-12 07:54:24,755 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isSurrogate()
2021-03-12 07:54:24,755 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@34594779]]
2021-03-12 07:54:24,755 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f]
2021-03-12 07:54:24,874 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:54:24,875 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@34594779]
2021-03-12 07:54:24,989 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:24,990 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).div(0.9489686384922569).equals("hjbgo")
2021-03-12 07:54:24,990 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7], public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@a67e46]]
2021-03-12 07:54:24,990 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 07:54:24,990 [main:149] - GENERATING call of type public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@a67e46]
2021-03-12 07:54:24,990 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toFloat().isInfinite()
2021-03-12 07:54:24,990 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.IntRange.contains(element: kotlin.Int?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@2ae1e7e0]]
2021-03-12 07:54:24,990 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8]
2021-03-12 07:54:25,093 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:54:25,095 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.IntRange.contains(element: kotlin.Int?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@2ae1e7e0]
2021-03-12 07:54:25,197 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:54:25,199 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).rangeTo(-1).contains(-1159367166)
2021-03-12 07:54:25,199 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@6970ad8]]
2021-03-12 07:54:25,199 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:54:25,199 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@6970ad8]
2021-03-12 07:54:25,199 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toDouble().isNaN()
2021-03-12 07:54:25,199 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@53d33965]]
2021-03-12 07:54:25,199 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:25,199 [main:149] - GENERATING call of type public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@53d33965]
2021-03-12 07:54:25,200 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isWhitespace()
2021-03-12 07:54:25,200 [main:114] - replacement of prope2 of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).next()).toFloat().equals("mymsh")
2021-03-12 07:54:25,302 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:25,303 [main:66] - Compilation checking started
2021-03-12 07:54:25,590 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { (Foo(-655341081, {a: Int -> 120045518}).next()).toFloat().equals("mymsh") = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { (f).next().toString(f.next()) }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:25,592 [main:107] - replacing (prope2, Boolean)
2021-03-12 07:54:25,592 [main:50] - replacing prope2 Boolean
2021-03-12 07:54:25,592 [main:54] - Getting value of type Boolean
2021-03-12 07:54:25,697 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:25,699 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:54:25,699 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:25,702 [main:67] - randomType = Char
2021-03-12 07:54:25,808 [main:302] - generating value of type = Char true depth = 0
2021-03-12 07:54:25,832 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Char): kotlin.ranges.CharRange defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@37033745]
2021-03-12 07:54:25,938 [main:302] - generating value of type = Char true depth = 0
2021-03-12 07:54:25,939 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.ranges.CharRange[DeserializedSimpleFunctionDescriptor@259618e1]
2021-03-12 07:54:26,046 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:26,046 [main:78] - Generated call from random type = ('').rangeTo('').equals("dbxkf")
2021-03-12 07:54:26,046 [main:114] - replacement of prope2 of type Boolean is ('').rangeTo('').equals("dbxkf")
2021-03-12 07:54:26,168 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:26,169 [main:66] - Compilation checking started
2021-03-12 07:54:26,457 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { ('').rangeTo('').equals("dbxkf") = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { (f).next().toString(f.next()) }
        }
        prope4()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:26,460 [main:107] - replacing (prope4, Function0<Unit>)
2021-03-12 07:54:26,460 [main:50] - replacing prope4 Function0<Unit>
2021-03-12 07:54:26,460 [main:54] - Getting value of type Function0<Unit>
2021-03-12 07:54:26,572 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 07:54:26,573 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 07:54:26,579 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { println()}
2021-03-12 07:54:26,580 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:28,068 [main:67] - randomType = HashMap<Double?, Function1<Map<Function1<ULong, UShort>, Byte>?, Collection<UShort>>>
2021-03-12 07:54:28,175 [main:302] - generating value of type = HashMap<Double?, Function1<Map<Function1<ULong, UShort>, Byte>?, Collection<UShort>>> false depth = 0
2021-03-12 07:54:28,293 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(pairs: Pair<Double?, Function1<Map<Function1<ULong, UShort>, Byte>?, Collection<UShort>>>): HashMap<Double?, Function1<Map<Function1<ULong, UShort>, Byte>?, Collection<UShort>>> = TODO()
2021-03-12 07:54:28,296 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(pairs: Pair<Double?, Function1<Map<Function1<ULong, UShort>, Byte>?, Collection<UShort>>>): HashMap<Double?, Function1<Map<Function1<ULong, UShort>, Byte>?, Collection<UShort>>> = TODO()
2021-03-12 07:54:28,408 [main:302] - generating value of type = Pair<Double?, Function1<Map<Function1<ULong, UShort>, Byte>?, Collection<UShort>>> false depth = 3
2021-03-12 07:54:28,521 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Double?, second: Function1<Map<Function1<ULong, UShort>, Byte>?, Collection<UShort>>): Pair<Double?, Function1<Map<Function1<ULong, UShort>, Byte>?, Collection<UShort>>> = TODO()
2021-03-12 07:54:28,524 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Double?, second: Function1<Map<Function1<ULong, UShort>, Byte>?, Collection<UShort>>): Pair<Double?, Function1<Map<Function1<ULong, UShort>, Byte>?, Collection<UShort>>> = TODO()
2021-03-12 07:54:28,634 [main:302] - generating value of type = Double true depth = 6
2021-03-12 07:54:28,635 [main:302] - generating value of type = Function1<Map<Function1<ULong, UShort>, Byte>?, Collection<UShort>> false depth = 6
2021-03-12 07:54:28,637 [main:302] - generating value of type = Collection<UShort> false depth = 7
2021-03-12 07:54:28,781 [main:43] - GENERATING CALL OF fun <T> listOfNotNull(elements: UShort): Collection<UShort> = TODO()
2021-03-12 07:54:28,784 [main:61] - WITHOUT TYPE PARAMS = fun <T> listOfNotNull(elements: UShort): Collection<UShort> = TODO()
2021-03-12 07:54:28,916 [main:302] - generating value of type = UShort true depth = 10
2021-03-12 07:54:28,918 [main:95] - GENERATED = listOfNotNull<UShort>(23809.toUShort())
2021-03-12 07:54:28,918 [main:95] - GENERATED = Pair<Double?, Function1<Map<Function1<ULong, UShort>, Byte>?, Collection<UShort>>>(0.19153145092573265, {a: Map<Function1<ULong, UShort>, Byte>? -> listOfNotNull<UShort>(23809.toUShort())})
2021-03-12 07:54:28,919 [main:95] - GENERATED = linkedMapOf<Double?, Function1<Map<Function1<ULong, UShort>, Byte>?, Collection<UShort>>>(Pair<Double?, Function1<Map<Function1<ULong, UShort>, Byte>?, Collection<UShort>>>(0.19153145092573265, {a: Map<Function1<ULong, UShort>, Byte>? -> listOfNotNull<UShort>(23809.toUShort())}))
2021-03-12 07:54:29,155 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:54:29,164 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:54:29,196 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:54:29,197 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:54:29,198 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:54:29,210 [main:114] - replacement of prope4 of type Function0<Unit> is { println()}
2021-03-12 07:54:29,313 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 07:54:29,314 [main:66] - Compilation checking started
2021-03-12 07:54:29,772 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { (f).next().toString(f.next()) }
        }
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:29,774 [main:107] - replacing ({ "BOOYA" }, Function0<String>)
2021-03-12 07:54:29,774 [main:50] - replacing { "BOOYA" } Function0<String>
2021-03-12 07:54:29,774 [main:54] - Getting value of type Function0<String>
2021-03-12 07:54:29,926 [main:302] - generating value of type = Function0<String> false depth = 0
2021-03-12 07:54:29,928 [main:302] - generating value of type = String true depth = 1
2021-03-12 07:54:29,930 [main:58] - GENERATED VALUE OF TYPE Function0<String> = { "gjdsy"}
2021-03-12 07:54:29,930 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:30,178 [main:67] - randomType = Kla2?
2021-03-12 07:54:30,291 [main:302] - generating value of type = Kla2 false depth = 0
2021-03-12 07:54:30,293 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { (f).next().toString(f.next()) }
        }
        { println()}()
        return prope2
    }
}
2021-03-12 07:54:30,304 [main:106] - GETTING Function0<String> from Function1<Int, Int>
2021-03-12 07:54:30,319 [main:106] - GETTING Function0<String> from Foo
2021-03-12 07:54:30,330 [main:106] - GETTING Function0<String> from Int
2021-03-12 07:54:30,391 [main:106] - GETTING Function0<String> from Int
2021-03-12 07:54:30,392 [main:106] - GETTING Function0<String> from Int
2021-03-12 07:54:30,392 [main:114] - replacement of { "BOOYA" } of type Function0<String> is { "gjdsy"}
2021-03-12 07:54:30,506 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 07:54:30,506 [main:66] - Compilation checking started
2021-03-12 07:54:30,953 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { (f).next().toString(f.next()) }
        }
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else "localAnonymousFunction.ShouldBeDisabled")
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:30,955 [main:107] - replacing ("localAnonymousFunction.ShouldBeDisabled", String)
2021-03-12 07:54:30,955 [main:50] - replacing "localAnonymousFunction.ShouldBeDisabled" String
2021-03-12 07:54:30,956 [main:54] - Getting value of type String
2021-03-12 07:54:31,063 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:54:31,065 [main:58] - GENERATED VALUE OF TYPE String = "akjer"
2021-03-12 07:54:31,065 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:31,071 [main:67] - randomType = Foo
2021-03-12 07:54:31,175 [main:302] - generating value of type = Foo false depth = 0
2021-03-12 07:54:31,176 [main:112] - generating klass Foo text = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}
2021-03-12 07:54:31,298 [main:194] - Type params = []
2021-03-12 07:54:31,400 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:54:31,402 [main:302] - generating value of type = Function1<Int, Int> false depth = 2
2021-03-12 07:54:31,403 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:54:31,413 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@78f08f2c]
2021-03-12 07:54:31,413 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:54:31,413 [main:78] - Generated call from random type = (Foo(286101772, {a: Int -> -1345093671})).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:54:31,414 [main:106] - GETTING String from Int
2021-03-12 07:54:31,443 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]]
2021-03-12 07:54:31,443 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:31,443 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]
2021-03-12 07:54:31,443 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().uppercase()
2021-03-12 07:54:31,444 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 07:54:31,444 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:31,444 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 07:54:31,444 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().lowercase()
2021-03-12 07:54:31,444 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:54:31,444 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:54:31,444 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:54:31,444 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).compareTo(f.next()).toString(f.next())
2021-03-12 07:54:31,444 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 07:54:31,444 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:54:31,445 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:54:31,546 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:54:31,548 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toShort().toString(-712691216)
2021-03-12 07:54:31,548 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:54:31,548 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:54:31,548 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:54:31,652 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:54:31,654 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toInt().toString(-963303375)
2021-03-12 07:54:31,654 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:54:31,655 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:54:31,655 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:54:31,655 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:54:31,655 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:54:31,655 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:54:31,655 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toByte().toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:54:31,656 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 07:54:31,656 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:31,656 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 07:54:31,656 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().titlecase()
2021-03-12 07:54:31,656 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 07:54:31,656 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:31,656 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 07:54:31,760 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:54:31,762 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf")
2021-03-12 07:54:31,762 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:54:31,762 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:54:31,762 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:54:31,762 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toLong().toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:54:31,762 [main:114] - replacement of "localAnonymousFunction.ShouldBeDisabled" of type String is (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf")
2021-03-12 07:54:31,864 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:31,865 [main:66] - Compilation checking started
2021-03-12 07:54:32,279 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { (f).next().toString(f.next()) }
        }
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:32,282 [main:107] - replacing (prope2, Boolean)
2021-03-12 07:54:32,282 [main:50] - replacing prope2 Boolean
2021-03-12 07:54:32,282 [main:54] - Getting value of type Boolean
2021-03-12 07:54:32,404 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:32,406 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:54:32,406 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:32,534 [main:67] - randomType = Kla1?
2021-03-12 07:54:32,660 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 07:54:32,663 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}
2021-03-12 07:54:32,669 [main:149] - GENERATING call of type public open fun fu2(): kotlin.Boolean defined in Kla1[SimpleFunctionDescriptorImpl@3f5a3c02]
2021-03-12 07:54:32,669 [main:78] - Generated call from random type = (Kla1())?.fu2()
2021-03-12 07:54:32,670 [main:106] - GETTING Boolean from Function1<Int, Int>
2021-03-12 07:54:32,679 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]]
2021-03-12 07:54:32,680 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:32,787 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:32,787 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("krptu")
2021-03-12 07:54:32,787 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:54:32,787 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:32,895 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:32,896 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:54:33,002 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:33,004 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("dlayw").xor(true)
2021-03-12 07:54:33,004 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:54:33,004 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:33,109 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:33,110 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:54:33,214 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:33,215 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("dlkhg").equals("dqgdw")
2021-03-12 07:54:33,215 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:54:33,215 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13]
2021-03-12 07:54:33,319 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:54:33,321 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:33,426 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:33,427 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).invoke(-951687393).equals("jdmvi")
2021-03-12 07:54:33,427 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:54:33,427 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:33,531 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:33,531 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:54:33,659 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:33,661 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("anwpe").or(true)
2021-03-12 07:54:33,661 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:54:33,661 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:33,778 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:33,778 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:54:33,778 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("kmhcu").not()
2021-03-12 07:54:33,778 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:54:33,778 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:33,886 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:33,886 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:54:33,990 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:33,992 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("fxpyo").and(false)
2021-03-12 07:54:33,992 [main:114] - replacement of prope2 of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).f).equals("fxpyo").and(false)
2021-03-12 07:54:34,098 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:34,099 [main:66] - Compilation checking started
2021-03-12 07:54:34,374 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { (Foo(-655341081, {a: Int -> 120045518}).f).equals("fxpyo").and(false) = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { (f).next().toString(f.next()) }
        }
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:34,376 [main:107] - replacing (prope2, Boolean)
2021-03-12 07:54:34,376 [main:50] - replacing prope2 Boolean
2021-03-12 07:54:34,376 [main:54] - Getting value of type Boolean
2021-03-12 07:54:34,485 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:34,487 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:54:34,487 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:34,495 [main:67] - randomType = Kla1
2021-03-12 07:54:34,600 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 07:54:34,602 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}
2021-03-12 07:54:34,609 [main:149] - GENERATING call of type public open fun fu4(): kotlin.Boolean defined in Kla1[SimpleFunctionDescriptorImpl@109072c9]
2021-03-12 07:54:34,609 [main:78] - Generated call from random type = (Kla1()).fu4()
2021-03-12 07:54:34,610 [main:106] - GETTING Boolean from Function1<Int, Int>
2021-03-12 07:54:34,620 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:54:34,620 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:34,724 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:34,724 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:54:34,847 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:34,849 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("sjvjv").or(true)
2021-03-12 07:54:34,849 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:54:34,849 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:34,953 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:34,953 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:54:35,059 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("jdwyy").equals(null)
2021-03-12 07:54:35,059 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:54:35,059 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13]
2021-03-12 07:54:35,060 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:35,163 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:35,164 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).invoke(f.next()).equals("pfgoq")
2021-03-12 07:54:35,164 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:54:35,164 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:35,271 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:35,271 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:54:35,376 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:35,378 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("dwfmm").xor(true)
2021-03-12 07:54:35,378 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:54:35,378 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:35,485 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:35,485 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:54:35,589 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:35,591 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("incpc").and(false)
2021-03-12 07:54:35,591 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]]
2021-03-12 07:54:35,591 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:35,694 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:35,695 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("oydeg")
2021-03-12 07:54:35,695 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:54:35,695 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:35,800 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:35,801 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:54:35,801 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("ukvnd").not()
2021-03-12 07:54:35,801 [main:114] - replacement of prope2 of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).f).equals("oydeg")
2021-03-12 07:54:35,905 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:35,905 [main:66] - Compilation checking started
2021-03-12 07:54:36,205 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { (Foo(-655341081, {a: Int -> 120045518}).f).equals("oydeg") = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { (f).next().toString(f.next()) }
        }
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:36,207 [main:107] - replacing (prope3, Function0<Boolean>)
2021-03-12 07:54:36,207 [main:50] - replacing prope3 Function0<Boolean>
2021-03-12 07:54:36,207 [main:54] - Getting value of type Function0<Boolean>
2021-03-12 07:54:36,311 [main:302] - generating value of type = Function0<Boolean> false depth = 0
2021-03-12 07:54:36,313 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 07:54:36,315 [main:58] - GENERATED VALUE OF TYPE Function0<Boolean> = { true}
2021-03-12 07:54:36,315 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:36,563 [main:67] - randomType = Pair<Kla1, UShort>
2021-03-12 07:54:36,667 [main:302] - generating value of type = Pair<Kla1, UShort> false depth = 0
2021-03-12 07:54:36,778 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Kla1, second: UShort): Pair<Kla1, UShort> = TODO()
2021-03-12 07:54:36,781 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Kla1, second: UShort): Pair<Kla1, UShort> = TODO()
2021-03-12 07:54:36,895 [main:302] - generating value of type = Kla1 false depth = 3
2021-03-12 07:54:36,897 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}
2021-03-12 07:54:36,897 [main:302] - generating value of type = UShort true depth = 3
2021-03-12 07:54:36,899 [main:95] - GENERATED = Pair<Kla1, UShort>(Kla1(), 5559.toUShort())
2021-03-12 07:54:36,912 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:54:36,920 [main:106] - GETTING Function0<Boolean> from Function1<Int, Int>
2021-03-12 07:54:36,930 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:54:36,960 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:54:36,961 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:54:36,961 [main:114] - replacement of prope3 of type Function0<Boolean> is { true}
2021-03-12 07:54:37,065 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 07:54:37,066 [main:66] - Compilation checking started
2021-03-12 07:54:37,521 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { (f).next().toString(f.next()) }
        }
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = fu0(true)
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:37,524 [main:107] - replacing (fu0(true), Kla0)
2021-03-12 07:54:37,524 [main:50] - replacing fu0(true) Kla0
2021-03-12 07:54:37,524 [main:54] - Getting value of type Kla0
2021-03-12 07:54:37,634 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 07:54:37,637 [main:112] - generating klass Kla0 text = interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}
2021-03-12 07:54:37,876 [main:302] - generating value of type = Kla1 false depth = 2
2021-03-12 07:54:37,878 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}
2021-03-12 07:54:37,879 [main:58] - GENERATED VALUE OF TYPE Kla0 = Kla1()
2021-03-12 07:54:37,879 [main:61] - GENERATED IS CALL =true
2021-03-12 07:54:38,237 [main:67] - randomType = Array<ULong?>
2021-03-12 07:54:38,341 [main:302] - generating value of type = Array<ULong?> false depth = 0
2021-03-12 07:54:38,451 [main:43] - GENERATING CALL OF fun <T> Array(size: kotlin.Int, init: (kotlin.Int)->ULong?): Array<ULong?> = TODO()
2021-03-12 07:54:38,454 [main:61] - WITHOUT TYPE PARAMS = fun <T> Array(size: kotlin.Int, init: (kotlin.Int)->ULong?): Array<ULong?> = TODO()
2021-03-12 07:54:38,850 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:54:38,852 [main:302] - generating value of type = Function1<Int, ULong?> false depth = 3
2021-03-12 07:54:38,854 [main:302] - generating value of type = ULong true depth = 4
2021-03-12 07:54:38,857 [main:95] - GENERATED = Array<ULong?>(-824718103, {a: Int -> 6551134166148322223.toULong()})
2021-03-12 07:54:38,875 [main:106] - GETTING Kla0 from Foo
2021-03-12 07:54:38,886 [main:106] - GETTING Kla0 from Int
2021-03-12 07:54:38,922 [main:106] - GETTING Kla0 from Int
2021-03-12 07:54:38,923 [main:106] - GETTING Kla0 from Int
2021-03-12 07:54:38,924 [main:106] - GETTING Kla0 from Function1<Int, Int>
2021-03-12 07:54:38,935 [main:114] - replacement of fu0(true) of type Kla0 is Kla1()
2021-03-12 07:54:39,044 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:54:39,044 [main:66] - Compilation checking started
2021-03-12 07:54:39,493 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { (f).next().toString(f.next()) }
        }
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:39,494 [main:107] - replacing ({ prope2 = true; false }, Function0<Boolean>)
2021-03-12 07:54:39,495 [main:50] - replacing { prope2 = true; false } Function0<Boolean>
2021-03-12 07:54:39,495 [main:54] - Getting value of type Function0<Boolean>
2021-03-12 07:54:39,624 [main:302] - generating value of type = Function0<Boolean> false depth = 0
2021-03-12 07:54:39,627 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 07:54:39,628 [main:58] - GENERATED VALUE OF TYPE Function0<Boolean> = { false}
2021-03-12 07:54:39,629 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:39,892 [main:67] - randomType = MutableMap<UShort, Foo>
2021-03-12 07:54:39,893 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:54:39,902 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:54:39,933 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:54:39,934 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:54:39,935 [main:106] - GETTING Function0<Boolean> from Function1<Int, Int>
2021-03-12 07:54:39,945 [main:114] - replacement of { prope2 = true; false } of type Function0<Boolean> is { false}
2021-03-12 07:54:40,051 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 07:54:40,051 [main:66] - Compilation checking started
2021-03-12 07:54:40,477 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { (f).next().toString(f.next()) }
        }
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:40,479 [main:107] - replacing ({ (f).next().toString(f.next()) }, Function0<String>)
2021-03-12 07:54:40,479 [main:50] - replacing { (f).next().toString(f.next()) } Function0<String>
2021-03-12 07:54:40,479 [main:54] - Getting value of type Function0<String>
2021-03-12 07:54:40,585 [main:302] - generating value of type = Function0<String> false depth = 0
2021-03-12 07:54:40,587 [main:302] - generating value of type = String true depth = 1
2021-03-12 07:54:40,589 [main:58] - GENERATED VALUE OF TYPE Function0<String> = { "xqxhf"}
2021-03-12 07:54:40,589 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:40,713 [main:67] - randomType = Kla1?
2021-03-12 07:54:40,820 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 07:54:40,822 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}
2021-03-12 07:54:40,831 [main:106] - GETTING Function0<String> from Foo
2021-03-12 07:54:40,841 [main:106] - GETTING Function0<String> from Int
2021-03-12 07:54:40,873 [main:106] - GETTING Function0<String> from Int
2021-03-12 07:54:40,874 [main:106] - GETTING Function0<String> from Function1<Int, Int>
2021-03-12 07:54:40,884 [main:106] - GETTING Function0<String> from Int
2021-03-12 07:54:40,885 [main:114] - replacement of { (f).next().toString(f.next()) } of type Function0<String> is { "xqxhf"}
2021-03-12 07:54:40,988 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 07:54:40,989 [main:66] - Compilation checking started
2021-03-12 07:54:41,387 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "xqxhf"}
        }
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:41,390 [main:107] - replacing (false, Boolean)
2021-03-12 07:54:41,390 [main:50] - replacing false Boolean
2021-03-12 07:54:41,390 [main:54] - Getting value of type Boolean
2021-03-12 07:54:41,511 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:41,513 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:54:41,513 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:41,632 [main:67] - randomType = UInt
2021-03-12 07:54:41,755 [main:302] - generating value of type = UInt true depth = 0
2021-03-12 07:54:41,796 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@2bffa5bc]
2021-03-12 07:54:41,796 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2c57ad81]
2021-03-12 07:54:41,904 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:41,904 [main:78] - Generated call from random type = (206216583.toUInt()).toByte().equals("uvnue")
2021-03-12 07:54:41,905 [main:106] - GETTING Boolean from Int
2021-03-12 07:54:41,956 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:54:41,956 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:42,070 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:42,070 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:54:42,174 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:42,174 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("skjcf").equals("viqux")
2021-03-12 07:54:42,174 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]]
2021-03-12 07:54:42,174 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f]
2021-03-12 07:54:42,279 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:54:42,282 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]
2021-03-12 07:54:42,282 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).div(0.6797540646332275).isFinite()
2021-03-12 07:54:42,283 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7], public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@54d06bc6]]
2021-03-12 07:54:42,283 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 07:54:42,283 [main:149] - GENERATING call of type public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@54d06bc6]
2021-03-12 07:54:42,283 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toFloat().isNaN()
2021-03-12 07:54:42,283 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]]
2021-03-12 07:54:42,283 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:54:42,283 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]
2021-03-12 07:54:42,283 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toDouble().isInfinite()
2021-03-12 07:54:42,284 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:54:42,284 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:42,387 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:42,387 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:54:42,489 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:42,491 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
2021-03-12 07:54:42,491 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8], public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@37c34207]]
2021-03-12 07:54:42,491 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8]
2021-03-12 07:54:42,595 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:54:42,597 [main:149] - GENERATING call of type public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@37c34207]
2021-03-12 07:54:42,597 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).rangeTo(-61).isEmpty()
2021-03-12 07:54:42,597 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]]
2021-03-12 07:54:42,597 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:54:42,597 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]
2021-03-12 07:54:42,597 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toDouble().isFinite()
2021-03-12 07:54:42,597 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@9f659]]
2021-03-12 07:54:42,597 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:42,597 [main:149] - GENERATING call of type public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@9f659]
2021-03-12 07:54:42,598 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDefined()
2021-03-12 07:54:42,598 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@48d86ac1]]
2021-03-12 07:54:42,598 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:42,598 [main:149] - GENERATING call of type public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@48d86ac1]
2021-03-12 07:54:42,598 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isSurrogate()
2021-03-12 07:54:42,598 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3260af05]]
2021-03-12 07:54:42,598 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:42,598 [main:149] - GENERATING call of type public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3260af05]
2021-03-12 07:54:42,598 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isLowSurrogate()
2021-03-12 07:54:42,598 [main:114] - replacement of false of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
2021-03-12 07:54:42,701 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:42,701 [main:66] - Compilation checking started
2021-03-12 07:54:43,106 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "xqxhf"}
        }
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (prope1.fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:43,108 [main:107] - replacing (prope1, Kla0)
2021-03-12 07:54:43,108 [main:50] - replacing prope1 Kla0
2021-03-12 07:54:43,108 [main:54] - Getting value of type Kla0
2021-03-12 07:54:43,237 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 07:54:43,240 [main:112] - generating klass Kla0 text = interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}
2021-03-12 07:54:43,462 [main:302] - generating value of type = Kla2 false depth = 2
2021-03-12 07:54:43,464 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "xqxhf"}
        }
        { println()}()
        return prope2
    }
}
2021-03-12 07:54:43,464 [main:58] - GENERATED VALUE OF TYPE Kla0 = Kla2()
2021-03-12 07:54:43,464 [main:61] - GENERATED IS CALL =true
2021-03-12 07:54:43,468 [main:67] - randomType = Boolean
2021-03-12 07:54:43,581 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:43,592 [main:106] - GETTING Kla0 from Int
2021-03-12 07:54:43,620 [main:106] - GETTING Kla0 from Int
2021-03-12 07:54:43,621 [main:106] - GETTING Kla0 from Int
2021-03-12 07:54:43,622 [main:106] - GETTING Kla0 from Foo
2021-03-12 07:54:43,629 [main:106] - GETTING Kla0 from Function1<Int, Int>
2021-03-12 07:54:43,638 [main:114] - replacement of prope1 of type Kla0 is Kla2()
2021-03-12 07:54:43,741 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:54:43,742 [main:66] - Compilation checking started
2021-03-12 07:54:44,150 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            assert(prope3()) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "xqxhf"}
        }
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (Kla2().fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:44,151 [main:107] - replacing (prope3(), Boolean)
2021-03-12 07:54:44,152 [main:50] - replacing prope3() Boolean
2021-03-12 07:54:44,152 [main:54] - Getting value of type Boolean
2021-03-12 07:54:44,263 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:44,265 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:54:44,265 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:44,501 [main:67] - randomType = Short?
2021-03-12 07:54:44,611 [main:302] - generating value of type = Short true depth = 0
2021-03-12 07:54:44,684 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@688ab131]
2021-03-12 07:54:44,811 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:54:44,813 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@6970ad8]
2021-03-12 07:54:44,813 [main:78] - Generated call from random type = (31790)?.div(0.7304373091941032).isNaN()
2021-03-12 07:54:44,814 [main:106] - GETTING Boolean from Function1<Int, Int>
2021-03-12 07:54:44,828 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:54:44,828 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:44,935 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:44,935 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:54:45,040 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:45,042 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("dwfno").or(true)
2021-03-12 07:54:45,043 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:54:45,043 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:45,149 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:45,149 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:54:45,253 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:45,254 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("bgibf").equals("rtgvb")
2021-03-12 07:54:45,254 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:54:45,254 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:45,358 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:45,358 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:54:45,463 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:45,465 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("ubsrf").and(false)
2021-03-12 07:54:45,465 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]]
2021-03-12 07:54:45,465 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:45,571 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:45,571 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("nomnq")
2021-03-12 07:54:45,571 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:54:45,572 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:45,674 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:45,675 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:54:45,675 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("ilxzs").not()
2021-03-12 07:54:45,675 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:54:45,675 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13]
2021-03-12 07:54:45,779 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:54:45,781 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:45,886 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:45,886 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).invoke(1879211143).equals("lpzmb")
2021-03-12 07:54:45,886 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:54:45,886 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:54:46,013 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:46,013 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:54:46,135 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:46,138 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("wbypc").xor(false)
2021-03-12 07:54:46,138 [main:114] - replacement of prope3() of type Boolean is true
2021-03-12 07:54:46,242 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(BOOLEAN_CONSTANT)
2021-03-12 07:54:46,243 [main:66] - Compilation checking started
2021-03-12 07:54:46,659 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        prope4()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "xqxhf"}
        }
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (Kla2().fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:46,662 [main:107] - replacing (prope4, Function0<Unit>)
2021-03-12 07:54:46,663 [main:50] - replacing prope4 Function0<Unit>
2021-03-12 07:54:46,663 [main:54] - Getting value of type Function0<Unit>
2021-03-12 07:54:46,788 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 07:54:46,790 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 07:54:46,903 [main:43] - GENERATING CALL OF fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 07:54:46,906 [main:61] - WITHOUT TYPE PARAMS = fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 07:54:47,136 [main:302] - generating value of type = Any false depth = 4
2021-03-12 07:54:47,136 [main:95] - GENERATED = print("zvmtb")
2021-03-12 07:54:47,136 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { print("zvmtb")}
2021-03-12 07:54:47,136 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:47,258 [main:67] - randomType = UShort
2021-03-12 07:54:47,385 [main:302] - generating value of type = UShort true depth = 0
2021-03-12 07:54:47,414 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:54:47,425 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:54:47,458 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:54:47,459 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:54:47,460 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:54:47,467 [main:114] - replacement of prope4 of type Function0<Unit> is { print("zvmtb")}
2021-03-12 07:54:47,570 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 07:54:47,570 [main:66] - Compilation checking started
2021-03-12 07:54:47,969 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "xqxhf"}
        }
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (Kla2().fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:47,972 [main:107] - replacing (prope2, Boolean)
2021-03-12 07:54:47,972 [main:50] - replacing prope2 Boolean
2021-03-12 07:54:47,972 [main:54] - Getting value of type Boolean
2021-03-12 07:54:48,081 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:48,083 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:54:48,084 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:48,202 [main:67] - randomType = Short
2021-03-12 07:54:48,305 [main:302] - generating value of type = Short true depth = 0
2021-03-12 07:54:48,336 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7b609fa2]
2021-03-12 07:54:48,440 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:48,440 [main:78] - Generated call from random type = (-6174).equals("agcxw")
2021-03-12 07:54:48,441 [main:106] - GETTING Boolean from Int
2021-03-12 07:54:48,471 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7], public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@54d06bc6]]
2021-03-12 07:54:48,471 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 07:54:48,471 [main:149] - GENERATING call of type public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@54d06bc6]
2021-03-12 07:54:48,471 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toFloat().isNaN()
2021-03-12 07:54:48,471 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4e3e340b]]
2021-03-12 07:54:48,471 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:48,472 [main:149] - GENERATING call of type public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4e3e340b]
2021-03-12 07:54:48,472 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isLetter()
2021-03-12 07:54:48,472 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@41df7a0c]]
2021-03-12 07:54:48,472 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:54:48,472 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@41df7a0c]
2021-03-12 07:54:48,576 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:48,576 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toLong().equals("bxzqa")
2021-03-12 07:54:48,576 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7], public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@a67e46]]
2021-03-12 07:54:48,576 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 07:54:48,576 [main:149] - GENERATING call of type public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@a67e46]
2021-03-12 07:54:48,576 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toFloat().isInfinite()
2021-03-12 07:54:48,577 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:54:48,577 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:48,680 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:48,681 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("pmsnv")
2021-03-12 07:54:48,681 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]]
2021-03-12 07:54:48,681 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f]
2021-03-12 07:54:48,799 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:54:48,802 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]
2021-03-12 07:54:48,802 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).div(0.4124509287307244).isFinite()
2021-03-12 07:54:48,802 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]]
2021-03-12 07:54:48,802 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:54:48,802 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]
2021-03-12 07:54:48,802 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toDouble().isInfinite()
2021-03-12 07:54:48,802 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@9f659]]
2021-03-12 07:54:48,802 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:48,802 [main:149] - GENERATING call of type public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@9f659]
2021-03-12 07:54:48,802 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDefined()
2021-03-12 07:54:48,803 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@454e7f3e]]
2021-03-12 07:54:48,803 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:48,803 [main:149] - GENERATING call of type public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@454e7f3e]
2021-03-12 07:54:48,803 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit()
2021-03-12 07:54:48,803 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8], public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@37c34207]]
2021-03-12 07:54:48,803 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8]
2021-03-12 07:54:48,912 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:54:48,914 [main:149] - GENERATING call of type public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@37c34207]
2021-03-12 07:54:48,914 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).rangeTo(11).isEmpty()
2021-03-12 07:54:48,914 [main:114] - replacement of prope2 of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).next()).toFloat().isNaN()
2021-03-12 07:54:49,018 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:49,019 [main:66] - Compilation checking started
2021-03-12 07:54:49,285 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { (Foo(-655341081, {a: Int -> 120045518}).next()).toFloat().isNaN() = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "xqxhf"}
        }
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (Kla2().fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:49,287 [main:107] - replacing (fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "xqxhf"}
        }, Function0<Unit>)
2021-03-12 07:54:49,287 [main:50] - replacing fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "xqxhf"}
        } Function0<Unit>
2021-03-12 07:54:49,287 [main:54] - Getting value of type Function0<Unit>
2021-03-12 07:54:49,393 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 07:54:49,395 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 07:54:49,507 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-12 07:54:49,510 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-12 07:54:49,744 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 07:54:49,746 [main:95] - GENERATED = check(false)
2021-03-12 07:54:49,746 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { check(false)}
2021-03-12 07:54:49,746 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:49,894 [main:67] - randomType = Kla1?
2021-03-12 07:54:50,001 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 07:54:50,003 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}
2021-03-12 07:54:50,011 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:54:50,022 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:54:50,068 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:54:50,069 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:54:50,081 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:54:50,081 [main:114] - replacement of fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "xqxhf"}
        } of type Function0<Unit> is { check(false)}
2021-03-12 07:54:50,202 [main:33] - Trying to replace Element(FUN) on LAMBDA_EXPRESSION
2021-03-12 07:54:50,202 [main:66] - Compilation checking started
2021-03-12 07:54:50,596 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (Kla2().fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:50,597 [main:107] - replacing (prope3, Function0<Boolean>)
2021-03-12 07:54:50,598 [main:50] - replacing prope3 Function0<Boolean>
2021-03-12 07:54:50,598 [main:54] - Getting value of type Function0<Boolean>
2021-03-12 07:54:50,702 [main:302] - generating value of type = Function0<Boolean> false depth = 0
2021-03-12 07:54:50,704 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 07:54:50,706 [main:58] - GENERATED VALUE OF TYPE Function0<Boolean> = { false}
2021-03-12 07:54:50,706 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:50,830 [main:67] - randomType = Kla0?
2021-03-12 07:54:50,831 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:54:50,861 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:54:50,862 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:54:50,870 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:54:50,871 [main:106] - GETTING Function0<Boolean> from Function1<Int, Int>
2021-03-12 07:54:50,880 [main:114] - replacement of prope3 of type Function0<Boolean> is { false}
2021-03-12 07:54:50,986 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 07:54:50,986 [main:66] - Compilation checking started
2021-03-12 07:54:51,393 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (Kla2().fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:51,394 [main:107] - replacing (fun() {
            assert(prope3())
        }, Function0<Unit>)
2021-03-12 07:54:51,394 [main:50] - replacing fun() {
            assert(prope3())
        } Function0<Unit>
2021-03-12 07:54:51,394 [main:54] - Getting value of type Function0<Unit>
2021-03-12 07:54:51,507 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 07:54:51,508 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 07:54:51,622 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 07:54:51,625 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 07:54:52,014 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 07:54:52,016 [main:302] - generating value of type = Function0<Any> false depth = 4
2021-03-12 07:54:52,018 [main:302] - generating value of type = Any false depth = 5
2021-03-12 07:54:52,018 [main:95] - GENERATED = require(true, { "afdkd"})
2021-03-12 07:54:52,018 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { require(true, { "afdkd"})}
2021-03-12 07:54:52,018 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:52,026 [main:67] - randomType = Kla1
2021-03-12 07:54:52,132 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 07:54:52,134 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}
2021-03-12 07:54:52,141 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:54:52,173 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:54:52,182 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:54:52,196 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:54:52,198 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:54:52,198 [main:114] - replacement of fun() {
            assert(prope3())
        } of type Function0<Unit> is { require(true, { "afdkd"})}
2021-03-12 07:54:52,301 [main:33] - Trying to replace Element(FUN) on LAMBDA_EXPRESSION
2021-03-12 07:54:52,301 [main:66] - Compilation checking started
2021-03-12 07:54:52,732 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (Kla2().fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:52,734 [main:107] - replacing (prope3, Function0<Boolean>)
2021-03-12 07:54:52,735 [main:50] - replacing prope3 Function0<Boolean>
2021-03-12 07:54:52,735 [main:54] - Getting value of type Function0<Boolean>
2021-03-12 07:54:52,844 [main:302] - generating value of type = Function0<Boolean> false depth = 0
2021-03-12 07:54:52,846 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 07:54:52,848 [main:58] - GENERATED VALUE OF TYPE Function0<Boolean> = { false}
2021-03-12 07:54:52,848 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:52,855 [main:67] - randomType = Kla0
2021-03-12 07:54:52,857 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:54:52,868 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:54:52,908 [main:106] - GETTING Function0<Boolean> from Function1<Int, Int>
2021-03-12 07:54:52,921 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:54:52,922 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:54:52,922 [main:114] - replacement of prope3 of type Function0<Boolean> is { false}
2021-03-12 07:54:53,028 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 07:54:53,028 [main:66] - Compilation checking started
2021-03-12 07:54:53,457 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (Kla2().fu1()) return "FAIL 0"
    if (prope1.fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:53,459 [main:107] - replacing (prope1, Kla0)
2021-03-12 07:54:53,459 [main:50] - replacing prope1 Kla0
2021-03-12 07:54:53,459 [main:54] - Getting value of type Kla0
2021-03-12 07:54:53,563 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 07:54:53,565 [main:112] - generating klass Kla0 text = interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}
2021-03-12 07:54:53,781 [main:302] - generating value of type = Kla2 false depth = 2
2021-03-12 07:54:53,783 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 07:54:53,783 [main:58] - GENERATED VALUE OF TYPE Kla0 = Kla2()
2021-03-12 07:54:53,783 [main:61] - GENERATED IS CALL =true
2021-03-12 07:54:53,791 [main:67] - randomType = Kla2
2021-03-12 07:54:53,895 [main:302] - generating value of type = Kla2 false depth = 0
2021-03-12 07:54:53,897 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 07:54:53,903 [main:106] - GETTING Kla0 from Int
2021-03-12 07:54:53,932 [main:106] - GETTING Kla0 from Int
2021-03-12 07:54:53,933 [main:106] - GETTING Kla0 from Function1<Int, Int>
2021-03-12 07:54:53,942 [main:106] - GETTING Kla0 from Int
2021-03-12 07:54:53,943 [main:106] - GETTING Kla0 from Foo
2021-03-12 07:54:53,949 [main:114] - replacement of prope1 of type Kla0 is Kla2()
2021-03-12 07:54:54,056 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:54:54,056 [main:66] - Compilation checking started
2021-03-12 07:54:54,467 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass(if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:54,469 [main:107] - replacing (if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf"), String)
2021-03-12 07:54:54,469 [main:50] - replacing if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf") String
2021-03-12 07:54:54,469 [main:54] - Getting value of type String
2021-03-12 07:54:54,573 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:54:54,575 [main:58] - GENERATED VALUE OF TYPE String = "abkpw"
2021-03-12 07:54:54,575 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:54,582 [main:67] - randomType = Foo
2021-03-12 07:54:54,686 [main:302] - generating value of type = Foo false depth = 0
2021-03-12 07:54:54,688 [main:112] - generating klass Foo text = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}
2021-03-12 07:54:54,807 [main:194] - Type params = []
2021-03-12 07:54:54,910 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:54:54,912 [main:302] - generating value of type = Function1<Int, Int> false depth = 2
2021-03-12 07:54:54,914 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:54:54,925 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@27b12c3]
2021-03-12 07:54:54,925 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:54:54,926 [main:78] - Generated call from random type = (Foo(448090128, {a: Int -> 698435272})).next().toString(f.next())
2021-03-12 07:54:54,926 [main:106] - GETTING String from Int
2021-03-12 07:54:54,955 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 07:54:54,955 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:54,956 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 07:54:54,956 [main:117] - GENERATED CALL = (f.next()).toChar().titlecase()
2021-03-12 07:54:54,956 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]]
2021-03-12 07:54:54,956 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:54,956 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]
2021-03-12 07:54:54,956 [main:117] - GENERATED CALL = (f.next()).toChar().uppercase()
2021-03-12 07:54:54,956 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:54:54,956 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:54:54,956 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:54:54,956 [main:117] - GENERATED CALL = (f.next()).toLong().toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:54:54,957 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:54:54,957 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:54:55,060 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:54:55,062 [main:117] - GENERATED CALL = (f.next()).toString(-2023102492)
2021-03-12 07:54:55,062 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:54:55,062 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:54:55,062 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:54:55,063 [main:117] - GENERATED CALL = (f.next()).toByte().toString(f.next())
2021-03-12 07:54:55,063 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:54:55,063 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 07:54:55,170 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:54:55,172 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:54:55,172 [main:117] - GENERATED CALL = (f.next()).div(5498065849600101788).toString(f.next())
2021-03-12 07:54:55,172 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 07:54:55,172 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:55,172 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 07:54:55,172 [main:117] - GENERATED CALL = (f.next()).toChar().lowercase()
2021-03-12 07:54:55,172 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 07:54:55,172 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:55,172 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 07:54:55,275 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:54:55,277 [main:117] - GENERATED CALL = (f.next()).toChar().plus("ljlvt")
2021-03-12 07:54:55,277 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:54:55,277 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:54:55,277 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:54:55,278 [main:117] - GENERATED CALL = (f.next()).toInt().toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:54:55,278 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 07:54:55,278 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:54:55,278 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:54:55,278 [main:117] - GENERATED CALL = (f.next()).toShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:54:55,278 [main:114] - replacement of if (v) "localAnonymousFunction.ShouldBeEnabled" else (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("nvlpf") of type String is (f.next()).div(5498065849600101788).toString(f.next())
2021-03-12 07:54:55,381 [main:33] - Trying to replace Element(IF) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:55,381 [main:66] - Compilation checking started
2021-03-12 07:54:55,783 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:55,784 [main:107] - replacing (prope2, Boolean)
2021-03-12 07:54:55,785 [main:50] - replacing prope2 Boolean
2021-03-12 07:54:55,785 [main:54] - Getting value of type Boolean
2021-03-12 07:54:55,893 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:55,894 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:54:55,894 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:56,015 [main:67] - randomType = UByte
2021-03-12 07:54:56,119 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 07:54:56,146 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@36d3af1c]
2021-03-12 07:54:56,266 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:56,267 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:54:56,368 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:56,370 [main:78] - Generated call from random type = (60.toUByte()).equals("bokvv").xor(false)
2021-03-12 07:54:56,371 [main:106] - GETTING Boolean from Int
2021-03-12 07:54:56,401 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@48d86ac1]]
2021-03-12 07:54:56,401 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:56,401 [main:149] - GENERATING call of type public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@48d86ac1]
2021-03-12 07:54:56,401 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toChar().isSurrogate()
2021-03-12 07:54:56,401 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3bbcbd00]]
2021-03-12 07:54:56,401 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:56,401 [main:149] - GENERATING call of type public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3bbcbd00]
2021-03-12 07:54:56,504 [main:302] - generating value of type = Char true depth = 0
2021-03-12 07:54:56,610 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:56,611 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toChar().equals('', false)
2021-03-12 07:54:56,612 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@53d33965]]
2021-03-12 07:54:56,612 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:56,612 [main:149] - GENERATING call of type public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@53d33965]
2021-03-12 07:54:56,612 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toChar().isWhitespace()
2021-03-12 07:54:56,612 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@34594779]]
2021-03-12 07:54:56,612 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:54:56,612 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@34594779]
2021-03-12 07:54:56,718 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:56,718 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toDouble().equals("rnahg")
2021-03-12 07:54:56,718 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7], public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@a67e46]]
2021-03-12 07:54:56,718 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 07:54:56,718 [main:149] - GENERATING call of type public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@a67e46]
2021-03-12 07:54:56,718 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isInfinite()
2021-03-12 07:54:56,718 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:54:56,718 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:54:56,718 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:56,822 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:56,822 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toInt().equals("lrwrz")
2021-03-12 07:54:56,822 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@6970ad8]]
2021-03-12 07:54:56,822 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:54:56,822 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@6970ad8]
2021-03-12 07:54:56,823 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toDouble().isNaN()
2021-03-12 07:54:56,823 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@559f74f6]]
2021-03-12 07:54:56,823 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:56,823 [main:149] - GENERATING call of type public fun kotlin.Char.isLowerCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@559f74f6]
2021-03-12 07:54:56,823 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toChar().isLowerCase()
2021-03-12 07:54:56,823 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:54:56,823 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:56,930 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:56,930 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:54:57,032 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:57,034 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).equals("uwokc").xor(true)
2021-03-12 07:54:57,034 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:54:57,034 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:57,136 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:57,137 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:54:57,239 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:57,241 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).equals("akico").or(false)
2021-03-12 07:54:57,241 [main:114] - replacement of prope2 of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).state).toDouble().equals("rnahg")
2021-03-12 07:54:57,343 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:57,343 [main:66] - Compilation checking started
2021-03-12 07:54:57,644 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { (Foo(-655341081, {a: Int -> 120045518}).state).toDouble().equals("rnahg") = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return "FAIL 3"
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:57,646 [main:107] - replacing ("FAIL 3", String)
2021-03-12 07:54:57,646 [main:50] - replacing "FAIL 3" String
2021-03-12 07:54:57,646 [main:54] - Getting value of type String
2021-03-12 07:54:57,752 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:54:57,754 [main:58] - GENERATED VALUE OF TYPE String = "kmrcz"
2021-03-12 07:54:57,754 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:57,988 [main:67] - randomType = Function1<Int, Double>
2021-03-12 07:54:57,989 [main:106] - GETTING String from Foo
2021-03-12 07:54:58,000 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@2882549a], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:54:58,000 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@2882549a]
2021-03-12 07:54:58,000 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:54:58,107 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:54:58,109 [main:117] - GENERATED CALL = (f).next().toString(1155528889)
2021-03-12 07:54:58,109 [main:114] - replacement of "FAIL 3" of type String is (f).next().toString(1155528889)
2021-03-12 07:54:58,211 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:54:58,212 [main:66] - Compilation checking started
2021-03-12 07:54:58,637 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:54:58,639 [main:107] - replacing (false, Boolean)
2021-03-12 07:54:58,639 [main:50] - replacing false Boolean
2021-03-12 07:54:58,639 [main:54] - Getting value of type Boolean
2021-03-12 07:54:58,754 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:58,756 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:54:58,756 [main:61] - GENERATED IS CALL =false
2021-03-12 07:54:59,260 [main:67] - randomType = Function1<Map<Kla2, Kla2>, Double?>
2021-03-12 07:54:59,261 [main:106] - GETTING Boolean from Int
2021-03-12 07:54:59,290 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f], public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@6970ad8]]
2021-03-12 07:54:59,290 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f]
2021-03-12 07:54:59,392 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:54:59,394 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@6970ad8]
2021-03-12 07:54:59,394 [main:117] - GENERATED CALL = (f.next()).div(0.12139672582845928).isNaN()
2021-03-12 07:54:59,394 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]]
2021-03-12 07:54:59,394 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:54:59,394 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]
2021-03-12 07:54:59,394 [main:117] - GENERATED CALL = (f.next()).toDouble().isInfinite()
2021-03-12 07:54:59,394 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]]
2021-03-12 07:54:59,394 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:54:59,394 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]
2021-03-12 07:54:59,395 [main:117] - GENERATED CALL = (f.next()).toDouble().isFinite()
2021-03-12 07:54:59,395 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@34594779]]
2021-03-12 07:54:59,395 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:54:59,395 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@34594779]
2021-03-12 07:54:59,497 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:59,497 [main:117] - GENERATED CALL = (f.next()).toDouble().equals("yuszy")
2021-03-12 07:54:59,497 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8], public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@37c34207]]
2021-03-12 07:54:59,497 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8]
2021-03-12 07:54:59,601 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:54:59,603 [main:149] - GENERATING call of type public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@37c34207]
2021-03-12 07:54:59,603 [main:117] - GENERATED CALL = (f.next()).rangeTo(-111).isEmpty()
2021-03-12 07:54:59,603 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:54:59,603 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:59,706 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:59,707 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:54:59,810 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:54:59,811 [main:117] - GENERATED CALL = (f.next()).equals("qzqba").xor(false)
2021-03-12 07:54:59,812 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@48d86ac1]]
2021-03-12 07:54:59,812 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:54:59,812 [main:149] - GENERATING call of type public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@48d86ac1]
2021-03-12 07:54:59,812 [main:117] - GENERATED CALL = (f.next()).toChar().isSurrogate()
2021-03-12 07:54:59,812 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:54:59,812 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:54:59,919 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:54:59,919 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:55:00,026 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:00,026 [main:117] - GENERATED CALL = (f.next()).equals("sfcpi").equals("wrhon")
2021-03-12 07:55:00,026 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7], public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@a67e46]]
2021-03-12 07:55:00,026 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 07:55:00,026 [main:149] - GENERATING call of type public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@a67e46]
2021-03-12 07:55:00,027 [main:117] - GENERATED CALL = (f.next()).toFloat().isInfinite()
2021-03-12 07:55:00,027 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7b609fa2]]
2021-03-12 07:55:00,027 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:55:00,027 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7b609fa2]
2021-03-12 07:55:00,130 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:00,131 [main:117] - GENERATED CALL = (f.next()).toShort().equals("xfuuk")
2021-03-12 07:55:00,131 [main:114] - replacement of false of type Boolean is (f.next()).div(0.12139672582845928).isNaN()
2021-03-12 07:55:00,233 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:00,233 [main:66] - Compilation checking started
2021-03-12 07:55:00,663 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:55:00,664 [main:107] - replacing (false, Boolean)
2021-03-12 07:55:00,665 [main:50] - replacing false Boolean
2021-03-12 07:55:00,665 [main:54] - Getting value of type Boolean
2021-03-12 07:55:00,768 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:00,770 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:55:00,770 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:01,741 [main:67] - randomType = Function1<Triple<Short, ULong, Kla1>, Function2<Double, String, ULong?>>
2021-03-12 07:55:01,742 [main:106] - GETTING Boolean from Function1<Int, Int>
2021-03-12 07:55:01,755 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:55:01,755 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:01,862 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:01,862 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:55:01,967 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:01,967 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("lxgfz").equals("xdzmm")
2021-03-12 07:55:01,967 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:55:01,967 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:02,094 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:02,094 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:55:02,199 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:02,201 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("gtjkd").and(true)
2021-03-12 07:55:02,201 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:55:02,201 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13]
2021-03-12 07:55:02,201 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:02,305 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:02,305 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).invoke(f.next()).equals("prwaj")
2021-03-12 07:55:02,305 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:55:02,306 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:02,408 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:55:02,511 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:02,513 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals(null).xor(false)
2021-03-12 07:55:02,513 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]]
2021-03-12 07:55:02,513 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:02,616 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:02,616 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("wigdf")
2021-03-12 07:55:02,616 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:55:02,616 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:02,720 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:02,720 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:55:02,824 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:02,825 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("zqrfb").or(false)
2021-03-12 07:55:02,826 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:55:02,826 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:02,929 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:02,929 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:55:02,929 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("ccrlv").not()
2021-03-12 07:55:02,929 [main:114] - replacement of false of type Boolean is false
2021-03-12 07:55:03,042 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(BOOLEAN_CONSTANT)
2021-03-12 07:55:03,043 [main:107] - replacing (fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }, Function0<Unit>)
2021-03-12 07:55:03,043 [main:50] - replacing fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        } Function0<Unit>
2021-03-12 07:55:03,044 [main:54] - Getting value of type Function0<Unit>
2021-03-12 07:55:03,148 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 07:55:03,150 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 07:55:03,259 [main:43] - GENERATING CALL OF fun repeat(times: kotlin.Int, action: (kotlin.Int)->kotlin.Unit): Unit = TODO()
2021-03-12 07:55:03,261 [main:61] - WITHOUT TYPE PARAMS = fun repeat(times: kotlin.Int, action: (kotlin.Int)->kotlin.Unit): Unit = TODO()
2021-03-12 07:55:03,641 [main:302] - generating value of type = Int true depth = 4
2021-03-12 07:55:03,643 [main:302] - generating value of type = Function1<Int, Unit> false depth = 4
2021-03-12 07:55:03,644 [main:302] - generating value of type = Unit false depth = 5
2021-03-12 07:55:03,776 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 07:55:03,778 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 07:55:04,144 [main:302] - generating value of type = Boolean true depth = 8
2021-03-12 07:55:04,146 [main:302] - generating value of type = Function0<Any> false depth = 8
2021-03-12 07:55:04,148 [main:302] - generating value of type = Any false depth = 9
2021-03-12 07:55:04,148 [main:95] - GENERATED = require(false, { "mynyf"})
2021-03-12 07:55:04,148 [main:95] - GENERATED = repeat(1242864462, {a: Int -> require(false, { "mynyf"})})
2021-03-12 07:55:04,148 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
2021-03-12 07:55:04,148 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:04,154 [main:67] - randomType = Kla2
2021-03-12 07:55:04,257 [main:302] - generating value of type = Kla2 false depth = 0
2021-03-12 07:55:04,258 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 07:55:04,265 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:55:04,277 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:55:04,307 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:55:04,308 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:55:04,316 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:55:04,316 [main:114] - replacement of fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ true}()) { "gjdsy"}
        } of type Function0<Unit> is { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
2021-03-12 07:55:04,418 [main:33] - Trying to replace Element(FUN) on LAMBDA_EXPRESSION
2021-03-12 07:55:04,418 [main:66] - Compilation checking started
2021-03-12 07:55:04,884 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:55:04,887 [main:107] - replacing (prope2, Boolean)
2021-03-12 07:55:04,888 [main:50] - replacing prope2 Boolean
2021-03-12 07:55:04,888 [main:54] - Getting value of type Boolean
2021-03-12 07:55:05,011 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:05,013 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:55:05,013 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:05,167 [main:67] - randomType = Collection<Char>
2021-03-12 07:55:05,168 [main:106] - GETTING Boolean from Int
2021-03-12 07:55:05,204 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7b609fa2]]
2021-03-12 07:55:05,205 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:55:05,205 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7b609fa2]
2021-03-12 07:55:05,316 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:05,316 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toShort().equals("rarrn")
2021-03-12 07:55:05,316 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@53d33965]]
2021-03-12 07:55:05,316 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:05,317 [main:149] - GENERATING call of type public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@53d33965]
2021-03-12 07:55:05,317 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isWhitespace()
2021-03-12 07:55:05,317 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:55:05,317 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:55:05,317 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:05,428 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:05,428 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toInt().equals("wwicr")
2021-03-12 07:55:05,428 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4e3e340b]]
2021-03-12 07:55:05,428 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:05,428 [main:149] - GENERATING call of type public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4e3e340b]
2021-03-12 07:55:05,428 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isLetter()
2021-03-12 07:55:05,428 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3bbcbd00]]
2021-03-12 07:55:05,428 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:05,428 [main:149] - GENERATING call of type public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3bbcbd00]
2021-03-12 07:55:05,535 [main:302] - generating value of type = Char true depth = 0
2021-03-12 07:55:05,646 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:05,648 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().equals('', true)
2021-03-12 07:55:05,648 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@34594779]]
2021-03-12 07:55:05,648 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:55:05,648 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@34594779]
2021-03-12 07:55:05,761 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:05,762 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toDouble().equals("rnowr")
2021-03-12 07:55:05,762 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]]
2021-03-12 07:55:05,762 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:55:05,762 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]
2021-03-12 07:55:05,762 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toDouble().isInfinite()
2021-03-12 07:55:05,762 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:55:05,762 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:05,869 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:05,869 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:55:05,975 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:05,975 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("kwqdk").equals("mxruw")
2021-03-12 07:55:05,975 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3260af05]]
2021-03-12 07:55:05,975 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:05,975 [main:149] - GENERATING call of type public fun kotlin.Char.isLowSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3260af05]
2021-03-12 07:55:05,976 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isLowSurrogate()
2021-03-12 07:55:05,976 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@454e7f3e]]
2021-03-12 07:55:05,976 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:05,976 [main:149] - GENERATING call of type public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@454e7f3e]
2021-03-12 07:55:05,976 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit()
2021-03-12 07:55:05,976 [main:114] - replacement of prope2 of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).next()).toInt().equals("wwicr")
2021-03-12 07:55:06,082 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:06,082 [main:66] - Compilation checking started
2021-03-12 07:55:06,364 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { (Foo(-655341081, {a: Int -> 120045518}).next()).toInt().equals("wwicr") = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0(false)
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:55:06,366 [main:107] - replacing (false, Boolean)
2021-03-12 07:55:06,366 [main:50] - replacing false Boolean
2021-03-12 07:55:06,366 [main:54] - Getting value of type Boolean
2021-03-12 07:55:06,472 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:06,474 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:55:06,474 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:06,621 [main:67] - randomType = Kla0?
2021-03-12 07:55:06,622 [main:106] - GETTING Boolean from Foo
2021-03-12 07:55:06,633 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:55:06,633 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:06,738 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:06,739 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:55:06,739 [main:117] - GENERATED CALL = (f).equals("jxhvi").not()
2021-03-12 07:55:06,739 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:55:06,739 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:06,850 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:55:06,956 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:06,958 [main:117] - GENERATED CALL = (f).equals(null).or(false)
2021-03-12 07:55:06,958 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:55:06,958 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:07,062 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:07,063 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:55:07,166 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:07,168 [main:117] - GENERATED CALL = (f).equals("vkdep").xor(true)
2021-03-12 07:55:07,169 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:55:07,169 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:07,272 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:07,273 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:55:07,381 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:07,383 [main:117] - GENERATED CALL = (f).equals("lwpgi").and(true)
2021-03-12 07:55:07,383 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]]
2021-03-12 07:55:07,383 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:07,488 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:07,488 [main:117] - GENERATED CALL = (f).equals("xnmmg")
2021-03-12 07:55:07,489 [main:113] - Case = [public final val f: (kotlin.Int) -> kotlin.Int defined in Foo[PropertyDescriptorImpl@13019d49], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]]
2021-03-12 07:55:07,489 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:07,600 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:07,601 [main:117] - GENERATED CALL = (f).f.equals("wazaa")
2021-03-12 07:55:07,601 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:55:07,601 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:07,706 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:07,706 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:55:07,811 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:07,811 [main:117] - GENERATED CALL = (f).equals("hmxxl").equals("qgzdw")
2021-03-12 07:55:07,811 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@2882549a], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:55:07,811 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@2882549a]
2021-03-12 07:55:07,811 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:07,943 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:07,943 [main:117] - GENERATED CALL = (f).next().equals("gdldf")
2021-03-12 07:55:07,943 [main:114] - replacement of false of type Boolean is (f).next().equals("gdldf")
2021-03-12 07:55:08,067 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:08,067 [main:66] - Compilation checking started
2021-03-12 07:55:08,472 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:55:08,475 [main:107] - replacing (fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }, Function0<Unit>)
2021-03-12 07:55:08,476 [main:50] - replacing fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        } Function0<Unit>
2021-03-12 07:55:08,476 [main:54] - Getting value of type Function0<Unit>
2021-03-12 07:55:08,605 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 07:55:08,607 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 07:55:08,723 [main:43] - GENERATING CALL OF fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-12 07:55:08,726 [main:61] - WITHOUT TYPE PARAMS = fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-12 07:55:09,003 [main:302] - generating value of type = [@kotlin.ExtensionFunctionType] Function1<ContractBuilder, Unit> false depth = 4
2021-03-12 07:55:09,005 [main:302] - generating value of type = Unit false depth = 5
2021-03-12 07:55:09,133 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-12 07:55:09,136 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean): Unit = TODO()
2021-03-12 07:55:09,379 [main:302] - generating value of type = Boolean true depth = 8
2021-03-12 07:55:09,381 [main:95] - GENERATED = check(false)
2021-03-12 07:55:09,381 [main:95] - GENERATED = contract({ check(false)})
2021-03-12 07:55:09,381 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { contract({ check(false)})}
2021-03-12 07:55:09,381 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:09,522 [main:67] - randomType = Byte
2021-03-12 07:55:09,629 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:55:09,662 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:55:09,691 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:55:09,692 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:55:09,700 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:55:09,701 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:55:09,709 [main:114] - replacement of fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        } of type Function0<Unit> is { contract({ check(false)})}
2021-03-12 07:55:09,814 [main:33] - Trying to replace Element(FUN) on LAMBDA_EXPRESSION
2021-03-12 07:55:09,814 [main:66] - Compilation checking started
2021-03-12 07:55:10,106 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = { contract({ check(false)})}
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:55:10,108 [main:107] - replacing ({ false}(), Boolean)
2021-03-12 07:55:10,108 [main:50] - replacing { false}() Boolean
2021-03-12 07:55:10,108 [main:54] - Getting value of type Boolean
2021-03-12 07:55:10,213 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:10,215 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:55:10,215 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:10,464 [main:67] - randomType = LinkedHashSet<ArrayList<Kla1>>
2021-03-12 07:55:10,569 [main:302] - generating value of type = LinkedHashSet<ArrayList<Kla1>> false depth = 0
2021-03-12 07:55:10,679 [main:43] - GENERATING CALL OF fun <T> linkedSetOf(elements: ArrayList<Kla1>): LkedHashSet<ArrayList<Kla1>> = TODO()
2021-03-12 07:55:10,682 [main:61] - WITHOUT TYPE PARAMS = fun <T> linkedSetOf(elements: ArrayList<Kla1>): LkedHashSet<ArrayList<Kla1>> = TODO()
2021-03-12 07:55:10,793 [main:302] - generating value of type = ArrayList<Kla1> false depth = 3
2021-03-12 07:55:10,905 [main:43] - GENERATING CALL OF fun <T> arrayListOf(elements: Kla1): ArrayList<Kla1> = TODO()
2021-03-12 07:55:10,908 [main:61] - WITHOUT TYPE PARAMS = fun <T> arrayListOf(elements: Kla1): ArrayList<Kla1> = TODO()
2021-03-12 07:55:11,045 [main:302] - generating value of type = Kla1 false depth = 6
2021-03-12 07:55:11,047 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}
2021-03-12 07:55:11,047 [main:95] - GENERATED = arrayListOf<Kla1>(Kla1())
2021-03-12 07:55:11,047 [main:95] - GENERATED = linkedSetOf<ArrayList<Kla1>>(arrayListOf<Kla1>(Kla1()))
2021-03-12 07:55:11,223 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.collections.Iterable[DeserializedSimpleFunctionDescriptor@2da4c650]
2021-03-12 07:55:11,327 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:55:11,328 [main:78] - Generated call from random type = (linkedSetOf<ArrayList<Kla1>>(arrayListOf<Kla1>(Kla1()))).equals(null).not()
2021-03-12 07:55:11,328 [main:106] - GETTING Boolean from Int
2021-03-12 07:55:11,358 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7b609fa2]]
2021-03-12 07:55:11,358 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:55:11,358 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7b609fa2]
2021-03-12 07:55:11,464 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:11,464 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toShort().equals("xuphi")
2021-03-12 07:55:11,464 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@41df7a0c]]
2021-03-12 07:55:11,464 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:55:11,464 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@41df7a0c]
2021-03-12 07:55:11,573 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:11,573 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toLong().equals("tzscv")
2021-03-12 07:55:11,573 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7dece268]]
2021-03-12 07:55:11,573 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:11,573 [main:149] - GENERATING call of type public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7dece268]
2021-03-12 07:55:11,573 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isLetterOrDigit()
2021-03-12 07:55:11,574 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3bbcbd00]]
2021-03-12 07:55:11,574 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:11,574 [main:149] - GENERATING call of type public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3bbcbd00]
2021-03-12 07:55:11,678 [main:302] - generating value of type = Char true depth = 0
2021-03-12 07:55:11,784 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:11,787 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().equals('', true)
2021-03-12 07:55:11,787 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@454e7f3e]]
2021-03-12 07:55:11,787 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:11,787 [main:149] - GENERATING call of type public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@454e7f3e]
2021-03-12 07:55:11,787 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit()
2021-03-12 07:55:11,787 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]]
2021-03-12 07:55:11,787 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f]
2021-03-12 07:55:11,898 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:55:11,900 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]
2021-03-12 07:55:11,901 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).div(0.3076655975385545).isInfinite()
2021-03-12 07:55:11,901 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:55:11,901 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:12,008 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:12,008 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:55:12,113 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:12,114 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("ehqgb").equals("cwndh")
2021-03-12 07:55:12,114 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7], public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@54d06bc6]]
2021-03-12 07:55:12,114 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 07:55:12,114 [main:149] - GENERATING call of type public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@54d06bc6]
2021-03-12 07:55:12,114 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toFloat().isNaN()
2021-03-12 07:55:12,114 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55530794]]
2021-03-12 07:55:12,114 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:12,114 [main:149] - GENERATING call of type public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55530794]
2021-03-12 07:55:12,114 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isUpperCase()
2021-03-12 07:55:12,114 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:55:12,114 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:12,219 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:12,219 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:55:12,220 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("dmohs").not()
2021-03-12 07:55:12,220 [main:114] - replacement of { false}() of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit()
2021-03-12 07:55:12,325 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:12,325 [main:66] - Compilation checking started
2021-03-12 07:55:12,766 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        prope1.fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:55:12,768 [main:107] - replacing (prope1, Kla0)
2021-03-12 07:55:12,768 [main:50] - replacing prope1 Kla0
2021-03-12 07:55:12,768 [main:54] - Getting value of type Kla0
2021-03-12 07:55:12,876 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 07:55:12,878 [main:112] - generating klass Kla0 text = interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}
2021-03-12 07:55:13,103 [main:302] - generating value of type = Kla1 false depth = 2
2021-03-12 07:55:13,105 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}
2021-03-12 07:55:13,105 [main:58] - GENERATED VALUE OF TYPE Kla0 = Kla1()
2021-03-12 07:55:13,105 [main:61] - GENERATED IS CALL =true
2021-03-12 07:55:13,654 [main:67] - randomType = Collection<Function1<Function2<Foo, String, Kla2>, Map<Boolean, String>>>
2021-03-12 07:55:13,655 [main:106] - GETTING Kla0 from Function1<Int, Int>
2021-03-12 07:55:13,665 [main:106] - GETTING Kla0 from Foo
2021-03-12 07:55:13,672 [main:106] - GETTING Kla0 from Int
2021-03-12 07:55:13,701 [main:106] - GETTING Kla0 from Int
2021-03-12 07:55:13,702 [main:106] - GETTING Kla0 from Int
2021-03-12 07:55:13,702 [main:114] - replacement of prope1 of type Kla0 is Kla1()
2021-03-12 07:55:13,806 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:55:13,807 [main:66] - Compilation checking started
2021-03-12 07:55:14,246 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!prope1.fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:55:14,248 [main:107] - replacing (Kla0::class, KClass<Kla0>)
2021-03-12 07:55:14,249 [main:50] - replacing Kla0::class KClass<Kla0>
2021-03-12 07:55:14,249 [main:54] - Getting value of type KClass<Kla0>
2021-03-12 07:55:14,380 [main:302] - generating value of type = KClass<Kla0> false depth = 0
2021-03-12 07:55:14,489 [main:58] - GENERATED VALUE OF TYPE KClass<Kla0> = Kla0::class
2021-03-12 07:55:14,489 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:14,733 [main:67] - randomType = HashSet<Byte>
2021-03-12 07:55:14,840 [main:302] - generating value of type = HashSet<Byte> false depth = 0
2021-03-12 07:55:14,950 [main:43] - GENERATING CALL OF fun <E> LinkedHashSet(initialCapacity: kotlin.Int): HashSet<Byte> = TODO()
2021-03-12 07:55:14,953 [main:61] - WITHOUT TYPE PARAMS = fun <E> LinkedHashSet(initialCapacity: kotlin.Int): HashSet<Byte> = TODO()
2021-03-12 07:55:15,187 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:55:15,189 [main:95] - GENERATED = LinkedHashSet<Byte>(-1821696955)
2021-03-12 07:55:15,284 [main:106] - GETTING KClass<Kla0> from Int
2021-03-12 07:55:15,313 [main:106] - GETTING KClass<Kla0> from Int
2021-03-12 07:55:15,314 [main:106] - GETTING KClass<Kla0> from Int
2021-03-12 07:55:15,315 [main:106] - GETTING KClass<Kla0> from Foo
2021-03-12 07:55:15,323 [main:106] - GETTING KClass<Kla0> from Function1<Int, Int>
2021-03-12 07:55:15,331 [main:114] - replacement of Kla0::class of type KClass<Kla0> is Kla0::class
2021-03-12 07:55:15,437 [main:33] - Trying to replace Element(CLASS_LITERAL_EXPRESSION) on Element(CLASS_LITERAL_EXPRESSION)
2021-03-12 07:55:15,439 [main:107] - replacing (prope1, Kla0)
2021-03-12 07:55:15,439 [main:50] - replacing prope1 Kla0
2021-03-12 07:55:15,439 [main:54] - Getting value of type Kla0
2021-03-12 07:55:15,544 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 07:55:15,546 [main:112] - generating klass Kla0 text = interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}
2021-03-12 07:55:15,764 [main:302] - generating value of type = Kla2 false depth = 2
2021-03-12 07:55:15,766 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 07:55:15,766 [main:58] - GENERATED VALUE OF TYPE Kla0 = Kla2()
2021-03-12 07:55:15,766 [main:61] - GENERATED IS CALL =true
2021-03-12 07:55:15,917 [main:67] - randomType = Int?
2021-03-12 07:55:16,023 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:55:16,073 [main:106] - GETTING Kla0 from Foo
2021-03-12 07:55:16,080 [main:106] - GETTING Kla0 from Int
2021-03-12 07:55:16,109 [main:106] - GETTING Kla0 from Int
2021-03-12 07:55:16,109 [main:106] - GETTING Kla0 from Int
2021-03-12 07:55:16,110 [main:106] - GETTING Kla0 from Function1<Int, Int>
2021-03-12 07:55:16,119 [main:114] - replacement of prope1 of type Kla0 is Kla2()
2021-03-12 07:55:16,223 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:55:16,223 [main:66] - Compilation checking started
2021-03-12 07:55:16,628 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:55:16,630 [main:107] - replacing (fu1(), Boolean)
2021-03-12 07:55:16,630 [main:50] - replacing fu1() Boolean
2021-03-12 07:55:16,631 [main:54] - Getting value of type Boolean
2021-03-12 07:55:16,740 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:16,742 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:55:16,742 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:16,746 [main:67] - randomType = Char
2021-03-12 07:55:16,855 [main:302] - generating value of type = Char true depth = 0
2021-03-12 07:55:16,879 [main:149] - GENERATING call of type public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7dece268]
2021-03-12 07:55:16,879 [main:78] - Generated call from random type = ('').isLetterOrDigit()
2021-03-12 07:55:16,880 [main:106] - GETTING Boolean from Int
2021-03-12 07:55:16,908 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55530794]]
2021-03-12 07:55:16,908 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:16,908 [main:149] - GENERATING call of type public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55530794]
2021-03-12 07:55:16,908 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isUpperCase()
2021-03-12 07:55:16,908 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:55:16,908 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:17,014 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:17,014 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:55:17,120 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:17,122 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("lzgdv").or(false)
2021-03-12 07:55:17,122 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8], public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@37c34207]]
2021-03-12 07:55:17,122 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8]
2021-03-12 07:55:17,225 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:55:17,228 [main:149] - GENERATING call of type public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@37c34207]
2021-03-12 07:55:17,228 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).rangeTo(72).isEmpty()
2021-03-12 07:55:17,228 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@48d86ac1]]
2021-03-12 07:55:17,228 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:17,228 [main:149] - GENERATING call of type public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@48d86ac1]
2021-03-12 07:55:17,228 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isSurrogate()
2021-03-12 07:55:17,228 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isHighSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@566fde60]]
2021-03-12 07:55:17,228 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:17,228 [main:149] - GENERATING call of type public fun kotlin.Char.isHighSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@566fde60]
2021-03-12 07:55:17,229 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isHighSurrogate()
2021-03-12 07:55:17,229 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@41df7a0c]]
2021-03-12 07:55:17,229 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:55:17,229 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@41df7a0c]
2021-03-12 07:55:17,332 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:17,332 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toLong().equals("bdojk")
2021-03-12 07:55:17,333 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]]
2021-03-12 07:55:17,333 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:55:17,333 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]
2021-03-12 07:55:17,333 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toDouble().isInfinite()
2021-03-12 07:55:17,333 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@454e7f3e]]
2021-03-12 07:55:17,333 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:17,333 [main:149] - GENERATING call of type public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@454e7f3e]
2021-03-12 07:55:17,333 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit()
2021-03-12 07:55:17,333 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:55:17,333 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:17,437 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:17,438 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:55:17,562 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:17,564 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("pmgde").and(true)
2021-03-12 07:55:17,564 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:55:17,565 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:17,671 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:17,671 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:55:17,777 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:17,780 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("fusgf").xor(false)
2021-03-12 07:55:17,780 [main:114] - replacement of fu1() of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit()
2021-03-12 07:55:17,888 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:17,888 [main:66] - Compilation checking started
2021-03-12 07:55:18,167 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().(Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:55:18,169 [main:107] - replacing (fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        }, Function0<Unit>)
2021-03-12 07:55:18,169 [main:50] - replacing fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        } Function0<Unit>
2021-03-12 07:55:18,169 [main:54] - Getting value of type Function0<Unit>
2021-03-12 07:55:18,276 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 07:55:18,278 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 07:55:18,388 [main:43] - GENERATING CALL OF fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 07:55:18,392 [main:61] - WITHOUT TYPE PARAMS = fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 07:55:18,626 [main:302] - generating value of type = Any false depth = 4
2021-03-12 07:55:18,626 [main:95] - GENERATED = println("yiivr")
2021-03-12 07:55:18,626 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { println("yiivr")}
2021-03-12 07:55:18,626 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:18,635 [main:67] - randomType = Kla1
2021-03-12 07:55:18,739 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 07:55:18,742 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}
2021-03-12 07:55:18,748 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:55:18,778 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:55:18,779 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:55:18,789 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:55:18,796 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:55:18,796 [main:114] - replacement of fun() {
            val f = Foo(23, {x -> 2 * x})
assert({ false}())
        } of type Function0<Unit> is { println("yiivr")}
2021-03-12 07:55:18,901 [main:33] - Trying to replace Element(FUN) on LAMBDA_EXPRESSION
2021-03-12 07:55:18,901 [main:66] - Compilation checking started
2021-03-12 07:55:19,334 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:55:19,336 [main:107] - replacing (fu2(), Boolean)
2021-03-12 07:55:19,337 [main:50] - replacing fu2() Boolean
2021-03-12 07:55:19,337 [main:54] - Getting value of type Boolean
2021-03-12 07:55:19,443 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:19,445 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:55:19,445 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:19,453 [main:67] - randomType = Foo
2021-03-12 07:55:19,556 [main:302] - generating value of type = Foo false depth = 0
2021-03-12 07:55:19,558 [main:112] - generating klass Foo text = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}
2021-03-12 07:55:19,661 [main:194] - Type params = []
2021-03-12 07:55:19,764 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:55:19,766 [main:302] - generating value of type = Function1<Int, Int> false depth = 2
2021-03-12 07:55:19,768 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:55:19,778 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@3d8deb95]
2021-03-12 07:55:19,881 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:19,881 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:55:19,985 [main:78] - Generated call from random type = (Foo(1348338521, {a: Int -> -401791623})).equals("mhpdh").equals(null)
2021-03-12 07:55:19,986 [main:106] - GETTING Boolean from Int
2021-03-12 07:55:20,015 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:55:20,015 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:20,119 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:55:20,119 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).equals(null).not()
2021-03-12 07:55:20,119 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@454e7f3e]]
2021-03-12 07:55:20,119 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:20,119 [main:149] - GENERATING call of type public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@454e7f3e]
2021-03-12 07:55:20,119 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit()
2021-03-12 07:55:20,119 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:55:20,119 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:20,223 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:20,223 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:55:20,330 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:20,332 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("xiylm").xor(true)
2021-03-12 07:55:20,332 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f], public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@6970ad8]]
2021-03-12 07:55:20,332 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f]
2021-03-12 07:55:20,437 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:55:20,439 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@6970ad8]
2021-03-12 07:55:20,440 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).div(0.7136039801972469).isNaN()
2021-03-12 07:55:20,440 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:55:20,440 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:20,543 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:20,543 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("rfmrj")
2021-03-12 07:55:20,543 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7dece268]]
2021-03-12 07:55:20,543 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:20,543 [main:149] - GENERATING call of type public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7dece268]
2021-03-12 07:55:20,544 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isLetterOrDigit()
2021-03-12 07:55:20,544 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@273e47e2]]
2021-03-12 07:55:20,544 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:20,544 [main:149] - GENERATING call of type public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@273e47e2]
2021-03-12 07:55:20,544 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isTitleCase()
2021-03-12 07:55:20,544 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]]
2021-03-12 07:55:20,544 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f]
2021-03-12 07:55:20,647 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:55:20,650 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]
2021-03-12 07:55:20,650 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).div(0.6253277065360642).isFinite()
2021-03-12 07:55:20,650 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:55:20,650 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:55:20,753 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:55:20,755 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:20,889 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:20,889 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).compareTo(898274260).equals("juokb")
2021-03-12 07:55:20,890 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@6970ad8]]
2021-03-12 07:55:20,890 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:55:20,890 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@6970ad8]
2021-03-12 07:55:20,890 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).next()).toDouble().isNaN()
2021-03-12 07:55:20,890 [main:114] - replacement of fu2() of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isTitleCase()
2021-03-12 07:55:21,018 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:21,019 [main:66] - Compilation checking started
2021-03-12 07:55:21,293 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.(Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isTitleCase()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:55:21,295 [main:107] - replacing (fu2(), Boolean)
2021-03-12 07:55:21,296 [main:50] - replacing fu2() Boolean
2021-03-12 07:55:21,296 [main:54] - Getting value of type Boolean
2021-03-12 07:55:21,399 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:21,401 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:55:21,401 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:21,644 [main:67] - randomType = ArrayDeque<UShort>
2021-03-12 07:55:21,748 [main:302] - generating value of type = ArrayDeque<UShort> false depth = 0
2021-03-12 07:55:21,857 [main:43] - GENERATING CALL OF fun <E> ArrayDeque(elements: kotlin.collections.Collection<UShort>): ArrayDeque<UShort> = TODO()
2021-03-12 07:55:21,860 [main:61] - WITHOUT TYPE PARAMS = fun <E> ArrayDeque(elements: kotlin.collections.Collection<UShort>): ArrayDeque<UShort> = TODO()
2021-03-12 07:55:22,093 [main:302] - generating value of type = Collection<UShort> false depth = 3
2021-03-12 07:55:22,205 [main:43] - GENERATING CALL OF fun <T> linkedSetOf(elements: UShort): Collection<UShort> = TODO()
2021-03-12 07:55:22,208 [main:61] - WITHOUT TYPE PARAMS = fun <T> linkedSetOf(elements: UShort): Collection<UShort> = TODO()
2021-03-12 07:55:22,360 [main:302] - generating value of type = UShort true depth = 6
2021-03-12 07:55:22,362 [main:95] - GENERATED = linkedSetOf<UShort>(17199.toUShort())
2021-03-12 07:55:22,362 [main:95] - GENERATED = ArrayDeque<UShort>(linkedSetOf<UShort>(17199.toUShort()))
2021-03-12 07:55:22,500 [main:149] - GENERATING call of type public open fun listIterator(): kotlin.collections.MutableListIterator<kotlin.UShort> defined in kotlin.collections.ArrayDeque[DeserializedSimpleFunctionDescriptor@1f4af549]
2021-03-12 07:55:22,500 [main:149] - GENERATING call of type public abstract fun hasNext(): kotlin.Boolean defined in kotlin.collections.MutableListIterator[DeserializedSimpleFunctionDescriptor@2a0e1548]
2021-03-12 07:55:22,500 [main:78] - Generated call from random type = (ArrayDeque<UShort>(linkedSetOf<UShort>(17199.toUShort()))).listIterator().hasNext()
2021-03-12 07:55:22,501 [main:106] - GETTING Boolean from Foo
2021-03-12 07:55:22,508 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@2882549a], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:55:22,508 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@2882549a]
2021-03-12 07:55:22,508 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:22,612 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:22,613 [main:117] - GENERATED CALL = (f).next().equals("oohka")
2021-03-12 07:55:22,613 [main:113] - Case = [public final val f: (kotlin.Int) -> kotlin.Int defined in Foo[PropertyDescriptorImpl@13019d49], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]]
2021-03-12 07:55:22,613 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:22,716 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:22,716 [main:117] - GENERATED CALL = (f).f.equals("xaril")
2021-03-12 07:55:22,716 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:55:22,716 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:22,819 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:55:22,922 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:22,922 [main:117] - GENERATED CALL = (f).equals(null).equals("fvpey")
2021-03-12 07:55:22,922 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:55:22,922 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:23,026 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:23,026 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:55:23,130 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:23,132 [main:117] - GENERATED CALL = (f).equals("vuicu").and(false)
2021-03-12 07:55:23,133 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:55:23,133 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:23,236 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:23,237 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:55:23,340 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:23,342 [main:117] - GENERATED CALL = (f).equals("eksus").or(true)
2021-03-12 07:55:23,342 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:55:23,342 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:23,444 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:23,445 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:55:23,445 [main:117] - GENERATED CALL = (f).equals("hbfgn").not()
2021-03-12 07:55:23,445 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:55:23,445 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:23,547 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:23,547 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:55:23,650 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:23,652 [main:117] - GENERATED CALL = (f).equals("bsavl").xor(true)
2021-03-12 07:55:23,653 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]]
2021-03-12 07:55:23,653 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:23,777 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:23,778 [main:117] - GENERATED CALL = (f).equals("pynae")
2021-03-12 07:55:23,778 [main:114] - replacement of fu2() of type Boolean is (f).equals("eksus").or(true)
2021-03-12 07:55:23,881 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:23,882 [main:66] - Compilation checking started
2021-03-12 07:55:24,153 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { "BOOYA" }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().(f).equals("eksus").or(true)
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:55:24,155 [main:107] - replacing ("BOOYA", String)
2021-03-12 07:55:24,156 [main:50] - replacing "BOOYA" String
2021-03-12 07:55:24,156 [main:54] - Getting value of type String
2021-03-12 07:55:24,262 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:55:24,264 [main:58] - GENERATED VALUE OF TYPE String = "ashte"
2021-03-12 07:55:24,264 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:24,272 [main:67] - randomType = Kla0
2021-03-12 07:55:24,273 [main:106] - GETTING String from Int
2021-03-12 07:55:24,320 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 07:55:24,320 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:24,321 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 07:55:24,321 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toChar().titlecase()
2021-03-12 07:55:24,321 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:55:24,321 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 07:55:24,428 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:55:24,430 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:55:24,430 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).div(-7026308163234325449).toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:55:24,430 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:55:24,430 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:55:24,431 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:55:24,431 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 07:55:24,431 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:24,431 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 07:55:24,431 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toChar().lowercase()
2021-03-12 07:55:24,431 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 07:55:24,431 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:55:24,431 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:55:24,431 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toShort().toString(Foo(-655341081, {a: Int -> 120045518}).next())
2021-03-12 07:55:24,432 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 07:55:24,432 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:24,432 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 07:55:24,539 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:55:24,541 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toChar().plus("ovenk")
2021-03-12 07:55:24,541 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]]
2021-03-12 07:55:24,541 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:55:24,541 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]
2021-03-12 07:55:24,541 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toChar().uppercase()
2021-03-12 07:55:24,541 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:55:24,541 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:55:24,542 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:55:24,542 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:55:24,542 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:55:24,542 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:55:24,542 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:55:24,650 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:55:24,652 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toByte().toString(-1498740999)
2021-03-12 07:55:24,653 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:55:24,653 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:55:24,653 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:55:24,653 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).state).toLong().toString(f.next())
2021-03-12 07:55:24,653 [main:114] - replacement of "BOOYA" of type String is (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:55:24,757 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:24,758 [main:66] - Compilation checking started
2021-03-12 07:55:25,194 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:55:25,196 [main:107] - replacing (prope4, Function0<Unit>)
2021-03-12 07:55:25,197 [main:50] - replacing prope4 Function0<Unit>
2021-03-12 07:55:25,197 [main:54] - Getting value of type Function0<Unit>
2021-03-12 07:55:25,305 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 07:55:25,307 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 07:55:25,418 [main:43] - GENERATING CALL OF fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 07:55:25,422 [main:61] - WITHOUT TYPE PARAMS = fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 07:55:25,675 [main:302] - generating value of type = Any false depth = 4
2021-03-12 07:55:25,675 [main:95] - GENERATED = print("zdbjr")
2021-03-12 07:55:25,675 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { print("zdbjr")}
2021-03-12 07:55:25,675 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:25,805 [main:67] - randomType = UShort
2021-03-12 07:55:25,912 [main:302] - generating value of type = UShort true depth = 0
2021-03-12 07:55:25,942 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:55:25,951 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:55:25,981 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:55:25,982 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:55:25,989 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:55:25,989 [main:114] - replacement of prope4 of type Function0<Unit> is { print("zdbjr")}
2021-03-12 07:55:26,105 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 07:55:26,105 [main:66] - Compilation checking started
2021-03-12 07:55:26,506 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return prope2
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return "OK"
}


2021-03-12 07:55:26,508 [main:107] - replacing ("OK", String)
2021-03-12 07:55:26,509 [main:50] - replacing "OK" String
2021-03-12 07:55:26,509 [main:54] - Getting value of type String
2021-03-12 07:55:26,616 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:55:26,619 [main:58] - GENERATED VALUE OF TYPE String = "ykyxi"
2021-03-12 07:55:26,619 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:26,629 [main:67] - randomType = Kla1
2021-03-12 07:55:26,736 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 07:55:26,739 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}
2021-03-12 07:55:26,747 [main:106] - GETTING String from Foo
2021-03-12 07:55:26,753 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@2882549a], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:55:26,753 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@2882549a]
2021-03-12 07:55:26,754 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:55:26,861 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:55:26,864 [main:117] - GENERATED CALL = (f).next().toString(-469178626)
2021-03-12 07:55:26,864 [main:114] - replacement of "OK" of type String is (f).next().toString(-469178626)
2021-03-12 07:55:26,970 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:26,971 [main:66] - Compilation checking started
2021-03-12 07:55:27,436 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; true }
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return prope2
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:27,440 [main:107] - replacing ({ prope2 = true; true }, Function0<Boolean>)
2021-03-12 07:55:27,440 [main:50] - replacing { prope2 = true; true } Function0<Boolean>
2021-03-12 07:55:27,440 [main:54] - Getting value of type Function0<Boolean>
2021-03-12 07:55:27,562 [main:302] - generating value of type = Function0<Boolean> false depth = 0
2021-03-12 07:55:27,565 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 07:55:27,568 [main:58] - GENERATED VALUE OF TYPE Function0<Boolean> = { true}
2021-03-12 07:55:27,568 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:27,573 [main:67] - randomType = Float
2021-03-12 07:55:27,679 [main:302] - generating value of type = Float true depth = 0
2021-03-12 07:55:27,710 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:55:27,739 [main:106] - GETTING Function0<Boolean> from Function1<Int, Int>
2021-03-12 07:55:27,748 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:55:27,756 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:55:27,757 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:55:27,757 [main:114] - replacement of { prope2 = true; true } of type Function0<Boolean> is { true}
2021-03-12 07:55:27,862 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 07:55:27,863 [main:66] - Compilation checking started
2021-03-12 07:55:28,287 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return prope2
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:28,289 [main:107] - replacing (prope2, Boolean)
2021-03-12 07:55:28,289 [main:50] - replacing prope2 Boolean
2021-03-12 07:55:28,290 [main:54] - Getting value of type Boolean
2021-03-12 07:55:28,398 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:28,401 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:55:28,401 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:28,411 [main:67] - randomType = Kla0
2021-03-12 07:55:28,412 [main:106] - GETTING Boolean from Function1<Int, Int>
2021-03-12 07:55:28,422 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:55:28,422 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:28,528 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:28,528 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:55:28,635 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:28,638 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("mgxkd").xor(true)
2021-03-12 07:55:28,638 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:55:28,638 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:28,745 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:28,745 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:55:28,852 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:28,855 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("xzcig").and(false)
2021-03-12 07:55:28,855 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:55:28,855 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:28,964 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:28,964 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:55:28,964 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("kxkgs").not()
2021-03-12 07:55:28,964 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:55:28,964 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13]
2021-03-12 07:55:28,964 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:29,087 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:29,087 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).invoke(f.next()).equals("pclcq")
2021-03-12 07:55:29,087 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]]
2021-03-12 07:55:29,087 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:29,194 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:29,195 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("qkutw")
2021-03-12 07:55:29,195 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:55:29,195 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:29,301 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:29,301 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:55:29,408 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:29,408 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("cucgp").equals("sssto")
2021-03-12 07:55:29,408 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:55:29,408 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:29,515 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:29,515 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:55:29,622 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:29,625 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
2021-03-12 07:55:29,625 [main:114] - replacement of prope2 of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
2021-03-12 07:55:29,733 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:29,734 [main:66] - Compilation checking started
2021-03-12 07:55:30,155 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return "FAIL 7"
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:30,158 [main:107] - replacing ("FAIL 7", String)
2021-03-12 07:55:30,159 [main:50] - replacing "FAIL 7" String
2021-03-12 07:55:30,159 [main:54] - Getting value of type String
2021-03-12 07:55:30,270 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:55:30,272 [main:58] - GENERATED VALUE OF TYPE String = "ohnwg"
2021-03-12 07:55:30,273 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:30,406 [main:67] - randomType = UByte
2021-03-12 07:55:30,513 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 07:55:30,541 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toUShort(): kotlin.UShort defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@1d672f42]
2021-03-12 07:55:30,542 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShort.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7a750e9d]
2021-03-12 07:55:30,542 [main:78] - Generated call from random type = (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:55:30,542 [main:114] - replacement of "FAIL 7" of type String is (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:55:30,650 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:30,650 [main:66] - Compilation checking started
2021-03-12 07:55:31,174 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:31,178 [main:107] - replacing (prope2, Boolean)
2021-03-12 07:55:31,178 [main:50] - replacing prope2 Boolean
2021-03-12 07:55:31,178 [main:54] - Getting value of type Boolean
2021-03-12 07:55:31,316 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:31,319 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:55:31,319 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:31,447 [main:67] - randomType = Byte
2021-03-12 07:55:31,558 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:55:31,591 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2c045eae]
2021-03-12 07:55:31,705 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:55:31,708 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@34594779]
2021-03-12 07:55:31,824 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:31,824 [main:78] - Generated call from random type = (-5).div(0.8533608805419071).equals("sscqc")
2021-03-12 07:55:31,825 [main:106] - GETTING Boolean from Foo
2021-03-12 07:55:31,833 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:55:31,833 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:31,943 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:31,943 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:55:32,052 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:32,055 [main:117] - GENERATED CALL = (f).equals("ivysg").xor(true)
2021-03-12 07:55:32,055 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:55:32,055 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:32,165 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:32,165 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:55:32,275 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:32,278 [main:117] - GENERATED CALL = (f).equals("fjupy").and(true)
2021-03-12 07:55:32,278 [main:113] - Case = [public final val f: (kotlin.Int) -> kotlin.Int defined in Foo[PropertyDescriptorImpl@13019d49], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]]
2021-03-12 07:55:32,278 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:32,389 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:32,389 [main:117] - GENERATED CALL = (f).f.equals("wozkc")
2021-03-12 07:55:32,389 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]]
2021-03-12 07:55:32,389 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:32,502 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:32,502 [main:117] - GENERATED CALL = (f).equals("dgonp")
2021-03-12 07:55:32,502 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:55:32,502 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:32,634 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:32,634 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:55:32,635 [main:117] - GENERATED CALL = (f).equals("oxmmk").not()
2021-03-12 07:55:32,635 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:55:32,635 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:32,744 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:32,744 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:55:32,856 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:32,856 [main:117] - GENERATED CALL = (f).equals("xpnri").equals("hizso")
2021-03-12 07:55:32,856 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:55:32,856 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@7172d2c6]
2021-03-12 07:55:32,966 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:32,967 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:55:33,084 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:33,087 [main:117] - GENERATED CALL = (f).equals("iegjl").or(false)
2021-03-12 07:55:33,087 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@2882549a], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:55:33,088 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@2882549a]
2021-03-12 07:55:33,088 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:33,197 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:33,197 [main:117] - GENERATED CALL = (f).next().equals("ehcwy")
2021-03-12 07:55:33,197 [main:114] - replacement of prope2 of type Boolean is (f).next().equals("ehcwy")
2021-03-12 07:55:33,306 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:33,306 [main:66] - Compilation checking started
2021-03-12 07:55:33,619 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { (f).next().equals("ehcwy") = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { prope2 = true; false }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:33,623 [main:107] - replacing ({ prope2 = true; false }, Function0<Boolean>)
2021-03-12 07:55:33,623 [main:50] - replacing { prope2 = true; false } Function0<Boolean>
2021-03-12 07:55:33,623 [main:54] - Getting value of type Function0<Boolean>
2021-03-12 07:55:33,740 [main:302] - generating value of type = Function0<Boolean> false depth = 0
2021-03-12 07:55:33,742 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 07:55:33,745 [main:58] - GENERATED VALUE OF TYPE Function0<Boolean> = { false}
2021-03-12 07:55:33,745 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:33,756 [main:67] - randomType = Kla0
2021-03-12 07:55:33,757 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:55:33,787 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:55:33,795 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:55:33,796 [main:106] - GETTING Function0<Boolean> from Function1<Int, Int>
2021-03-12 07:55:33,806 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:55:33,806 [main:114] - replacement of { prope2 = true; false } of type Function0<Boolean> is { false}
2021-03-12 07:55:33,915 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 07:55:33,915 [main:66] - Compilation checking started
2021-03-12 07:55:34,349 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:34,352 [main:107] - replacing (false, Boolean)
2021-03-12 07:55:34,352 [main:50] - replacing false Boolean
2021-03-12 07:55:34,352 [main:54] - Getting value of type Boolean
2021-03-12 07:55:34,485 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:34,488 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:55:34,488 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:34,742 [main:67] - randomType = UInt?
2021-03-12 07:55:34,856 [main:302] - generating value of type = UInt true depth = 0
2021-03-12 07:55:34,896 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toDouble(): kotlin.Double defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@4890f472]
2021-03-12 07:55:34,896 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@6970ad8]
2021-03-12 07:55:34,896 [main:78] - Generated call from random type = (141840546.toUInt())?.toDouble().isNaN()
2021-03-12 07:55:34,896 [main:114] - replacement of false of type Boolean is (141840546.toUInt())?.toDouble().isNaN()
2021-03-12 07:55:35,005 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:35,005 [main:66] - Compilation checking started
2021-03-12 07:55:35,537 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:35,539 [main:107] - replacing (prope2, Boolean)
2021-03-12 07:55:35,540 [main:50] - replacing prope2 Boolean
2021-03-12 07:55:35,540 [main:54] - Getting value of type Boolean
2021-03-12 07:55:35,657 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:35,660 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:55:35,660 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:35,671 [main:67] - randomType = Foo
2021-03-12 07:55:35,785 [main:302] - generating value of type = Foo false depth = 0
2021-03-12 07:55:35,787 [main:112] - generating klass Foo text = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}
2021-03-12 07:55:35,912 [main:194] - Type params = []
2021-03-12 07:55:36,046 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:55:36,050 [main:302] - generating value of type = Function1<Int, Int> false depth = 2
2021-03-12 07:55:36,054 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:55:36,067 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@5142af89]
2021-03-12 07:55:36,182 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:36,183 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:55:36,295 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:36,295 [main:78] - Generated call from random type = (Foo(-98621843, {a: Int -> 2119636301})).equals("mfskz").equals("tkdfv")
2021-03-12 07:55:36,296 [main:114] - replacement of prope2 of type Boolean is (Foo(-98621843, {a: Int -> 2119636301})).equals("mfskz").equals("tkdfv")
2021-03-12 07:55:36,406 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:36,407 [main:66] - Compilation checking started
2021-03-12 07:55:36,745 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { (Foo(-98621843, {a: Int -> 2119636301})).equals("mfskz").equals("tkdfv") = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:36,747 [main:107] - replacing (false, Boolean)
2021-03-12 07:55:36,747 [main:50] - replacing false Boolean
2021-03-12 07:55:36,747 [main:54] - Getting value of type Boolean
2021-03-12 07:55:36,858 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:36,861 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:55:36,861 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:37,000 [main:67] - randomType = Foo?
2021-03-12 07:55:37,111 [main:302] - generating value of type = Foo false depth = 0
2021-03-12 07:55:37,113 [main:112] - generating klass Foo text = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}
2021-03-12 07:55:37,224 [main:194] - Type params = []
2021-03-12 07:55:37,336 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:55:37,339 [main:302] - generating value of type = Function1<Int, Int> false depth = 2
2021-03-12 07:55:37,342 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:55:37,353 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@730ba193]
2021-03-12 07:55:37,463 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:37,464 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:55:37,575 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:37,578 [main:78] - Generated call from random type = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
2021-03-12 07:55:37,578 [main:114] - replacement of false of type Boolean is (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
2021-03-12 07:55:37,689 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:37,690 [main:66] - Compilation checking started
2021-03-12 07:55:38,185 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:38,188 [main:107] - replacing (fu0((f).next().equals("gdldf")), Kla0)
2021-03-12 07:55:38,189 [main:50] - replacing fu0((f).next().equals("gdldf")) Kla0
2021-03-12 07:55:38,189 [main:54] - Getting value of type Kla0
2021-03-12 07:55:38,322 [main:302] - generating value of type = Kla0 false depth = 0
2021-03-12 07:55:38,324 [main:112] - generating klass Kla0 text = interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}
2021-03-12 07:55:38,601 [main:302] - generating value of type = Kla2 false depth = 2
2021-03-12 07:55:38,604 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 07:55:38,604 [main:58] - GENERATED VALUE OF TYPE Kla0 = Kla2()
2021-03-12 07:55:38,604 [main:61] - GENERATED IS CALL =true
2021-03-12 07:55:38,734 [main:67] - randomType = UByte
2021-03-12 07:55:38,845 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 07:55:38,874 [main:106] - GETTING Kla0 from Int
2021-03-12 07:55:38,902 [main:106] - GETTING Kla0 from Foo
2021-03-12 07:55:38,910 [main:106] - GETTING Kla0 from Int
2021-03-12 07:55:38,910 [main:106] - GETTING Kla0 from Int
2021-03-12 07:55:38,911 [main:106] - GETTING Kla0 from Function1<Int, Int>
2021-03-12 07:55:38,919 [main:114] - replacement of fu0((f).next().equals("gdldf")) of type Kla0 is Kla2()
2021-03-12 07:55:39,030 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:55:39,031 [main:66] - Compilation checking started
2021-03-12 07:55:39,369 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = Kla2()
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:39,373 [main:107] - replacing (prope2, Boolean)
2021-03-12 07:55:39,373 [main:50] - replacing prope2 Boolean
2021-03-12 07:55:39,373 [main:54] - Getting value of type Boolean
2021-03-12 07:55:39,505 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:39,508 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:55:39,508 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:39,514 [main:67] - randomType = Boolean
2021-03-12 07:55:39,631 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:39,642 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:55:39,757 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:39,760 [main:78] - Generated call from random type = (false).or(true)
2021-03-12 07:55:39,761 [main:106] - GETTING Boolean from Function1<Int, Int>
2021-03-12 07:55:39,771 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]]
2021-03-12 07:55:39,771 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:39,884 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:39,884 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("gwdlm")
2021-03-12 07:55:39,884 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:55:39,884 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@4660df13]
2021-03-12 07:55:39,999 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:55:40,001 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:55:40,119 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:40,120 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).invoke(-110157088).equals("muurk")
2021-03-12 07:55:40,120 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:55:40,120 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:40,232 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:40,232 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:55:40,344 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:40,347 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("mfzss").or(false)
2021-03-12 07:55:40,347 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:55:40,348 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:40,480 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:40,480 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:55:40,595 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:40,598 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("ymduu").xor(false)
2021-03-12 07:55:40,598 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:55:40,598 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:40,714 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:40,714 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:55:40,827 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:55:40,830 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("isfjg").and(false)
2021-03-12 07:55:40,830 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:55:40,830 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:40,941 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:40,942 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:55:40,942 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("zmicq").not()
2021-03-12 07:55:40,942 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:55:40,942 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:55:41,054 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:41,054 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:55:41,168 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:55:41,168 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518}).f).equals("zpjnf").equals("iflsx")
2021-03-12 07:55:41,168 [main:114] - replacement of prope2 of type Boolean is (Foo(-655341081, {a: Int -> 120045518}).f).invoke(-110157088).equals("muurk")
2021-03-12 07:55:41,280 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:41,281 [main:66] - Compilation checking started
2021-03-12 07:55:41,585 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { prope2 = true; (true).compareTo(true).equals("eljmm") }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { (Foo(-655341081, {a: Int -> 120045518}).f).invoke(-110157088).equals("muurk") = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:41,587 [main:107] - replacing ({ prope2 = true; (true).compareTo(true).equals("eljmm") }, Function0<Boolean>)
2021-03-12 07:55:41,588 [main:50] - replacing { prope2 = true; (true).compareTo(true).equals("eljmm") } Function0<Boolean>
2021-03-12 07:55:41,588 [main:54] - Getting value of type Function0<Boolean>
2021-03-12 07:55:41,699 [main:302] - generating value of type = Function0<Boolean> false depth = 0
2021-03-12 07:55:41,702 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 07:55:41,705 [main:58] - GENERATED VALUE OF TYPE Function0<Boolean> = { true}
2021-03-12 07:55:41,705 [main:61] - GENERATED IS CALL =false
2021-03-12 07:55:42,796 [main:67] - randomType = Function2<Function2<Kla1?, Kla0, UInt>, Triple<Float, Kla0, Kla2>, MutableMap<Double, Foo>>
2021-03-12 07:55:42,797 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:55:42,843 [main:106] - GETTING Function0<Boolean> from Function1<Int, Int>
2021-03-12 07:55:42,856 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:55:42,868 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:55:42,869 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:55:42,869 [main:114] - replacement of { prope2 = true; (true).compareTo(true).equals("eljmm") } of type Function0<Boolean> is { true}
2021-03-12 07:55:42,980 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 07:55:42,980 [main:66] - Compilation checking started
2021-03-12 07:55:43,436 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { true}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:43,556 [main:141] - TRYING TO REPLACE CONSTANT true
2021-03-12 07:55:43,669 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(CALL_EXPRESSION)
2021-03-12 07:55:43,670 [main:66] - Compilation checking started
2021-03-12 07:55:44,128 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:44,129 [main:141] - TRYING TO REPLACE CONSTANT 655341081
2021-03-12 07:55:44,244 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-12 07:55:44,245 [main:66] - Compilation checking started
2021-03-12 07:55:44,711 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> 120045518}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:44,711 [main:141] - TRYING TO REPLACE CONSTANT 120045518
2021-03-12 07:55:44,824 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(PREFIX_EXPRESSION)
2021-03-12 07:55:44,824 [main:66] - Compilation checking started
2021-03-12 07:55:45,264 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:45,264 [main:141] - TRYING TO REPLACE CONSTANT 655341081
2021-03-12 07:55:45,375 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:55:45,375 [main:66] - Compilation checking started
2021-03-12 07:55:45,673 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(compareTo(Foo(-655341081, {a: Int -> 120045518}).state), {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:45,674 [main:141] - TRYING TO REPLACE CONSTANT 120045518
2021-03-12 07:55:45,788 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(REFERENCE_EXPRESSION)
2021-03-12 07:55:45,789 [main:66] - Compilation checking started
2021-03-12 07:55:46,101 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(1500832613, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> state}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:46,102 [main:141] - TRYING TO REPLACE CONSTANT 1500832613
2021-03-12 07:55:46,219 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-12 07:55:46,219 [main:66] - Compilation checking started
2021-03-12 07:55:46,697 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:46,698 [main:141] - TRYING TO REPLACE CONSTANT 519820721
2021-03-12 07:55:46,814 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(REFERENCE_EXPRESSION)
2021-03-12 07:55:46,815 [main:66] - Compilation checking started
2021-03-12 07:55:47,116 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> state})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:47,116 [main:141] - TRYING TO REPLACE CONSTANT 655341081
2021-03-12 07:55:47,229 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(REFERENCE_EXPRESSION)
2021-03-12 07:55:47,230 [main:66] - Compilation checking started
2021-03-12 07:55:47,532 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(x, {a: Int -> 120045518}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:47,532 [main:141] - TRYING TO REPLACE CONSTANT 120045518
2021-03-12 07:55:47,646 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:47,647 [main:66] - Compilation checking started
2021-03-12 07:55:48,084 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(false)
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:48,084 [main:141] - TRYING TO REPLACE CONSTANT false
2021-03-12 07:55:48,199 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:48,199 [main:66] - Compilation checking started
2021-03-12 07:55:48,686 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:48,686 [main:141] - TRYING TO REPLACE CONSTANT 655341081
2021-03-12 07:55:48,803 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-12 07:55:48,804 [main:66] - Compilation checking started
2021-03-12 07:55:49,272 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> 120045518}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:49,272 [main:141] - TRYING TO REPLACE CONSTANT 120045518
2021-03-12 07:55:49,386 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:49,386 [main:66] - Compilation checking started
2021-03-12 07:55:49,841 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { false}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:49,841 [main:141] - TRYING TO REPLACE CONSTANT false
2021-03-12 07:55:49,955 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:49,955 [main:66] - Compilation checking started
2021-03-12 07:55:50,400 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:50,401 [main:141] - TRYING TO REPLACE CONSTANT false
2021-03-12 07:55:50,520 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:50,521 [main:66] - Compilation checking started
2021-03-12 07:55:50,819 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(-655341081, {a: Int -> 120045518}).next()).equals("phnso").and(prope1.fu2())
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:50,820 [main:141] - TRYING TO REPLACE CONSTANT 655341081
2021-03-12 07:55:50,950 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:50,950 [main:66] - Compilation checking started
2021-03-12 07:55:51,384 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 120045518}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:51,385 [main:141] - TRYING TO REPLACE CONSTANT 120045518
2021-03-12 07:55:51,500 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-12 07:55:51,500 [main:66] - Compilation checking started
2021-03-12 07:55:51,946 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:51,947 [main:141] - TRYING TO REPLACE CONSTANT false
2021-03-12 07:55:52,063 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(CALL_EXPRESSION)
2021-03-12 07:55:52,063 [main:66] - Compilation checking started
2021-03-12 07:55:52,372 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require(true, { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(isDefined())}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:52,372 [main:141] - TRYING TO REPLACE CONSTANT true
2021-03-12 07:55:52,488 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:52,488 [main:66] - Compilation checking started
2021-03-12 07:55:52,930 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div(5498065849600101788).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:52,931 [main:141] - TRYING TO REPLACE CONSTANT 5498065849600101788
2021-03-12 07:55:53,066 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:53,067 [main:66] - Compilation checking started
2021-03-12 07:55:53,514 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(1155528889)
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:53,514 [main:141] - TRYING TO REPLACE CONSTANT 1155528889
2021-03-12 07:55:53,634 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:53,634 [main:66] - Compilation checking started
2021-03-12 07:55:54,097 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div(0.12139672582845928).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:54,097 [main:141] - TRYING TO REPLACE CONSTANT 0.12139672582845928
2021-03-12 07:55:54,215 [main:33] - Trying to replace Element(FLOAT_CONSTANT) on Element(SAFE_ACCESS_EXPRESSION)
2021-03-12 07:55:54,215 [main:66] - Compilation checking started
2021-03-12 07:55:54,690 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(1242864462, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:54,690 [main:141] - TRYING TO REPLACE CONSTANT 1242864462
2021-03-12 07:55:54,827 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-12 07:55:54,827 [main:66] - Compilation checking started
2021-03-12 07:55:55,307 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(655341081, {a: Int -> require(false, { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:55,307 [main:141] - TRYING TO REPLACE CONSTANT false
2021-03-12 07:55:55,428 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(CALL_EXPRESSION)
2021-03-12 07:55:55,428 [main:66] - Compilation checking started
2021-03-12 07:55:55,889 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:55,889 [main:141] - TRYING TO REPLACE CONSTANT 655341081
2021-03-12 07:55:56,030 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:55:56,030 [main:66] - Compilation checking started
2021-03-12 07:55:56,340 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(next(), {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:56,341 [main:141] - TRYING TO REPLACE CONSTANT 120045518
2021-03-12 07:55:56,459 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(CALL_EXPRESSION)
2021-03-12 07:55:56,459 [main:66] - Compilation checking started
2021-03-12 07:55:56,765 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> next()}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:56,766 [main:141] - TRYING TO REPLACE CONSTANT 655341081
2021-03-12 07:55:56,886 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:55:56,886 [main:66] - Compilation checking started
2021-03-12 07:55:57,253 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(f(state), {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(-655341081, {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:57,253 [main:141] - TRYING TO REPLACE CONSTANT 655341081
2021-03-12 07:55:57,375 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:57,376 [main:66] - Compilation checking started
2021-03-12 07:55:57,861 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> 120045518}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:57,861 [main:141] - TRYING TO REPLACE CONSTANT 120045518
2021-03-12 07:55:57,984 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:57,984 [main:66] - Compilation checking started
2021-03-12 07:55:58,480 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:58,480 [main:141] - TRYING TO REPLACE CONSTANT 655341081
2021-03-12 07:55:58,604 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(REFERENCE_EXPRESSION)
2021-03-12 07:55:58,604 [main:66] - Compilation checking started
2021-03-12 07:55:58,918 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(x, {a: Int -> 120045518}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> 120045518}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:58,919 [main:141] - TRYING TO REPLACE CONSTANT 120045518
2021-03-12 07:55:59,045 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:55:59,046 [main:66] - Compilation checking started
2021-03-12 07:55:59,507 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:55:59,508 [main:141] - TRYING TO REPLACE CONSTANT 120045518
2021-03-12 07:55:59,631 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-12 07:55:59,632 [main:66] - Compilation checking started
2021-03-12 07:56:00,119 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(-469178626)
}


2021-03-12 07:56:00,119 [main:141] - TRYING TO REPLACE CONSTANT 469178626
2021-03-12 07:56:00,239 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:56:00,239 [main:66] - Compilation checking started
2021-03-12 07:56:00,753 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { true}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}


2021-03-12 07:56:00,753 [main:141] - TRYING TO REPLACE CONSTANT true
2021-03-12 07:56:00,875 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(BINARY_EXPRESSION)
2021-03-12 07:56:00,875 [main:66] - Compilation checking started
2021-03-12 07:56:01,346 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}


2021-03-12 07:56:01,346 [main:141] - TRYING TO REPLACE CONSTANT true
2021-03-12 07:56:01,482 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(REFERENCE_EXPRESSION)
2021-03-12 07:56:01,483 [main:66] - Compilation checking started
2021-03-12 07:56:01,811 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(-655341081, {a: Int -> 120045518}).f).equals("chvog").or(v)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}


2021-03-12 07:56:01,812 [main:141] - TRYING TO REPLACE CONSTANT 655341081
2021-03-12 07:56:01,942 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-12 07:56:01,942 [main:66] - Compilation checking started
2021-03-12 07:56:02,409 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}


2021-03-12 07:56:02,410 [main:141] - TRYING TO REPLACE CONSTANT 120045518
2021-03-12 07:56:02,528 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(CALL_EXPRESSION)
2021-03-12 07:56:02,529 [main:66] - Compilation checking started
2021-03-12 07:56:02,834 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> next()}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}


2021-03-12 07:56:02,834 [main:141] - TRYING TO REPLACE CONSTANT 5
2021-03-12 07:56:02,952 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(REFERENCE_EXPRESSION)
2021-03-12 07:56:02,952 [main:66] - Compilation checking started
2021-03-12 07:56:03,255 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (x.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}


2021-03-12 07:56:03,256 [main:141] - TRYING TO REPLACE CONSTANT 655341081
2021-03-12 07:56:03,394 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(REFERENCE_EXPRESSION)
2021-03-12 07:56:03,394 [main:66] - Compilation checking started
2021-03-12 07:56:03,703 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(x, {a: Int -> 120045518}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}


2021-03-12 07:56:03,703 [main:141] - TRYING TO REPLACE CONSTANT 120045518
2021-03-12 07:56:03,832 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(PREFIX_EXPRESSION)
2021-03-12 07:56:03,833 [main:66] - Compilation checking started
2021-03-12 07:56:04,307 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}


2021-03-12 07:56:04,308 [main:141] - TRYING TO REPLACE CONSTANT false
2021-03-12 07:56:04,431 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(CALL_EXPRESSION)
2021-03-12 07:56:04,431 [main:66] - Compilation checking started
2021-03-12 07:56:04,752 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { and(Kla2().fu3())}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}


2021-03-12 07:56:04,753 [main:141] - TRYING TO REPLACE CONSTANT 141840546
2021-03-12 07:56:04,877 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(BINARY_EXPRESSION)
2021-03-12 07:56:04,877 [main:66] - Compilation checking started
2021-03-12 07:56:05,220 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(true)
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (2 * x.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}


2021-03-12 07:56:05,220 [main:141] - TRYING TO REPLACE CONSTANT true
2021-03-12 07:56:05,346 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(CALL_EXPRESSION)
2021-03-12 07:56:05,347 [main:66] - Compilation checking started
2021-03-12 07:56:05,790 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(1762188734, {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}


2021-03-12 07:56:05,791 [main:141] - TRYING TO REPLACE CONSTANT 1762188734
2021-03-12 07:56:05,911 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:56:05,911 [main:66] - Compilation checking started
2021-03-12 07:56:06,397 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}


2021-03-12 07:56:06,397 [main:141] - TRYING TO REPLACE CONSTANT 1126701799
2021-03-12 07:56:06,517 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:56:06,517 [main:66] - Compilation checking started
2021-03-12 07:56:06,837 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> next()}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}


2021-03-12 07:56:06,837 [main:141] - TRYING TO REPLACE CONSTANT true
2021-03-12 07:56:06,957 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(CALL_EXPRESSION)
2021-03-12 07:56:06,958 [main:66] - Compilation checking started
2021-03-12 07:56:07,273 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { isDefined()}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}


2021-03-12 07:56:07,274 [main:41] - AFTER TRY 1 res = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}


2021-03-12 07:56:07,516 [main:112] - generating klass Foo text = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}
2021-03-12 07:56:07,635 [main:194] - Type params = []
2021-03-12 07:56:07,754 [main:302] - generating value of type = Int true depth = 1
2021-03-12 07:56:07,758 [main:302] - generating value of type = Function1<Int, Int> false depth = 1
2021-03-12 07:56:07,762 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:56:07,765 [main:112] - generating klass Kla0 text = interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}
2021-03-12 07:56:08,018 [main:302] - generating value of type = Kla2 false depth = 1
2021-03-12 07:56:08,022 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 07:56:08,022 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}
2021-03-12 07:56:08,022 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 07:56:08,279 [main:43] - GENERATING CALL OF fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}
2021-03-12 07:56:08,283 [main:61] - WITHOUT TYPE PARAMS = fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}
2021-03-12 07:56:08,428 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 07:56:08,432 [main:95] - GENERATED = fu0(false)
2021-03-12 07:56:08,573 [main:43] - Try 1
2021-03-12 07:56:09,705 [main:69] - Trying to insert fun box834(): String {
    val prope7 by lazy { 3 }

    if (prope5 != 1) throw AssertionError()
    if (Kla3().prope6 != 2) throw AssertionError()
    if (prope7 != 3) throw AssertionError()

    return "OK"
}
2021-03-12 07:56:09,909 [main:66] - Compilation checking started
2021-03-12 07:56:10,929 [main:103] - Trying to change 24 nodes
2021-03-12 07:56:10,930 [main:107] - replacing (prope6, Int)
2021-03-12 07:56:10,930 [main:50] - replacing prope6 Int
2021-03-12 07:56:10,931 [main:54] - Getting value of type Int
2021-03-12 07:56:11,128 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:56:11,132 [main:58] - GENERATED VALUE OF TYPE Int = 1759755278
2021-03-12 07:56:11,132 [main:61] - GENERATED IS CALL =false
2021-03-12 07:56:11,548 [main:67] - randomType = Function1<Kla1, ArrayList<UByte>>
2021-03-12 07:56:11,550 [main:106] - GETTING Int from UByte
2021-03-12 07:56:11,595 [main:113] - Case = [@kotlin.internal.InlineOnly public open inline fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@563e835c], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@55e60c72]]
2021-03-12 07:56:11,595 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public open inline fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@563e835c]
2021-03-12 07:56:11,595 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@55e60c72]
2021-03-12 07:56:11,755 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:56:11,759 [main:117] - GENERATED CALL = ((5.toUByte())).compareTo(5.toUByte()).div(124)
2021-03-12 07:56:11,760 [main:113] - Case = [@kotlin.internal.InlineOnly public open inline fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@563e835c], @kotlin.SinceKotlin public val kotlin.Int.sign: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@4b82cbd8]]
2021-03-12 07:56:11,760 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public open inline fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@563e835c]
2021-03-12 07:56:11,760 [main:117] - GENERATED CALL = ((5.toUByte())).compareTo(5.toUByte()).sign
2021-03-12 07:56:11,760 [main:113] - Case = [@kotlin.internal.InlineOnly public open inline fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@563e835c], public fun kotlin.Int.coerceAtMost(maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@741f1e49]]
2021-03-12 07:56:11,760 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public open inline fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@563e835c]
2021-03-12 07:56:11,760 [main:149] - GENERATING call of type public fun kotlin.Int.coerceAtMost(maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@741f1e49]
2021-03-12 07:56:11,761 [main:117] - GENERATED CALL = ((5.toUByte())).compareTo((5.toUByte())).coerceAtMost((f).next())
2021-03-12 07:56:11,761 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@66bc2b30], public open fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@7d194ace]]
2021-03-12 07:56:11,761 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@66bc2b30]
2021-03-12 07:56:11,761 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@7d194ace]
2021-03-12 07:56:11,902 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:56:11,906 [main:117] - GENERATED CALL = ((5.toUByte())).toByte().compareTo(-36)
2021-03-12 07:56:11,906 [main:113] - Case = [@kotlin.internal.InlineOnly public open inline fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@563e835c], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@35d0f108]]
2021-03-12 07:56:11,906 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public open inline fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@563e835c]
2021-03-12 07:56:11,906 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@35d0f108]
2021-03-12 07:56:11,907 [main:117] - GENERATED CALL = ((5.toUByte())).compareTo(5.toUByte()).unaryPlus()
2021-03-12 07:56:11,907 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@66bc2b30], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@27d8f15e]]
2021-03-12 07:56:11,907 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@66bc2b30]
2021-03-12 07:56:11,907 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@27d8f15e]
2021-03-12 07:56:11,907 [main:117] - GENERATED CALL = ((5.toUByte())).toByte().countLeadingZeroBits()
2021-03-12 07:56:11,907 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@66bc2b30], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@7f449d0c]]
2021-03-12 07:56:11,907 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@66bc2b30]
2021-03-12 07:56:11,907 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@7f449d0c]
2021-03-12 07:56:11,907 [main:117] - GENERATED CALL = ((5.toUByte())).toByte().unaryPlus()
2021-03-12 07:56:11,907 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toUShort(): kotlin.UShort defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@e6b5235], @kotlin.internal.InlineOnly public final inline operator fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@65b1ac56]]
2021-03-12 07:56:11,907 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toUShort(): kotlin.UShort defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@e6b5235]
2021-03-12 07:56:11,907 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UShort[DeserializedSimpleFunctionDescriptor@65b1ac56]
2021-03-12 07:56:11,908 [main:117] - GENERATED CALL = ((5.toUByte())).toUShort().compareTo((5.toUByte()))
2021-03-12 07:56:11,908 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toLong(): kotlin.Long defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@1d105dec], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4aa16b76]]
2021-03-12 07:56:11,908 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toLong(): kotlin.Long defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@1d105dec]
2021-03-12 07:56:11,908 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4aa16b76]
2021-03-12 07:56:11,908 [main:117] - GENERATED CALL = ((5.toUByte())).toLong().countOneBits()
2021-03-12 07:56:11,908 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline operator fun div(other: kotlin.UByte): kotlin.UInt defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@27b22121], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UInt.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@138a00fa]]
2021-03-12 07:56:11,908 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun div(other: kotlin.UByte): kotlin.UInt defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@27b22121]
2021-03-12 07:56:11,908 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.ExperimentalUnsignedTypes @kotlin.internal.InlineOnly public inline fun kotlin.UInt.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@138a00fa]
2021-03-12 07:56:11,908 [main:117] - GENERATED CALL = ((5.toUByte())).div(5.toUByte()).countLeadingZeroBits()
2021-03-12 07:56:11,908 [main:114] - replacement of prope6 of type Int is 1759755278
2021-03-12 07:56:12,050 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-12 07:56:12,050 [main:66] - Compilation checking started
2021-03-12 07:56:12,057 [main:71] - Wrong syntax or breaks conditions
2021-03-12 07:56:12,057 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { 2 }
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if (prope5 != 1) throw AssertionError()
    if (Kla3().1759755278 != 2) throw AssertionError()
    if (prope7 != 3) throw AssertionError()

    return "OK"
}


2021-03-12 07:56:12,058 [main:107] - replacing ({ 2 }, Function0<Int>)
2021-03-12 07:56:12,058 [main:50] - replacing { 2 } Function0<Int>
2021-03-12 07:56:12,058 [main:54] - Getting value of type Function0<Int>
2021-03-12 07:56:12,197 [main:302] - generating value of type = Function0<Int> false depth = 0
2021-03-12 07:56:12,201 [main:302] - generating value of type = Int true depth = 1
2021-03-12 07:56:12,205 [main:58] - GENERATED VALUE OF TYPE Function0<Int> = { -239305732}
2021-03-12 07:56:12,205 [main:61] - GENERATED IS CALL =false
2021-03-12 07:56:12,384 [main:67] - randomType = Set<Int>
2021-03-12 07:56:12,385 [main:106] - GETTING Function0<Int> from Boolean
2021-03-12 07:56:12,399 [main:106] - GETTING Function0<Int> from Boolean
2021-03-12 07:56:12,400 [main:106] - GETTING Function0<Int> from Foo
2021-03-12 07:56:12,411 [main:106] - GETTING Function0<Int> from Kla0
2021-03-12 07:56:12,414 [main:106] - GETTING Function0<Int> from Boolean
2021-03-12 07:56:12,415 [main:106] - GETTING Function0<Int> from Foo
2021-03-12 07:56:12,416 [main:106] - GETTING Function0<Int> from Function1<Int, Int>
2021-03-12 07:56:12,426 [main:106] - GETTING Function0<Int> from Boolean
2021-03-12 07:56:12,427 [main:106] - GETTING Function0<Int> from Foo
2021-03-12 07:56:12,428 [main:106] - GETTING Function0<Int> from Boolean
2021-03-12 07:56:12,429 [main:106] - GETTING Function0<Int> from Int
2021-03-12 07:56:12,459 [main:106] - GETTING Function0<Int> from Boolean
2021-03-12 07:56:12,460 [main:106] - GETTING Function0<Int> from Int
2021-03-12 07:56:12,461 [main:106] - GETTING Function0<Int> from Int
2021-03-12 07:56:12,462 [main:106] - GETTING Function0<Int> from UShort
2021-03-12 07:56:12,484 [main:106] - GETTING Function0<Int> from Boolean
2021-03-12 07:56:12,485 [main:106] - GETTING Function0<Int> from Foo
2021-03-12 07:56:12,486 [main:106] - GETTING Function0<Int> from Kla2
2021-03-12 07:56:12,493 [main:106] - GETTING Function0<Int> from Boolean
2021-03-12 07:56:12,494 [main:106] - GETTING Function0<Int> from Foo
2021-03-12 07:56:12,495 [main:106] - GETTING Function0<Int> from Boolean
2021-03-12 07:56:12,495 [main:106] - GETTING Function0<Int> from Int
2021-03-12 07:56:12,496 [main:106] - GETTING Function0<Int> from Boolean
2021-03-12 07:56:12,497 [main:106] - GETTING Function0<Int> from Int
2021-03-12 07:56:12,498 [main:106] - GETTING Function0<Int> from Float
2021-03-12 07:56:12,528 [main:106] - GETTING Function0<Int> from Kla0
2021-03-12 07:56:12,529 [main:106] - GETTING Function0<Int> from Boolean
2021-03-12 07:56:12,529 [main:106] - GETTING Function0<Int> from Boolean
2021-03-12 07:56:12,530 [main:106] - GETTING Function0<Int> from UByte
2021-03-12 07:56:12,553 [main:106] - GETTING Function0<Int> from Function1<Int, Int>
2021-03-12 07:56:12,554 [main:106] - GETTING Function0<Int> from Boolean
2021-03-12 07:56:12,555 [main:106] - GETTING Function0<Int> from Foo
2021-03-12 07:56:12,556 [main:106] - GETTING Function0<Int> from Int
2021-03-12 07:56:12,557 [main:106] - GETTING Function0<Int> from Char
2021-03-12 07:56:12,574 [main:106] - GETTING Function0<Int> from Function1<Int, Int>
2021-03-12 07:56:12,575 [main:106] - GETTING Function0<Int> from Boolean
2021-03-12 07:56:12,576 [main:106] - GETTING Function0<Int> from UByte
2021-03-12 07:56:12,577 [main:106] - GETTING Function0<Int> from Boolean
2021-03-12 07:56:12,578 [main:106] - GETTING Function0<Int> from Int
2021-03-12 07:56:12,578 [main:114] - replacement of { 2 } of type Function0<Int> is { -239305732}
2021-03-12 07:56:12,716 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 07:56:12,716 [main:66] - Compilation checking started
2021-03-12 07:56:13,268 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -239305732}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if (prope5 != 1) throw AssertionError()
    if (Kla3().prope6 != 2) throw AssertionError()
    if (prope7 != 3) throw AssertionError()

    return "OK"
}


2021-03-12 07:56:13,269 [main:107] - replacing (prope5, Int)
2021-03-12 07:56:13,269 [main:50] - replacing prope5 Int
2021-03-12 07:56:13,269 [main:54] - Getting value of type Int
2021-03-12 07:56:13,503 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:56:13,509 [main:58] - GENERATED VALUE OF TYPE Int = 218073903
2021-03-12 07:56:13,509 [main:61] - GENERATED IS CALL =false
2021-03-12 07:56:13,521 [main:67] - randomType = Int
2021-03-12 07:56:13,672 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:56:13,712 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:56:13,713 [main:149] - GENERATING call of type public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7bf4ba17]
2021-03-12 07:56:13,713 [main:78] - Generated call from random type = (2128636376).compareTo((f.next())).inv()
2021-03-12 07:56:13,713 [main:114] - replacement of prope5 of type Int is (2128636376).compareTo((f.next())).inv()
2021-03-12 07:56:13,852 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:56:13,852 [main:66] - Compilation checking started
2021-03-12 07:56:14,423 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -239305732}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((2128636376).compareTo((f.next())).inv() != 1) throw AssertionError()
    if (Kla3().prope6 != 2) throw AssertionError()
    if (prope7 != 3) throw AssertionError()

    return "OK"
}


2021-03-12 07:56:14,424 [main:107] - replacing (prope7 != 3, Boolean)
2021-03-12 07:56:14,424 [main:50] - replacing prope7 != 3 Boolean
2021-03-12 07:56:14,424 [main:54] - Getting value of type Boolean
2021-03-12 07:56:14,576 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:56:14,580 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:56:14,580 [main:61] - GENERATED IS CALL =false
2021-03-12 07:56:14,754 [main:67] - randomType = Kla2?
2021-03-12 07:56:14,894 [main:302] - generating value of type = Kla2 false depth = 0
2021-03-12 07:56:14,898 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 07:56:14,904 [main:149] - GENERATING call of type public open fun fu2(): kotlin.Boolean defined in Kla2[SimpleFunctionDescriptorImpl@6ce8caa9]
2021-03-12 07:56:14,904 [main:78] - Generated call from random type = (Kla2())?.fu2()
2021-03-12 07:56:14,905 [main:106] - GETTING Boolean from Foo
2021-03-12 07:56:14,912 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:56:14,912 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78]
2021-03-12 07:56:15,046 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:15,046 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:56:15,046 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> -655341081})).equals("uzppc").not()
2021-03-12 07:56:15,046 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:56:15,046 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78]
2021-03-12 07:56:15,182 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:15,182 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:56:15,183 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> -655341081})).equals("wqdck").xor(Kla2().fu4())
2021-03-12 07:56:15,183 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:56:15,183 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78]
2021-03-12 07:56:15,318 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:15,319 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:56:15,453 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:15,454 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> -655341081})).equals("jntta").equals("duttq")
2021-03-12 07:56:15,454 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@30f79b34], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:56:15,454 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@30f79b34]
2021-03-12 07:56:15,454 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:56:15,592 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:15,592 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> -655341081})).next().equals("kfrrs")
2021-03-12 07:56:15,592 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:56:15,592 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78]
2021-03-12 07:56:15,759 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:15,759 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:56:15,759 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> -655341081})).equals("olhvg").and(prope1.fu4())
2021-03-12 07:56:15,759 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:56:15,760 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78]
2021-03-12 07:56:15,896 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:15,896 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:56:15,896 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> -655341081})).equals("qornb").or(Kla2().fu1())
2021-03-12 07:56:15,897 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78]]
2021-03-12 07:56:15,897 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78]
2021-03-12 07:56:16,032 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:16,033 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> -655341081})).equals("citxp")
2021-03-12 07:56:16,033 [main:113] - Case = [public final val f: (kotlin.Int) -> kotlin.Int defined in Foo[PropertyDescriptorImpl@38b6127d], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]]
2021-03-12 07:56:16,033 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:56:16,168 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:16,169 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> -655341081})).f.equals("nckoa")
2021-03-12 07:56:16,169 [main:114] - replacement of prope7 != 3 of type Boolean is (Foo(655341081, {a: Int -> -655341081})).f.equals("nckoa")
2021-03-12 07:56:16,303 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:56:16,303 [main:66] - Compilation checking started
2021-03-12 07:56:16,817 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -239305732}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((2128636376).compareTo((f.next())).inv() != 1) throw AssertionError()
    if (Kla3().prope6 != 2) throw AssertionError()
    if ((Foo(655341081, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return "OK"
}


2021-03-12 07:56:16,818 [main:107] - replacing (Kla3().prope6 != 2, Boolean)
2021-03-12 07:56:16,818 [main:50] - replacing Kla3().prope6 != 2 Boolean
2021-03-12 07:56:16,818 [main:54] - Getting value of type Boolean
2021-03-12 07:56:16,971 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:56:16,975 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:56:16,975 [main:61] - GENERATED IS CALL =false
2021-03-12 07:56:16,991 [main:67] - randomType = Kla1
2021-03-12 07:56:17,124 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 07:56:17,128 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}
2021-03-12 07:56:17,135 [main:149] - GENERATING call of type public open fun fu1(): kotlin.Boolean defined in Kla1[SimpleFunctionDescriptorImpl@d1727eb]
2021-03-12 07:56:17,135 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:56:17,279 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:17,279 [main:78] - Generated call from random type = (Kla1()).fu1().equals("itmno")
2021-03-12 07:56:17,280 [main:106] - GETTING Boolean from Foo
2021-03-12 07:56:17,290 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@30f79b34], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:56:17,290 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@30f79b34]
2021-03-12 07:56:17,291 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:56:17,424 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:17,425 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518})).next().equals("cvgyg")
2021-03-12 07:56:17,425 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:56:17,425 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78]
2021-03-12 07:56:17,560 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:17,561 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:56:17,561 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518})).equals("mkguo").not()
2021-03-12 07:56:17,561 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:56:17,561 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78]
2021-03-12 07:56:17,695 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:17,696 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:56:17,696 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518})).equals("vsdpo").xor(Kla1().fu2())
2021-03-12 07:56:17,696 [main:113] - Case = [public final val f: (kotlin.Int) -> kotlin.Int defined in Foo[PropertyDescriptorImpl@38b6127d], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]]
2021-03-12 07:56:17,696 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:56:17,831 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:17,831 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518})).f.equals("vdwqy")
2021-03-12 07:56:17,831 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78]]
2021-03-12 07:56:17,831 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78]
2021-03-12 07:56:17,965 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:17,965 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518})).equals("fkmpu")
2021-03-12 07:56:17,965 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:56:17,965 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78]
2021-03-12 07:56:18,131 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:18,131 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:56:18,132 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518})).equals("egeuh").and(Kla1().fu2())
2021-03-12 07:56:18,132 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:56:18,132 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78]
2021-03-12 07:56:18,265 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:18,265 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:56:18,399 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:56:18,403 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518})).equals("fwytl").or(false)
2021-03-12 07:56:18,403 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:56:18,403 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@15d6ce78]
2021-03-12 07:56:18,535 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:18,535 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:56:18,671 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:56:18,671 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518})).equals("aiabu").equals("xsign")
2021-03-12 07:56:18,671 [main:114] - replacement of Kla3().prope6 != 2 of type Boolean is (Foo(-655341081, {a: Int -> 120045518})).equals("fkmpu")
2021-03-12 07:56:18,803 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:56:18,804 [main:66] - Compilation checking started
2021-03-12 07:56:19,326 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -239305732}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((2128636376).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(-655341081, {a: Int -> 120045518})).equals("fkmpu")) throw AssertionError()
    if ((Foo(655341081, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return "OK"
}


2021-03-12 07:56:19,327 [main:107] - replacing ("OK", String)
2021-03-12 07:56:19,327 [main:50] - replacing "OK" String
2021-03-12 07:56:19,327 [main:54] - Getting value of type String
2021-03-12 07:56:19,493 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:56:19,497 [main:58] - GENERATED VALUE OF TYPE String = "rybdl"
2021-03-12 07:56:19,497 [main:61] - GENERATED IS CALL =false
2021-03-12 07:56:19,681 [main:67] - randomType = Kla2?
2021-03-12 07:56:19,821 [main:302] - generating value of type = Kla2 false depth = 0
2021-03-12 07:56:19,826 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 07:56:19,834 [main:106] - GETTING String from Int
2021-03-12 07:56:19,862 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 07:56:19,862 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:56:19,862 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 07:56:19,863 [main:117] - GENERATED CALL = (Foo(416482559, {a: Int -> -1476306215}).state).toChar().lowercase()
2021-03-12 07:56:19,863 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:56:19,863 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:56:19,998 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:56:20,002 [main:117] - GENERATED CALL = (Foo(416482559, {a: Int -> -1476306215}).state).toString(-1987332860)
2021-03-12 07:56:20,002 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:56:20,003 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:56:20,003 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:56:20,137 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:56:20,141 [main:117] - GENERATED CALL = (Foo(416482559, {a: Int -> -1476306215}).state).toByte().toString(-223322045)
2021-03-12 07:56:20,141 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 07:56:20,141 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:56:20,141 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 07:56:20,275 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:56:20,279 [main:117] - GENERATED CALL = (Foo(416482559, {a: Int -> -1476306215}).state).toChar().plus("tomii")
2021-03-12 07:56:20,279 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 07:56:20,279 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:56:20,279 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 07:56:20,280 [main:117] - GENERATED CALL = (Foo(416482559, {a: Int -> -1476306215}).state).toChar().titlecase()
2021-03-12 07:56:20,280 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]]
2021-03-12 07:56:20,280 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:56:20,280 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]
2021-03-12 07:56:20,280 [main:117] - GENERATED CALL = (Foo(416482559, {a: Int -> -1476306215}).state).toChar().uppercase()
2021-03-12 07:56:20,280 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 07:56:20,280 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:56:20,280 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:56:20,280 [main:117] - GENERATED CALL = (Foo(416482559, {a: Int -> -1476306215}).state).toShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:56:20,281 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:56:20,281 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:56:20,281 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:56:20,281 [main:117] - GENERATED CALL = (Foo(416482559, {a: Int -> -1476306215}).state).toInt().toString(f.next())
2021-03-12 07:56:20,281 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:56:20,281 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:56:20,281 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:56:20,281 [main:117] - GENERATED CALL = (Foo(416482559, {a: Int -> -1476306215}).state).toLong().toString((f.next()))
2021-03-12 07:56:20,281 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:56:20,281 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:56:20,281 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:56:20,282 [main:117] - GENERATED CALL = (Foo(416482559, {a: Int -> -1476306215}).state).compareTo(f.next()).toString(Foo(416482559, {a: Int -> -1476306215}).state)
2021-03-12 07:56:20,282 [main:114] - replacement of "OK" of type String is (Foo(416482559, {a: Int -> -1476306215}).state).toByte().toString(-223322045)
2021-03-12 07:56:20,415 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:56:20,415 [main:66] - Compilation checking started
2021-03-12 07:56:20,979 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -239305732}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((2128636376).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(-655341081, {a: Int -> 120045518})).equals("fkmpu")) throw AssertionError()
    if ((Foo(655341081, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> -1476306215}).state).toByte().toString(-223322045)
}


2021-03-12 07:56:21,122 [main:141] - TRYING TO REPLACE CONSTANT 239305732
2021-03-12 07:56:21,255 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-12 07:56:21,256 [main:66] - Compilation checking started
2021-03-12 07:56:21,774 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((2128636376).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(-655341081, {a: Int -> 120045518})).equals("fkmpu")) throw AssertionError()
    if ((Foo(655341081, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> -1476306215}).state).toByte().toString(-223322045)
}


2021-03-12 07:56:21,774 [main:141] - TRYING TO REPLACE CONSTANT 2128636376
2021-03-12 07:56:21,922 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:56:21,923 [main:66] - Compilation checking started
2021-03-12 07:56:22,452 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(-655341081, {a: Int -> 120045518})).equals("fkmpu")) throw AssertionError()
    if ((Foo(655341081, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> -1476306215}).state).toByte().toString(-223322045)
}


2021-03-12 07:56:22,452 [main:141] - TRYING TO REPLACE CONSTANT 655341081
2021-03-12 07:56:22,609 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-12 07:56:22,610 [main:66] - Compilation checking started
2021-03-12 07:56:23,169 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(-655341081, {a: Int -> 120045518})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> -1476306215}).state).toByte().toString(-223322045)
}


2021-03-12 07:56:23,169 [main:141] - TRYING TO REPLACE CONSTANT 655341081
2021-03-12 07:56:23,313 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(BINARY_EXPRESSION)
2021-03-12 07:56:23,313 [main:66] - Compilation checking started
2021-03-12 07:56:23,669 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(-655341081, {a: Int -> 120045518})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> 2 * x})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> -1476306215}).state).toByte().toString(-223322045)
}


2021-03-12 07:56:23,669 [main:141] - TRYING TO REPLACE CONSTANT 655341081
2021-03-12 07:56:23,808 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-12 07:56:23,808 [main:66] - Compilation checking started
2021-03-12 07:56:24,336 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 120045518})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> -1476306215}).state).toByte().toString(-223322045)
}


2021-03-12 07:56:24,337 [main:141] - TRYING TO REPLACE CONSTANT 120045518
2021-03-12 07:56:24,504 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(INTEGER_CONSTANT)
2021-03-12 07:56:24,504 [main:66] - Compilation checking started
2021-03-12 07:56:25,023 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> -1476306215}).state).toByte().toString(-223322045)
}


2021-03-12 07:56:25,023 [main:141] - TRYING TO REPLACE CONSTANT 223322045
2021-03-12 07:56:25,177 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(REFERENCE_EXPRESSION)
2021-03-12 07:56:25,177 [main:66] - Compilation checking started
2021-03-12 07:56:25,546 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> -1476306215}).state).toByte().toString(x)
}


2021-03-12 07:56:25,547 [main:141] - TRYING TO REPLACE CONSTANT 416482559
2021-03-12 07:56:25,708 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(REFERENCE_EXPRESSION)
2021-03-12 07:56:25,709 [main:66] - Compilation checking started
2021-03-12 07:56:26,073 [main:49] - Result = false
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(x, {a: Int -> -1476306215}).state).toByte().toString(-223322045)
}


2021-03-12 07:56:26,074 [main:141] - TRYING TO REPLACE CONSTANT 1476306215
2021-03-12 07:56:26,210 [main:33] - Trying to replace Element(PREFIX_EXPRESSION) on Element(INTEGER_CONSTANT)
2021-03-12 07:56:26,210 [main:66] - Compilation checking started
2021-03-12 07:56:26,732 [main:53] - Result = true
Text:
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}


2021-03-12 07:56:26,732 [main:41] - AFTER TRY 2 res = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}


2021-03-12 07:56:27,009 [main:112] - generating klass Foo text = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}
2021-03-12 07:56:27,143 [main:194] - Type params = []
2021-03-12 07:56:27,277 [main:302] - generating value of type = Int true depth = 1
2021-03-12 07:56:27,281 [main:302] - generating value of type = Function1<Int, Int> false depth = 1
2021-03-12 07:56:27,285 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:56:27,289 [main:112] - generating klass Kla0 text = interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}
2021-03-12 07:56:27,572 [main:302] - generating value of type = Kla2 false depth = 1
2021-03-12 07:56:27,576 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 07:56:27,577 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}
2021-03-12 07:56:27,577 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 07:56:27,577 [main:112] - generating klass Kla3 text = class Kla3 {
    val prope6 by lazy { -655341081}
}
2021-03-12 07:56:27,892 [main:43] - GENERATING CALL OF fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}
2021-03-12 07:56:27,896 [main:61] - WITHOUT TYPE PARAMS = fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}
2021-03-12 07:56:28,042 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 07:56:28,047 [main:95] - GENERATED = fu0(false)
2021-03-12 07:56:28,237 [main:43] - Try 2
2021-03-12 07:56:40,033 [main:48] - Already checked
2021-03-12 07:56:43,439 [main:69] - Trying to insert fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}
2021-03-12 07:56:43,579 [main:66] - Compilation checking started
2021-03-12 07:56:45,169 [main:103] - Trying to change 213 nodes
2021-03-12 07:56:45,169 [main:107] - replacing (fu13(), String)
2021-03-12 07:56:45,170 [main:50] - replacing fu13() String
2021-03-12 07:56:45,170 [main:54] - Getting value of type String
2021-03-12 07:56:45,387 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:56:45,395 [main:58] - GENERATED VALUE OF TYPE String = "xhnln"
2021-03-12 07:56:45,395 [main:61] - GENERATED IS CALL =false
2021-03-12 07:56:45,684 [main:67] - randomType = Kla13
2021-03-12 07:56:45,881 [main:302] - generating value of type = Kla13 false depth = 0
2021-03-12 07:56:45,888 [main:112] - generating klass Kla13 text = object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}
2021-03-12 07:56:45,938 [main:106] - GETTING String from Boolean
2021-03-12 07:56:45,950 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:56:45,950 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:56:45,950 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:56:45,950 [main:117] - GENERATED CALL = (Kla1().fu1()).compareTo(Kla2().fu2()).toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:56:45,950 [main:114] - replacement of fu13() of type String is (Kla1().fu1()).compareTo(Kla2().fu2()).toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:56:46,164 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:56:46,165 [main:66] - Compilation checking started
2021-03-12 07:56:46,756 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4(ss.s)

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11(fu6<Kla4>())))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4(s)

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().(Kla1().fu1()).compareTo(Kla2().fu2()).toString(Foo(-655341081, {a: Int -> 120045518}).state)
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        prope13 = 0
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope13)
        if (prope14) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:56:46,759 [main:107] - replacing (Kla4(ss.s), Kla4)
2021-03-12 07:56:46,759 [main:50] - replacing Kla4(ss.s) Kla4
2021-03-12 07:56:46,759 [main:54] - Getting value of type Kla4
2021-03-12 07:56:46,982 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 07:56:46,989 [main:112] - generating klass Kla4 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)
2021-03-12 07:56:47,198 [main:194] - Type params = []
2021-03-12 07:56:47,404 [main:302] - generating value of type = String true depth = 2
2021-03-12 07:56:47,412 [main:58] - GENERATED VALUE OF TYPE Kla4 = Kla4("qevti")
2021-03-12 07:56:47,412 [main:61] - GENERATED IS CALL =true
2021-03-12 07:56:47,982 [main:67] - randomType = Sequence<Kla4>
2021-03-12 07:56:47,984 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:56:47,996 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:56:48,004 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:56:48,005 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:56:48,006 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:56:48,006 [main:106] - GETTING Kla4 from UByte
2021-03-12 07:56:48,032 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:56:48,033 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:56:48,034 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:56:48,034 [main:106] - GETTING Kla4 from Int
2021-03-12 07:56:48,065 [main:106] - GETTING Kla4 from Int
2021-03-12 07:56:48,065 [main:106] - GETTING Kla4 from Int
2021-03-12 07:56:48,066 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:56:48,067 [main:106] - GETTING Kla4 from Kla2
2021-03-12 07:56:48,072 [main:106] - GETTING Kla4 from Int
2021-03-12 07:56:48,073 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:56:48,073 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:56:48,074 [main:106] - GETTING Kla4 from Int
2021-03-12 07:56:48,075 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:56:48,075 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:56:48,076 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:56:48,076 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:56:48,086 [main:106] - GETTING Kla4 from Int
2021-03-12 07:56:48,087 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:56:48,088 [main:106] - GETTING Kla4 from Int
2021-03-12 07:56:48,088 [main:106] - GETTING Kla4 from Int
2021-03-12 07:56:48,089 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:56:48,089 [main:106] - GETTING Kla4 from Byte
2021-03-12 07:56:48,119 [main:106] - GETTING Kla4 from Kla0
2021-03-12 07:56:48,122 [main:106] - GETTING Kla4 from Int
2021-03-12 07:56:48,122 [main:106] - GETTING Kla4 from Int
2021-03-12 07:56:48,123 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:56:48,124 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:56:48,124 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:56:48,125 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:56:48,125 [main:106] - GETTING Kla4 from UByte
2021-03-12 07:56:48,126 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:56:48,126 [main:106] - GETTING Kla4 from Int
2021-03-12 07:56:48,127 [main:106] - GETTING Kla4 from Kla0
2021-03-12 07:56:48,128 [main:106] - GETTING Kla4 from Float
2021-03-12 07:56:48,156 [main:106] - GETTING Kla4 from UShort
2021-03-12 07:56:48,176 [main:106] - GETTING Kla4 from Int
2021-03-12 07:56:48,177 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:56:48,178 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:56:48,178 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:56:48,179 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:56:48,179 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:56:48,180 [main:106] - GETTING Kla4 from Int
2021-03-12 07:56:48,181 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:56:48,181 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:56:48,182 [main:106] - GETTING Kla4 from Char
2021-03-12 07:56:48,199 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:56:48,199 [main:114] - replacement of Kla4(ss.s) of type Kla4 is Kla4("qevti")
2021-03-12 07:56:48,426 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:56:48,426 [main:66] - Compilation checking started
2021-03-12 07:56:49,399 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11(fu6<Kla4>())))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4(s)

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true } ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        prope13 = 0
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope13)
        if (prope14) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:56:49,401 [main:107] - replacing (prope8, Continuation<*>)
2021-03-12 07:56:49,402 [main:50] - replacing prope8 Continuation<*>
2021-03-12 07:56:49,402 [main:54] - Getting value of type Continuation<*>
2021-03-12 07:56:49,599 [main:302] - generating value of type = Continuation<*> false depth = 0
2021-03-12 07:56:49,800 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 07:56:49,809 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 07:56:50,572 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 07:56:50,782 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:56:50,797 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:56:51,299 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 07:56:51,511 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<AbstractCoroutineContextElement>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:56:51,520 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<AbstractCoroutineContextElement>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:56:52,313 [main:302] - generating value of type = Key<AbstractCoroutineContextElement> false depth = 9
2021-03-12 07:56:52,522 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->AbstractCoroutineContextElement): Key<AbstractCoroutineContextElement> = TODO()
2021-03-12 07:56:52,532 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->AbstractCoroutineContextElement): Key<AbstractCoroutineContextElement> = TODO()
2021-03-12 07:56:53,258 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->AbstractCoroutineContextElement): Key<AbstractCoroutineContextElement> = TODO()
2021-03-12 07:56:53,258 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<AbstractCoroutineContextElement>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:56:53,259 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:56:53,259 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 07:56:53,259 [main:58] - GENERATED VALUE OF TYPE Continuation<*> = 
2021-03-12 07:56:53,510 [main:67] - randomType = Float?
2021-03-12 07:56:53,705 [main:302] - generating value of type = Float true depth = 0
2021-03-12 07:56:53,757 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:56:53,770 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:53,783 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:53,784 [main:106] - GETTING Continuation<*> from Kla0
2021-03-12 07:56:53,789 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:53,790 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:53,834 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:53,841 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:53,842 [main:106] - GETTING Continuation<*> from Float
2021-03-12 07:56:53,869 [main:106] - GETTING Continuation<*> from UShort
2021-03-12 07:56:53,890 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:53,891 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:53,891 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:53,892 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:56:53,893 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:53,894 [main:106] - GETTING Continuation<*> from Kla2
2021-03-12 07:56:53,900 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:53,901 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:53,902 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:53,902 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:53,903 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:53,904 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:53,905 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:53,906 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:53,906 [main:106] - GETTING Continuation<*> from Byte
2021-03-12 07:56:53,936 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:53,937 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:53,938 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:56:53,939 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:53,940 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:53,940 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:53,941 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:53,942 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:53,943 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:53,944 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:53,944 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:53,945 [main:106] - GETTING Continuation<*> from UByte
2021-03-12 07:56:53,968 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:53,969 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:53,970 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:53,970 [main:106] - GETTING Continuation<*> from UByte
2021-03-12 07:56:53,971 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:53,972 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:53,973 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:53,974 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:53,974 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:53,975 [main:106] - GETTING Continuation<*> from Char
2021-03-12 07:56:53,993 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:53,994 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:53,995 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:56:53,995 [main:106] - GETTING Continuation<*> from Kla0
2021-03-12 07:56:53,996 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:53,996 [main:111] - Cant find and generate replacement for prope8 type Continuation<*>
2021-03-12 07:56:53,996 [main:107] - replacing (prope8, Continuation<*>)
2021-03-12 07:56:53,996 [main:50] - replacing prope8 Continuation<*>
2021-03-12 07:56:53,996 [main:54] - Getting value of type Continuation<*>
2021-03-12 07:56:54,187 [main:302] - generating value of type = Continuation<*> false depth = 0
2021-03-12 07:56:54,387 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 07:56:54,396 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 07:56:55,151 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 07:56:55,351 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:56:55,360 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:56:55,827 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 07:56:56,039 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:56:56,048 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:56:56,760 [main:302] - generating value of type = Key<ContinuationInterceptor> false depth = 9
2021-03-12 07:56:56,966 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 07:56:56,975 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 07:56:57,746 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 07:56:57,746 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:56:57,746 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:56:57,746 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 07:56:57,746 [main:58] - GENERATED VALUE OF TYPE Continuation<*> = 
2021-03-12 07:56:58,051 [main:67] - randomType = Function1<Kla4, Kla1>
2021-03-12 07:56:58,053 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:58,064 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:58,072 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:58,101 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:56:58,110 [main:106] - GETTING Continuation<*> from Byte
2021-03-12 07:56:58,139 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:58,140 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:58,141 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:58,142 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:58,143 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:58,143 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:58,144 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:58,145 [main:106] - GETTING Continuation<*> from Float
2021-03-12 07:56:58,173 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:58,174 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:56:58,174 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:58,175 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:58,176 [main:106] - GETTING Continuation<*> from Kla0
2021-03-12 07:56:58,180 [main:106] - GETTING Continuation<*> from Char
2021-03-12 07:56:58,197 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:58,198 [main:106] - GETTING Continuation<*> from UByte
2021-03-12 07:56:58,222 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:58,223 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:58,224 [main:106] - GETTING Continuation<*> from Kla0
2021-03-12 07:56:58,224 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:58,225 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:58,226 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:58,227 [main:106] - GETTING Continuation<*> from UShort
2021-03-12 07:56:58,249 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:58,250 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:58,250 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:58,251 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:58,252 [main:106] - GETTING Continuation<*> from Kla2
2021-03-12 07:56:58,258 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:58,259 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:56:58,260 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:58,261 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:58,262 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:58,262 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:58,263 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:58,264 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:58,265 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:58,266 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:58,266 [main:106] - GETTING Continuation<*> from UByte
2021-03-12 07:56:58,267 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:56:58,268 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:58,269 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:58,270 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:58,271 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:56:58,271 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:56:58,272 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:58,273 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:56:58,273 [main:111] - Cant find and generate replacement for prope8 type Continuation<*>
2021-03-12 07:56:58,273 [main:107] - replacing ({ it?.methodName?.startsWith(method) == true }, Function0<Boolean>)
2021-03-12 07:56:58,274 [main:50] - replacing { it?.methodName?.startsWith(method) == true } Function0<Boolean>
2021-03-12 07:56:58,274 [main:54] - Getting value of type Function0<Boolean>
2021-03-12 07:56:58,463 [main:302] - generating value of type = Function0<Boolean> false depth = 0
2021-03-12 07:56:58,471 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 07:56:58,478 [main:58] - GENERATED VALUE OF TYPE Function0<Boolean> = { false}
2021-03-12 07:56:58,479 [main:61] - GENERATED IS CALL =false
2021-03-12 07:56:58,509 [main:67] - randomType = Kla8
2021-03-12 07:56:58,708 [main:302] - generating value of type = Kla8 false depth = 0
2021-03-12 07:56:58,716 [main:112] - generating klass Kla8 text = open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}
2021-03-12 07:56:58,913 [main:194] - Type params = []
2021-03-12 07:56:59,104 [main:302] - generating value of type = CoroutineContext false depth = 2
2021-03-12 07:56:59,314 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:56:59,324 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:56:59,795 [main:302] - generating value of type = Key<*> false depth = 5
2021-03-12 07:57:00,006 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:57:00,015 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:57:00,786 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:57:00,786 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:57:00,804 [main:106] - GETTING Function0<Boolean> from Boolean
2021-03-12 07:57:00,817 [main:106] - GETTING Function0<Boolean> from Boolean
2021-03-12 07:57:00,818 [main:106] - GETTING Function0<Boolean> from UByte
2021-03-12 07:57:00,846 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:57:00,875 [main:106] - GETTING Function0<Boolean> from Boolean
2021-03-12 07:57:00,876 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:57:00,884 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:57:00,885 [main:106] - GETTING Function0<Boolean> from Function1<Int, Int>
2021-03-12 07:57:00,895 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:57:00,896 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:57:00,897 [main:106] - GETTING Function0<Boolean> from Kla2
2021-03-12 07:57:00,903 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:57:00,904 [main:106] - GETTING Function0<Boolean> from Boolean
2021-03-12 07:57:00,905 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:57:00,906 [main:106] - GETTING Function0<Boolean> from Boolean
2021-03-12 07:57:00,907 [main:106] - GETTING Function0<Boolean> from Function1<Int, Int>
2021-03-12 07:57:00,908 [main:106] - GETTING Function0<Boolean> from UByte
2021-03-12 07:57:00,909 [main:106] - GETTING Function0<Boolean> from Function1<Int, Int>
2021-03-12 07:57:00,910 [main:106] - GETTING Function0<Boolean> from UShort
2021-03-12 07:57:00,936 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:57:00,937 [main:106] - GETTING Function0<Boolean> from Boolean
2021-03-12 07:57:00,938 [main:106] - GETTING Function0<Boolean> from Boolean
2021-03-12 07:57:00,939 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:57:00,940 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:57:00,941 [main:106] - GETTING Function0<Boolean> from Function1<Int, Int>
2021-03-12 07:57:00,942 [main:106] - GETTING Function0<Boolean> from Kla0
2021-03-12 07:57:00,946 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:57:00,947 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:57:00,948 [main:106] - GETTING Function0<Boolean> from Float
2021-03-12 07:57:00,978 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:57:00,979 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:57:00,979 [main:106] - GETTING Function0<Boolean> from Byte
2021-03-12 07:57:01,009 [main:106] - GETTING Function0<Boolean> from Kla0
2021-03-12 07:57:01,010 [main:106] - GETTING Function0<Boolean> from Boolean
2021-03-12 07:57:01,011 [main:106] - GETTING Function0<Boolean> from Boolean
2021-03-12 07:57:01,012 [main:106] - GETTING Function0<Boolean> from Boolean
2021-03-12 07:57:01,013 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:57:01,014 [main:106] - GETTING Function0<Boolean> from Boolean
2021-03-12 07:57:01,015 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:57:01,016 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:57:01,017 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:57:01,018 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:57:01,018 [main:106] - GETTING Function0<Boolean> from Boolean
2021-03-12 07:57:01,019 [main:106] - GETTING Function0<Boolean> from Boolean
2021-03-12 07:57:01,020 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:57:01,021 [main:106] - GETTING Function0<Boolean> from Boolean
2021-03-12 07:57:01,022 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:57:01,023 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:57:01,024 [main:106] - GETTING Function0<Boolean> from Int
2021-03-12 07:57:01,025 [main:106] - GETTING Function0<Boolean> from Boolean
2021-03-12 07:57:01,026 [main:106] - GETTING Function0<Boolean> from Foo
2021-03-12 07:57:01,027 [main:106] - GETTING Function0<Boolean> from Char
2021-03-12 07:57:01,047 [main:114] - replacement of { it?.methodName?.startsWith(method) == true } of type Function0<Boolean> is { false}
2021-03-12 07:57:01,245 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 07:57:01,245 [main:66] - Compilation checking started
2021-03-12 07:57:02,221 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11(fu6<Kla4>())))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4(s)

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        prope13 = 0
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope13)
        if (prope14) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:57:02,223 [main:107] - replacing (getOrThrow(), Any?)
2021-03-12 07:57:02,224 [main:50] - replacing getOrThrow() Any?
2021-03-12 07:57:02,224 [main:54] - Getting value of type Any?
2021-03-12 07:57:02,427 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:02,427 [main:58] - GENERATED VALUE OF TYPE Any? = "zmety"
2021-03-12 07:57:02,427 [main:61] - GENERATED IS CALL =false
2021-03-12 07:57:02,938 [main:67] - randomType = ArrayDeque<Kla6>
2021-03-12 07:57:03,127 [main:302] - generating value of type = ArrayDeque<Kla6> false depth = 0
2021-03-12 07:57:03,325 [main:43] - GENERATING CALL OF fun <E> ArrayDeque(): ArrayDeque<Kla6> = TODO()
2021-03-12 07:57:03,334 [main:61] - WITHOUT TYPE PARAMS = fun <E> ArrayDeque(): ArrayDeque<Kla6> = TODO()
2021-03-12 07:57:03,561 [main:95] - GENERATED = ArrayDeque<Kla6>()
2021-03-12 07:57:03,682 [main:149] - GENERATING call of type @kotlin.js.JsName protected open fun toArray(): kotlin.Array<kotlin.Any?> defined in kotlin.collections.ArrayDeque[DeserializedSimpleFunctionDescriptor@72c4bf3]
2021-03-12 07:57:03,682 [main:149] - GENERATING call of type public final operator fun get(index: kotlin.Int): kotlin.Any? defined in kotlin.Array[DeserializedSimpleFunctionDescriptor@7c52d558]
2021-03-12 07:57:03,682 [main:78] - Generated call from random type = (ArrayDeque<Kla6>()).toArray().get((f.next()))
2021-03-12 07:57:03,684 [main:106] - GETTING Any? from Boolean
2021-03-12 07:57:03,694 [main:106] - GETTING Any? from Kla0
2021-03-12 07:57:03,699 [main:106] - GETTING Any? from Int
2021-03-12 07:57:03,730 [main:106] - GETTING Any? from Boolean
2021-03-12 07:57:03,731 [main:106] - GETTING Any? from Int
2021-03-12 07:57:03,732 [main:106] - GETTING Any? from Boolean
2021-03-12 07:57:03,733 [main:106] - GETTING Any? from Boolean
2021-03-12 07:57:03,734 [main:106] - GETTING Any? from Int
2021-03-12 07:57:03,735 [main:106] - GETTING Any? from Int
2021-03-12 07:57:03,736 [main:106] - GETTING Any? from Foo
2021-03-12 07:57:03,745 [main:106] - GETTING Any? from Int
2021-03-12 07:57:03,746 [main:106] - GETTING Any? from Boolean
2021-03-12 07:57:03,747 [main:106] - GETTING Any? from Kla0
2021-03-12 07:57:03,748 [main:106] - GETTING Any? from Kla2
2021-03-12 07:57:03,754 [main:106] - GETTING Any? from Int
2021-03-12 07:57:03,755 [main:106] - GETTING Any? from Boolean
2021-03-12 07:57:03,756 [main:106] - GETTING Any? from Foo
2021-03-12 07:57:03,757 [main:106] - GETTING Any? from Boolean
2021-03-12 07:57:03,758 [main:106] - GETTING Any? from Boolean
2021-03-12 07:57:03,759 [main:106] - GETTING Any? from Float
2021-03-12 07:57:03,788 [main:106] - GETTING Any? from Foo
2021-03-12 07:57:03,789 [main:106] - GETTING Any? from Function1<Int, Int>
2021-03-12 07:57:03,799 [main:106] - GETTING Any? from Boolean
2021-03-12 07:57:03,800 [main:106] - GETTING Any? from Foo
2021-03-12 07:57:03,801 [main:106] - GETTING Any? from Foo
2021-03-12 07:57:03,802 [main:106] - GETTING Any? from Int
2021-03-12 07:57:03,804 [main:106] - GETTING Any? from UByte
2021-03-12 07:57:03,827 [main:106] - GETTING Any? from Boolean
2021-03-12 07:57:03,828 [main:106] - GETTING Any? from Function1<Int, Int>
2021-03-12 07:57:03,829 [main:106] - GETTING Any? from Function1<Int, Int>
2021-03-12 07:57:03,830 [main:106] - GETTING Any? from Foo
2021-03-12 07:57:03,831 [main:106] - GETTING Any? from Boolean
2021-03-12 07:57:03,832 [main:106] - GETTING Any? from Byte
2021-03-12 07:57:03,862 [main:106] - GETTING Any? from Int
2021-03-12 07:57:03,863 [main:106] - GETTING Any? from Int
2021-03-12 07:57:03,864 [main:106] - GETTING Any? from Foo
2021-03-12 07:57:03,865 [main:106] - GETTING Any? from Boolean
2021-03-12 07:57:03,867 [main:106] - GETTING Any? from Foo
2021-03-12 07:57:03,868 [main:106] - GETTING Any? from Foo
2021-03-12 07:57:03,869 [main:106] - GETTING Any? from Int
2021-03-12 07:57:03,870 [main:106] - GETTING Any? from Boolean
2021-03-12 07:57:03,871 [main:106] - GETTING Any? from UByte
2021-03-12 07:57:03,872 [main:106] - GETTING Any? from Int
2021-03-12 07:57:03,873 [main:106] - GETTING Any? from Foo
2021-03-12 07:57:03,874 [main:106] - GETTING Any? from Int
2021-03-12 07:57:03,875 [main:106] - GETTING Any? from Foo
2021-03-12 07:57:03,876 [main:106] - GETTING Any? from Boolean
2021-03-12 07:57:03,877 [main:106] - GETTING Any? from Int
2021-03-12 07:57:03,878 [main:106] - GETTING Any? from Function1<Int, Int>
2021-03-12 07:57:03,879 [main:106] - GETTING Any? from Boolean
2021-03-12 07:57:03,880 [main:106] - GETTING Any? from Char
2021-03-12 07:57:03,901 [main:106] - GETTING Any? from UShort
2021-03-12 07:57:03,923 [main:114] - replacement of getOrThrow() of type Any? is (ArrayDeque<Kla6>()).toArray().get((f.next()))
2021-03-12 07:57:04,111 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:57:04,111 [main:66] - Compilation checking started
2021-03-12 07:57:04,666 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11(fu6<Kla4>())))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4(s)

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.(ArrayDeque<Kla6>()).toArray().get((f.next()))
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        prope13 = 0
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope13)
        if (prope14) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:57:04,668 [main:107] - replacing (prope14, Boolean)
2021-03-12 07:57:04,669 [main:50] - replacing prope14 Boolean
2021-03-12 07:57:04,669 [main:54] - Getting value of type Boolean
2021-03-12 07:57:04,865 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:57:04,873 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:57:04,873 [main:61] - GENERATED IS CALL =false
2021-03-12 07:57:05,384 [main:67] - randomType = Kla13?
2021-03-12 07:57:05,581 [main:302] - generating value of type = Kla13 false depth = 0
2021-03-12 07:57:05,589 [main:112] - generating klass Kla13 text = object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}
2021-03-12 07:57:05,606 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Kla13[DeserializedSimpleFunctionDescriptor@435987f7]
2021-03-12 07:57:05,799 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:05,799 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:57:05,995 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:05,996 [main:78] - Generated call from random type = (Kla13)?.equals("hjvnw").equals("rplpi")
2021-03-12 07:57:05,997 [main:106] - GETTING Boolean from Int
2021-03-12 07:57:06,031 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@273e47e2]]
2021-03-12 07:57:06,031 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:57:06,031 [main:149] - GENERATING call of type public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@273e47e2]
2021-03-12 07:57:06,031 [main:117] - GENERATED CALL = (Kla3().prope6).toChar().isTitleCase()
2021-03-12 07:57:06,032 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:57:06,032 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:57:06,032 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:57:06,228 [main:117] - GENERATED CALL = (Kla3().prope6).toInt().equals(null)
2021-03-12 07:57:06,228 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@454e7f3e]]
2021-03-12 07:57:06,228 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:57:06,228 [main:149] - GENERATING call of type public fun kotlin.Char.isDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@454e7f3e]
2021-03-12 07:57:06,228 [main:117] - GENERATED CALL = (Kla3().prope6).toChar().isDigit()
2021-03-12 07:57:06,228 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]]
2021-03-12 07:57:06,229 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:57:06,229 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]
2021-03-12 07:57:06,229 [main:117] - GENERATED CALL = (Kla3().prope6).toDouble().isInfinite()
2021-03-12 07:57:06,229 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@546bdc1a]]
2021-03-12 07:57:06,229 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8]
2021-03-12 07:57:06,438 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:57:06,447 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@546bdc1a]
2021-03-12 07:57:06,639 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:06,639 [main:117] - GENERATED CALL = (Kla3().prope6).rangeTo(-73).equals("hjyez")
2021-03-12 07:57:06,639 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]]
2021-03-12 07:57:06,639 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f]
2021-03-12 07:57:06,834 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:57:06,842 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]
2021-03-12 07:57:06,842 [main:117] - GENERATED CALL = (Kla3().prope6).div(0.7297240013062397).isFinite()
2021-03-12 07:57:06,842 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3bbcbd00]]
2021-03-12 07:57:06,842 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:57:06,842 [main:149] - GENERATING call of type public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3bbcbd00]
2021-03-12 07:57:07,031 [main:302] - generating value of type = Char true depth = 0
2021-03-12 07:57:07,039 [main:117] - GENERATED CALL = (Kla3().prope6).toChar().equals('', Kla1().fu3())
2021-03-12 07:57:07,039 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:57:07,039 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:57:07,227 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:07,228 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:57:07,417 [main:117] - GENERATED CALL = (Kla3().prope6).equals("shlft").equals(null)
2021-03-12 07:57:07,417 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7], public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@a67e46]]
2021-03-12 07:57:07,417 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 07:57:07,418 [main:149] - GENERATING call of type public fun kotlin.Float.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@a67e46]
2021-03-12 07:57:07,418 [main:117] - GENERATED CALL = (Kla3().prope6).toFloat().isInfinite()
2021-03-12 07:57:07,418 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4e3e340b]]
2021-03-12 07:57:07,418 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:57:07,418 [main:149] - GENERATING call of type public fun kotlin.Char.isLetter(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@4e3e340b]
2021-03-12 07:57:07,418 [main:117] - GENERATED CALL = (Kla3().prope6).toChar().isLetter()
2021-03-12 07:57:07,418 [main:114] - replacement of prope14 of type Boolean is (Kla3().prope6).div(0.7297240013062397).isFinite()
2021-03-12 07:57:07,606 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:57:07,607 [main:66] - Compilation checking started
2021-03-12 07:57:08,146 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11(fu6<Kla4>())))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4(s)

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = 0
        (Kla3().prope6).div(0.7297240013062397).isFinite() = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        for (i in 1..numberOfSuspensions) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope13)
        if (prope14) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:57:08,148 [main:107] - replacing (it as Continuation<Any>, Continuation<Any>)
2021-03-12 07:57:08,148 [main:50] - replacing it as Continuation<Any> Continuation<Any>
2021-03-12 07:57:08,148 [main:54] - Getting value of type Continuation<Any>
2021-03-12 07:57:08,335 [main:302] - generating value of type = Continuation<Any> false depth = 0
2021-03-12 07:57:08,536 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any>)->kotlin.Unit): Contuation<Any> = TODO()
2021-03-12 07:57:08,545 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any>)->kotlin.Unit): Contuation<Any> = TODO()
2021-03-12 07:57:09,259 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 07:57:09,469 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:57:09,478 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:57:09,965 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 07:57:10,175 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:57:10,184 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:57:10,908 [main:302] - generating value of type = Key<ContinuationInterceptor> false depth = 9
2021-03-12 07:57:11,117 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 07:57:11,127 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 07:57:11,850 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 07:57:11,851 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:57:11,851 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:57:11,851 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any>)->kotlin.Unit): Contuation<Any> = TODO()
2021-03-12 07:57:11,851 [main:58] - GENERATED VALUE OF TYPE Continuation<Any> = 
2021-03-12 07:57:14,286 [main:67] - randomType = Function2<Int, LinkedHashMap<Pair<UByte, Kla8>, Long>, List<Map<Kla13?, UByte?>>?>
2021-03-12 07:57:14,288 [main:106] - GETTING Continuation<Any> from Char
2021-03-12 07:57:14,309 [main:106] - GETTING Continuation<Any> from Int
2021-03-12 07:57:14,338 [main:106] - GETTING Continuation<Any> from Function1<Int, Int>
2021-03-12 07:57:14,348 [main:106] - GETTING Continuation<Any> from Boolean
2021-03-12 07:57:14,356 [main:106] - GETTING Continuation<Any> from Boolean
2021-03-12 07:57:14,357 [main:106] - GETTING Continuation<Any> from Int
2021-03-12 07:57:14,358 [main:106] - GETTING Continuation<Any> from Function1<Int, Int>
2021-03-12 07:57:14,359 [main:106] - GETTING Continuation<Any> from Foo
2021-03-12 07:57:14,367 [main:106] - GETTING Continuation<Any> from Foo
2021-03-12 07:57:14,368 [main:106] - GETTING Continuation<Any> from Foo
2021-03-12 07:57:14,369 [main:106] - GETTING Continuation<Any> from UByte
2021-03-12 07:57:14,391 [main:106] - GETTING Continuation<Any> from Kla0
2021-03-12 07:57:14,394 [main:106] - GETTING Continuation<Any> from Foo
2021-03-12 07:57:14,395 [main:106] - GETTING Continuation<Any> from Foo
2021-03-12 07:57:14,396 [main:106] - GETTING Continuation<Any> from Kla2
2021-03-12 07:57:14,402 [main:106] - GETTING Continuation<Any> from UByte
2021-03-12 07:57:14,403 [main:106] - GETTING Continuation<Any> from Float
2021-03-12 07:57:14,430 [main:106] - GETTING Continuation<Any> from Int
2021-03-12 07:57:14,431 [main:106] - GETTING Continuation<Any> from Int
2021-03-12 07:57:14,432 [main:106] - GETTING Continuation<Any> from Foo
2021-03-12 07:57:14,433 [main:106] - GETTING Continuation<Any> from Boolean
2021-03-12 07:57:14,434 [main:106] - GETTING Continuation<Any> from Int
2021-03-12 07:57:14,435 [main:106] - GETTING Continuation<Any> from Boolean
2021-03-12 07:57:14,436 [main:106] - GETTING Continuation<Any> from Int
2021-03-12 07:57:14,437 [main:106] - GETTING Continuation<Any> from Boolean
2021-03-12 07:57:14,437 [main:106] - GETTING Continuation<Any> from Int
2021-03-12 07:57:14,438 [main:106] - GETTING Continuation<Any> from Int
2021-03-12 07:57:14,439 [main:106] - GETTING Continuation<Any> from Foo
2021-03-12 07:57:14,440 [main:106] - GETTING Continuation<Any> from Int
2021-03-12 07:57:14,441 [main:106] - GETTING Continuation<Any> from Boolean
2021-03-12 07:57:14,442 [main:106] - GETTING Continuation<Any> from Boolean
2021-03-12 07:57:14,443 [main:106] - GETTING Continuation<Any> from Foo
2021-03-12 07:57:14,444 [main:106] - GETTING Continuation<Any> from Foo
2021-03-12 07:57:14,445 [main:106] - GETTING Continuation<Any> from Int
2021-03-12 07:57:14,446 [main:106] - GETTING Continuation<Any> from Boolean
2021-03-12 07:57:14,447 [main:106] - GETTING Continuation<Any> from Function1<Int, Int>
2021-03-12 07:57:14,448 [main:106] - GETTING Continuation<Any> from Boolean
2021-03-12 07:57:14,448 [main:106] - GETTING Continuation<Any> from UShort
2021-03-12 07:57:14,471 [main:106] - GETTING Continuation<Any> from Boolean
2021-03-12 07:57:14,472 [main:106] - GETTING Continuation<Any> from Boolean
2021-03-12 07:57:14,473 [main:106] - GETTING Continuation<Any> from Boolean
2021-03-12 07:57:14,474 [main:106] - GETTING Continuation<Any> from Int
2021-03-12 07:57:14,475 [main:106] - GETTING Continuation<Any> from Boolean
2021-03-12 07:57:14,476 [main:106] - GETTING Continuation<Any> from Int
2021-03-12 07:57:14,477 [main:106] - GETTING Continuation<Any> from Foo
2021-03-12 07:57:14,478 [main:106] - GETTING Continuation<Any> from Function1<Int, Int>
2021-03-12 07:57:14,478 [main:106] - GETTING Continuation<Any> from Boolean
2021-03-12 07:57:14,479 [main:106] - GETTING Continuation<Any> from Byte
2021-03-12 07:57:14,510 [main:106] - GETTING Continuation<Any> from Boolean
2021-03-12 07:57:14,511 [main:106] - GETTING Continuation<Any> from Int
2021-03-12 07:57:14,512 [main:106] - GETTING Continuation<Any> from Foo
2021-03-12 07:57:14,513 [main:106] - GETTING Continuation<Any> from Kla0
2021-03-12 07:57:14,513 [main:111] - Cant find and generate replacement for it as Continuation<Any> type Continuation<Any>
2021-03-12 07:57:14,513 [main:107] - replacing (prope14, Boolean)
2021-03-12 07:57:14,514 [main:50] - replacing prope14 Boolean
2021-03-12 07:57:14,514 [main:54] - Getting value of type Boolean
2021-03-12 07:57:14,707 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:57:14,715 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:57:14,715 [main:61] - GENERATED IS CALL =false
2021-03-12 07:57:14,747 [main:67] - randomType = Kla0
2021-03-12 07:57:14,747 [main:106] - GETTING Boolean from Boolean
2021-03-12 07:57:14,756 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:57:14,756 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 07:57:14,945 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:14,945 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:57:14,945 [main:117] - GENERATED CALL = (Kla1().fu3()).equals("veuad").not()
2021-03-12 07:57:14,945 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:57:14,945 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 07:57:15,136 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:15,136 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:57:15,328 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:57:15,336 [main:117] - GENERATED CALL = (Kla1().fu3()).equals("iwanc").xor(false)
2021-03-12 07:57:15,336 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:57:15,336 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 07:57:15,527 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:15,527 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:57:15,528 [main:117] - GENERATED CALL = (Kla1().fu3()).equals("psmht").or((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy"))
2021-03-12 07:57:15,528 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:57:15,528 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 07:57:15,732 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:15,732 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:57:15,732 [main:117] - GENERATED CALL = (Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())
2021-03-12 07:57:15,732 [main:113] - Case = [public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:57:15,732 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:57:15,733 [main:117] - GENERATED CALL = (Kla1().fu3()).or(prope1.fu4())
2021-03-12 07:57:15,733 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:57:15,733 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:57:15,921 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:15,921 [main:117] - GENERATED CALL = (Kla1().fu3()).equals("vpwlr")
2021-03-12 07:57:15,921 [main:113] - Case = [public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:57:15,921 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:57:15,922 [main:117] - GENERATED CALL = (Kla1().fu3()).and((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy"))
2021-03-12 07:57:15,922 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:57:15,922 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:57:16,113 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:57:16,121 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:57:16,310 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:16,310 [main:117] - GENERATED CALL = (Kla1().fu3()).compareTo(false).equals("wmxvz")
2021-03-12 07:57:16,310 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:57:16,310 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 07:57:16,499 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:16,499 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:57:16,688 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:16,689 [main:117] - GENERATED CALL = (Kla1().fu3()).equals("ocate").equals("rrhem")
2021-03-12 07:57:16,689 [main:113] - Case = [public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:57:16,689 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:57:16,689 [main:117] - GENERATED CALL = (Kla1().fu3()).not()
2021-03-12 07:57:16,689 [main:114] - replacement of prope14 of type Boolean is (Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())
2021-03-12 07:57:16,876 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:57:16,877 [main:66] - Compilation checking started
2021-03-12 07:57:17,805 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11(fu6<Kla4>())))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4(s)

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = 0
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in 1..numberOfSuspensions) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:57:17,808 [main:107] - replacing (1..numberOfSuspensions, IntRange)
2021-03-12 07:57:17,808 [main:50] - replacing 1..numberOfSuspensions IntRange
2021-03-12 07:57:17,808 [main:54] - Getting value of type IntRange
2021-03-12 07:57:18,015 [main:302] - generating value of type = IntRange false depth = 0
2021-03-12 07:57:18,214 [main:43] - GENERATING CALL OF fun IntRange(start: kotlin.Int, endInclusive: kotlin.Int): IntRange = TODO()
2021-03-12 07:57:18,224 [main:61] - WITHOUT TYPE PARAMS = fun IntRange(start: kotlin.Int, endInclusive: kotlin.Int): IntRange = TODO()
2021-03-12 07:57:18,916 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:57:18,924 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:57:18,952 [main:95] - GENERATED = IntRange(-715277236, -1386715245)
2021-03-12 07:57:18,952 [main:58] - GENERATED VALUE OF TYPE IntRange = IntRange(-715277236, -1386715245)
2021-03-12 07:57:18,953 [main:61] - GENERATED IS CALL =true
2021-03-12 07:57:18,984 [main:67] - randomType = Kla4
2021-03-12 07:57:19,174 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 07:57:19,182 [main:112] - generating klass Kla4 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)
2021-03-12 07:57:19,370 [main:194] - Type params = []
2021-03-12 07:57:19,558 [main:302] - generating value of type = String true depth = 2
2021-03-12 07:57:19,571 [main:106] - GETTING IntRange from Boolean
2021-03-12 07:57:19,579 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8]]
2021-03-12 07:57:19,579 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:57:19,579 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8]
2021-03-12 07:57:19,580 [main:117] - GENERATED CALL = (Kla2().fu1()).compareTo(prope1.fu4()).rangeTo((Foo(416482559, {a: Int -> 23}).state).toByte())
2021-03-12 07:57:19,580 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public infix fun kotlin.Int.until(to: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@679d66fa]]
2021-03-12 07:57:19,580 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:57:19,769 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:57:19,777 [main:149] - GENERATING call of type public infix fun kotlin.Int.until(to: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@679d66fa]
2021-03-12 07:57:19,777 [main:117] - GENERATED CALL = (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())
2021-03-12 07:57:19,777 [main:114] - replacement of 1..numberOfSuspensions of type IntRange is (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())
2021-03-12 07:57:19,967 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:57:19,967 [main:66] - Compilation checking started
2021-03-12 07:57:20,897 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11(fu6<Kla4>())))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4(s)

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = 0
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:57:20,900 [main:107] - replacing (fu10(fu11(fu6<Kla4>())), Kla4)
2021-03-12 07:57:20,901 [main:50] - replacing fu10(fu11(fu6<Kla4>())) Kla4
2021-03-12 07:57:20,901 [main:54] - Getting value of type Kla4
2021-03-12 07:57:21,106 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 07:57:21,114 [main:112] - generating klass Kla4 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)
2021-03-12 07:57:21,305 [main:194] - Type params = []
2021-03-12 07:57:21,498 [main:302] - generating value of type = String true depth = 2
2021-03-12 07:57:21,506 [main:58] - GENERATED VALUE OF TYPE Kla4 = Kla4("eohor")
2021-03-12 07:57:21,506 [main:61] - GENERATED IS CALL =true
2021-03-12 07:57:21,776 [main:67] - randomType = ArrayDeque<UByte>
2021-03-12 07:57:21,969 [main:302] - generating value of type = ArrayDeque<UByte> false depth = 0
2021-03-12 07:57:22,175 [main:43] - GENERATING CALL OF fun <E> ArrayDeque(initialCapacity: kotlin.Int): ArrayDeque<UByte> = TODO()
2021-03-12 07:57:22,185 [main:61] - WITHOUT TYPE PARAMS = fun <E> ArrayDeque(initialCapacity: kotlin.Int): ArrayDeque<UByte> = TODO()
2021-03-12 07:57:22,675 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:57:22,683 [main:95] - GENERATED = ArrayDeque<UByte>(433573046)
2021-03-12 07:57:22,817 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:57:22,826 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:57:22,834 [main:106] - GETTING Kla4 from Int
2021-03-12 07:57:22,863 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:57:22,864 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:57:22,872 [main:106] - GETTING Kla4 from UByte
2021-03-12 07:57:22,894 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:57:22,894 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:57:22,895 [main:106] - GETTING Kla4 from Int
2021-03-12 07:57:22,895 [main:106] - GETTING Kla4 from Int
2021-03-12 07:57:22,896 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:57:22,897 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:57:22,897 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:57:22,898 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:57:22,898 [main:106] - GETTING Kla4 from Int
2021-03-12 07:57:22,899 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:57:22,900 [main:106] - GETTING Kla4 from Int
2021-03-12 07:57:22,900 [main:106] - GETTING Kla4 from Int
2021-03-12 07:57:22,901 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:57:22,901 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:57:22,902 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:57:22,902 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:57:22,903 [main:106] - GETTING Kla4 from Int
2021-03-12 07:57:22,904 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:57:22,904 [main:106] - GETTING Kla4 from Int
2021-03-12 07:57:22,905 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:57:22,905 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:57:22,906 [main:106] - GETTING Kla4 from Kla0
2021-03-12 07:57:22,910 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:57:22,910 [main:106] - GETTING Kla4 from Kla2
2021-03-12 07:57:22,916 [main:106] - GETTING Kla4 from Int
2021-03-12 07:57:22,916 [main:106] - GETTING Kla4 from Int
2021-03-12 07:57:22,917 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:57:22,917 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:57:22,918 [main:106] - GETTING Kla4 from Int
2021-03-12 07:57:22,919 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:57:22,919 [main:106] - GETTING Kla4 from Kla0
2021-03-12 07:57:22,920 [main:106] - GETTING Kla4 from UByte
2021-03-12 07:57:22,920 [main:106] - GETTING Kla4 from Byte
2021-03-12 07:57:22,950 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:57:22,951 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:57:22,951 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:57:22,952 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:57:22,952 [main:106] - GETTING Kla4 from Char
2021-03-12 07:57:22,970 [main:106] - GETTING Kla4 from Int
2021-03-12 07:57:22,970 [main:106] - GETTING Kla4 from Float
2021-03-12 07:57:22,998 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:57:22,999 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:57:22,999 [main:106] - GETTING Kla4 from Int
2021-03-12 07:57:23,000 [main:106] - GETTING Kla4 from UShort
2021-03-12 07:57:23,021 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:57:23,022 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:57:23,022 [main:114] - replacement of fu10(fu11(fu6<Kla4>())) of type Kla4 is Kla4("eohor")
2021-03-12 07:57:23,216 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:57:23,217 [main:66] - Compilation checking started
2021-03-12 07:57:24,073 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4(s)

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = 0
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:57:24,075 [main:107] - replacing (prope15, Function0<Unit>)
2021-03-12 07:57:24,075 [main:50] - replacing prope15 Function0<Unit>
2021-03-12 07:57:24,075 [main:54] - Getting value of type Function0<Unit>
2021-03-12 07:57:24,269 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 07:57:24,277 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 07:57:24,479 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 07:57:24,490 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 07:57:24,941 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 07:57:24,950 [main:95] - GENERATED = require(false)
2021-03-12 07:57:24,950 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { require(false)}
2021-03-12 07:57:24,950 [main:61] - GENERATED IS CALL =false
2021-03-12 07:57:24,966 [main:67] - randomType = Long
2021-03-12 07:57:25,162 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:57:25,214 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:25,222 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:25,251 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:25,252 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:25,253 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:25,254 [main:106] - GETTING Function0<Unit> from Float
2021-03-12 07:57:25,282 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:25,283 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:25,284 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:25,285 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:25,293 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:25,294 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:25,295 [main:106] - GETTING Function0<Unit> from Byte
2021-03-12 07:57:25,325 [main:106] - GETTING Function0<Unit> from UShort
2021-03-12 07:57:25,351 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:25,352 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:25,353 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:57:25,365 [main:106] - GETTING Function0<Unit> from Kla2
2021-03-12 07:57:25,374 [main:106] - GETTING Function0<Unit> from Char
2021-03-12 07:57:25,400 [main:106] - GETTING Function0<Unit> from UByte
2021-03-12 07:57:25,430 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:25,431 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:25,432 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:25,433 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:25,434 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:25,435 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:25,436 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:25,437 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:25,438 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:25,439 [main:106] - GETTING Function0<Unit> from Kla0
2021-03-12 07:57:25,443 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:57:25,444 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:25,445 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:25,446 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:25,447 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:25,448 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:25,449 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:25,450 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:25,451 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:25,452 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:25,453 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:25,454 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:25,455 [main:106] - GETTING Function0<Unit> from Kla0
2021-03-12 07:57:25,455 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:25,456 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:25,457 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:25,458 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:57:25,459 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:57:25,460 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:25,461 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:25,462 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:25,463 [main:106] - GETTING Function0<Unit> from UByte
2021-03-12 07:57:25,463 [main:114] - replacement of prope15 of type Function0<Unit> is { require(false)}
2021-03-12 07:57:25,655 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 07:57:25,656 [main:66] - Compilation checking started
2021-03-12 07:57:26,221 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4(s)

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = 0
        prope14 = false
        { require(false)} = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:57:26,223 [main:107] - replacing (prope15, Function0<Unit>)
2021-03-12 07:57:26,223 [main:50] - replacing prope15 Function0<Unit>
2021-03-12 07:57:26,223 [main:54] - Getting value of type Function0<Unit>
2021-03-12 07:57:26,415 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 07:57:26,424 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 07:57:26,631 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 07:57:26,641 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 07:57:27,090 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 07:57:27,098 [main:95] - GENERATED = require(true)
2021-03-12 07:57:27,098 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { require(true)}
2021-03-12 07:57:27,098 [main:61] - GENERATED IS CALL =false
2021-03-12 07:57:27,366 [main:67] - randomType = Float?
2021-03-12 07:57:27,558 [main:302] - generating value of type = Float true depth = 0
2021-03-12 07:57:27,596 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:27,626 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:27,635 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:27,636 [main:106] - GETTING Function0<Unit> from UByte
2021-03-12 07:57:27,658 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:27,659 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:57:27,668 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:27,669 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:27,670 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:27,671 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:27,672 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:27,681 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:27,682 [main:106] - GETTING Function0<Unit> from Byte
2021-03-12 07:57:27,711 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:27,712 [main:106] - GETTING Function0<Unit> from UShort
2021-03-12 07:57:27,734 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:27,735 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:27,736 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:27,737 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:27,738 [main:106] - GETTING Function0<Unit> from Float
2021-03-12 07:57:27,766 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:27,767 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:27,767 [main:106] - GETTING Function0<Unit> from Kla2
2021-03-12 07:57:27,773 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:27,774 [main:106] - GETTING Function0<Unit> from UByte
2021-03-12 07:57:27,775 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:57:27,776 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:27,777 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:27,778 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:27,779 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:27,780 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:27,781 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:27,782 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:27,783 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:57:27,784 [main:106] - GETTING Function0<Unit> from Kla0
2021-03-12 07:57:27,788 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:27,789 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:27,790 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:27,791 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:27,792 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:27,793 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:27,794 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:27,795 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:27,796 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:57:27,797 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:27,798 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:27,799 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:27,800 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:27,801 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:27,802 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:27,803 [main:106] - GETTING Function0<Unit> from Char
2021-03-12 07:57:27,827 [main:106] - GETTING Function0<Unit> from Kla0
2021-03-12 07:57:27,827 [main:114] - replacement of prope15 of type Function0<Unit> is { require(true)}
2021-03-12 07:57:28,037 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 07:57:28,038 [main:66] - Compilation checking started
2021-03-12 07:57:28,588 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4(s)

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = 0
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        { require(true)} = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:57:28,591 [main:107] - replacing (prope10.prope14, Boolean)
2021-03-12 07:57:28,591 [main:50] - replacing prope10.prope14 Boolean
2021-03-12 07:57:28,591 [main:54] - Getting value of type Boolean
2021-03-12 07:57:28,785 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:57:28,794 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:57:28,794 [main:61] - GENERATED IS CALL =false
2021-03-12 07:57:28,810 [main:67] - randomType = Double
2021-03-12 07:57:29,007 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:57:29,042 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@34594779]
2021-03-12 07:57:29,236 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:29,236 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:57:29,236 [main:78] - Generated call from random type = (0.005371210275863625).equals("ydeeh").not()
2021-03-12 07:57:29,236 [main:106] - GETTING Boolean from Boolean
2021-03-12 07:57:29,245 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:57:29,245 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:57:29,245 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:57:29,439 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:29,439 [main:117] - GENERATED CALL = (Kla2().fu1()).compareTo(Kla1().fu2()).equals("xhkvw")
2021-03-12 07:57:29,439 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:57:29,439 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:57:29,643 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:29,643 [main:117] - GENERATED CALL = (Kla2().fu1()).equals("wyvde")
2021-03-12 07:57:29,643 [main:113] - Case = [public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:57:29,643 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:57:29,643 [main:117] - GENERATED CALL = (Kla2().fu1()).or(Kla2().fu1())
2021-03-12 07:57:29,643 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:57:29,643 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 07:57:29,838 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:29,838 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:57:29,839 [main:117] - GENERATED CALL = (Kla2().fu1()).equals("qcfho").or(Kla2().fu2())
2021-03-12 07:57:29,839 [main:113] - Case = [public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:57:29,839 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:57:29,839 [main:117] - GENERATED CALL = (Kla2().fu1()).not()
2021-03-12 07:57:29,839 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:57:29,839 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 07:57:30,035 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:30,035 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:57:30,228 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:30,229 [main:117] - GENERATED CALL = (Kla2().fu1()).equals("kltyy").equals("bwwym")
2021-03-12 07:57:30,229 [main:113] - Case = [public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:57:30,229 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:57:30,229 [main:117] - GENERATED CALL = (Kla2().fu1()).xor(Kla2().fu4())
2021-03-12 07:57:30,229 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:57:30,229 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 07:57:30,422 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:30,422 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:57:30,422 [main:117] - GENERATED CALL = (Kla2().fu1()).equals("djcrt").xor(Kla2().fu2())
2021-03-12 07:57:30,422 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:57:30,422 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 07:57:30,626 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:30,626 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:57:30,835 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:57:30,844 [main:117] - GENERATED CALL = (Kla2().fu1()).equals("yvidf").and(true)
2021-03-12 07:57:30,844 [main:113] - Case = [public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:57:30,844 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:57:31,040 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:57:31,048 [main:117] - GENERATED CALL = (Kla2().fu1()).and(true)
2021-03-12 07:57:31,048 [main:114] - replacement of prope10.prope14 of type Boolean is (Kla2().fu1()).or(Kla2().fu1())
2021-03-12 07:57:31,258 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:57:31,259 [main:66] - Compilation checking started
2021-03-12 07:57:31,807 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4(s)

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = 0
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            (Kla2().fu1()).or(Kla2().fu1()) = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:57:31,810 [main:107] - replacing (suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}, Ty0)
2021-03-12 07:57:31,810 [main:50] - replacing suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
} Ty0
2021-03-12 07:57:31,810 [main:54] - Getting value of type Ty0
2021-03-12 07:57:32,005 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 07:57:32,016 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 07:57:32,257 [main:67] - randomType = Short
2021-03-12 07:57:32,453 [main:302] - generating value of type = Short true depth = 0
2021-03-12 07:57:32,492 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:32,500 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:32,529 [main:106] - GETTING Ty0 from Char
2021-03-12 07:57:32,545 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:32,546 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:57:32,555 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:32,562 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:57:32,563 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:32,563 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:57:32,564 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:32,564 [main:106] - GETTING Ty0 from Float
2021-03-12 07:57:32,593 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:32,594 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:32,594 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:32,595 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:32,595 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:32,596 [main:106] - GETTING Ty0 from UShort
2021-03-12 07:57:32,618 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:32,618 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:32,619 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:32,619 [main:106] - GETTING Ty0 from Byte
2021-03-12 07:57:32,649 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:32,649 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:32,650 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:32,650 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:32,651 [main:106] - GETTING Ty0 from Kla2
2021-03-12 07:57:32,657 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:32,657 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:32,658 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:32,659 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:32,659 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:32,660 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:32,660 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:32,661 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:57:32,662 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:32,662 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:32,663 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:32,663 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:32,664 [main:106] - GETTING Ty0 from UByte
2021-03-12 07:57:32,686 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:32,687 [main:106] - GETTING Ty0 from UByte
2021-03-12 07:57:32,688 [main:106] - GETTING Ty0 from Kla0
2021-03-12 07:57:32,691 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:32,691 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:32,692 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:32,692 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:32,693 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:32,694 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:32,694 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:32,695 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:32,695 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:32,696 [main:106] - GETTING Ty0 from Kla0
2021-03-12 07:57:32,696 [main:111] - Cant find and generate replacement for suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
} type Ty0
2021-03-12 07:57:32,696 [main:107] - replacing (s, String)
2021-03-12 07:57:32,696 [main:50] - replacing s String
2021-03-12 07:57:32,696 [main:54] - Getting value of type String
2021-03-12 07:57:32,889 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:57:32,897 [main:58] - GENERATED VALUE OF TYPE String = "oibwa"
2021-03-12 07:57:32,897 [main:61] - GENERATED IS CALL =false
2021-03-12 07:57:33,156 [main:67] - randomType = Char?
2021-03-12 07:57:33,354 [main:302] - generating value of type = Char true depth = 0
2021-03-12 07:57:33,382 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Char defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@229dfe7e]
2021-03-12 07:57:33,383 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 07:57:33,383 [main:78] - Generated call from random type = ('')?.dec().titlecase()
2021-03-12 07:57:33,384 [main:106] - GETTING String from Int
2021-03-12 07:57:33,412 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:57:33,412 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:57:33,413 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:57:33,413 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).state).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).state)
2021-03-12 07:57:33,413 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 07:57:33,413 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:57:33,413 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 07:57:33,413 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).state).toChar().titlecase()
2021-03-12 07:57:33,413 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:57:33,413 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:57:33,414 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).state).toString(Foo(416482559, {a: Int -> 23}).state)
2021-03-12 07:57:33,414 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:57:33,414 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:57:33,414 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:57:33,608 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:57:33,616 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).state).compareTo(Foo(1397637829, {a: Int -> -710498597}).next()).toString(-621884171)
2021-03-12 07:57:33,616 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:57:33,616 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:57:33,616 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:57:33,617 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).state).toLong().toString(Foo(1397637829, {a: Int -> -710498597}).next())
2021-03-12 07:57:33,617 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 07:57:33,617 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:57:33,617 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 07:57:33,617 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).state).toChar().lowercase()
2021-03-12 07:57:33,617 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 07:57:33,617 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:57:33,617 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:57:33,813 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:57:33,821 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).state).toShort().toString(34525313)
2021-03-12 07:57:33,821 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]]
2021-03-12 07:57:33,821 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:57:33,821 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]
2021-03-12 07:57:33,821 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase()
2021-03-12 07:57:33,821 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:57:33,821 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 07:57:34,015 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:57:34,023 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:57:34,234 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:57:34,242 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).state).div(-2551413941536906994).toString(1178867956)
2021-03-12 07:57:34,242 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 07:57:34,242 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:57:34,243 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 07:57:34,439 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:57:34,447 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).state).toChar().plus("wyryy")
2021-03-12 07:57:34,447 [main:114] - replacement of s of type String is (Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase()
2021-03-12 07:57:34,638 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:57:34,638 [main:66] - Compilation checking started
2021-03-12 07:57:35,544 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = 0
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:57:35,547 [main:107] - replacing (0, Int)
2021-03-12 07:57:35,547 [main:50] - replacing 0 Int
2021-03-12 07:57:35,547 [main:54] - Getting value of type Int
2021-03-12 07:57:35,742 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:57:35,750 [main:58] - GENERATED VALUE OF TYPE Int = -21270334
2021-03-12 07:57:35,750 [main:61] - GENERATED IS CALL =false
2021-03-12 07:57:36,025 [main:67] - randomType = Array<Kla2>
2021-03-12 07:57:36,220 [main:302] - generating value of type = Array<Kla2> false depth = 0
2021-03-12 07:57:36,425 [main:43] - GENERATING CALL OF fun <T> Array(size: kotlin.Int, init: (kotlin.Int)->Kla2): Array<Kla2> = TODO()
2021-03-12 07:57:36,435 [main:61] - WITHOUT TYPE PARAMS = fun <T> Array(size: kotlin.Int, init: (kotlin.Int)->Kla2): Array<Kla2> = TODO()
2021-03-12 07:57:37,140 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:57:37,149 [main:302] - generating value of type = Function1<Int, Kla2> false depth = 3
2021-03-12 07:57:37,157 [main:302] - generating value of type = Kla2 false depth = 4
2021-03-12 07:57:37,165 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 07:57:37,165 [main:95] - GENERATED = Array<Kla2>(861863364, {a: Int -> Kla2()})
2021-03-12 07:57:37,176 [main:78] - Generated call from random type = (Array<Kla2>(861863364, {a: Int -> Kla2()})).size
2021-03-12 07:57:37,176 [main:106] - GETTING Int from Int
2021-03-12 07:57:37,204 [main:113] - Case = [public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@63d279b5]]
2021-03-12 07:57:37,204 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@63d279b5]
2021-03-12 07:57:37,205 [main:117] - GENERATED CALL = ((f.next())).and((f).next())
2021-03-12 07:57:37,205 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@62f7e5f9]]
2021-03-12 07:57:37,205 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:57:37,205 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@62f7e5f9]
2021-03-12 07:57:37,205 [main:117] - GENERATED CALL = ((f.next())).compareTo((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()).ushr(Kla3().prope6)
2021-03-12 07:57:37,205 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4b5951a3]]
2021-03-12 07:57:37,205 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:57:37,205 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Short.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4b5951a3]
2021-03-12 07:57:37,206 [main:117] - GENERATED CALL = ((f.next())).toShort().countTrailingZeroBits()
2021-03-12 07:57:37,206 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3495fc12]]
2021-03-12 07:57:37,206 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:57:37,206 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3495fc12]
2021-03-12 07:57:37,206 [main:117] - GENERATED CALL = ((f.next())).compareTo(Kla3().prope6).times((Foo(416482559, {a: Int -> 23}).state).toByte())
2021-03-12 07:57:37,206 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], public open fun toInt(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@6865832d]]
2021-03-12 07:57:37,206 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:57:37,206 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@6865832d]
2021-03-12 07:57:37,206 [main:117] - GENERATED CALL = ((f.next())).toShort().toInt()
2021-03-12 07:57:37,207 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public open fun toInt(): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@45ebde80]]
2021-03-12 07:57:37,207 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:57:37,207 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@45ebde80]
2021-03-12 07:57:37,207 [main:117] - GENERATED CALL = ((f.next())).toDouble().toInt()
2021-03-12 07:57:37,207 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@529bf692]]
2021-03-12 07:57:37,207 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:57:37,207 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@529bf692]
2021-03-12 07:57:37,434 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:57:37,442 [main:117] - GENERATED CALL = ((f.next())).toInt().minus(-33)
2021-03-12 07:57:37,442 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7252e063]]
2021-03-12 07:57:37,442 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:57:37,442 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7252e063]
2021-03-12 07:57:37,636 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:57:37,645 [main:117] - GENERATED CALL = ((f.next())).toShort().rem(95)
2021-03-12 07:57:37,645 [main:113] - Case = [public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4fa2ec50]]
2021-03-12 07:57:37,645 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4fa2ec50]
2021-03-12 07:57:37,645 [main:117] - GENERATED CALL = ((f.next())).unaryMinus()
2021-03-12 07:57:37,645 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@35d0f108]]
2021-03-12 07:57:37,645 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:57:37,842 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:57:37,850 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@35d0f108]
2021-03-12 07:57:37,850 [main:117] - GENERATED CALL = ((f.next())).compareTo(1257052942).unaryPlus()
2021-03-12 07:57:37,850 [main:114] - replacement of 0 of type Int is ((f.next())).toShort().toInt()
2021-03-12 07:57:38,042 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:57:38,043 [main:66] - Compilation checking started
2021-03-12 07:57:38,973 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + numberOfSuspensions + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:57:38,976 [main:107] - replacing (numberOfSuspensions, Int)
2021-03-12 07:57:38,976 [main:50] - replacing numberOfSuspensions Int
2021-03-12 07:57:38,976 [main:54] - Getting value of type Int
2021-03-12 07:57:39,177 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:57:39,186 [main:58] - GENERATED VALUE OF TYPE Int = 1971577449
2021-03-12 07:57:39,186 [main:61] - GENERATED IS CALL =false
2021-03-12 07:57:39,203 [main:67] - randomType = Byte
2021-03-12 07:57:39,400 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:57:39,441 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:57:39,442 [main:149] - GENERATING call of type public fun kotlin.Int.coerceAtMost(maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@741f1e49]
2021-03-12 07:57:39,442 [main:78] - Generated call from random type = (-56).toInt().coerceAtMost((Foo(-655341081, {a: Int -> 120045518}).state))
2021-03-12 07:57:39,442 [main:106] - GETTING Int from Int
2021-03-12 07:57:39,470 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3833da6f]]
2021-03-12 07:57:39,470 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:57:39,470 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3833da6f]
2021-03-12 07:57:39,664 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:57:39,673 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).compareTo(Foo(416482559, {a: Int -> 23}).state).rem(45)
2021-03-12 07:57:39,673 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7], public open fun toInt(): kotlin.Int defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@5f9f94ec]]
2021-03-12 07:57:39,673 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 07:57:39,673 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@5f9f94ec]
2021-03-12 07:57:39,673 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toFloat().toInt()
2021-03-12 07:57:39,673 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public final operator fun minus(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@63d3006a]]
2021-03-12 07:57:39,673 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:57:39,673 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@63d3006a]
2021-03-12 07:57:39,867 [main:302] - generating value of type = Char true depth = 0
2021-03-12 07:57:39,875 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('')
2021-03-12 07:57:39,875 [main:113] - Case = [public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3495fc12]]
2021-03-12 07:57:39,875 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3495fc12]
2021-03-12 07:57:40,069 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:57:40,078 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).times(14)
2021-03-12 07:57:40,078 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@1ece8c98]]
2021-03-12 07:57:40,078 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:57:40,078 [main:149] - GENERATING call of type public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@1ece8c98]
2021-03-12 07:57:40,271 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:57:40,280 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toInt().coerceIn(1941548299, (Foo(416482559, {a: Int -> 23}).state))
2021-03-12 07:57:40,280 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3c01ca5a]]
2021-03-12 07:57:40,280 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:57:40,280 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@3c01ca5a]
2021-03-12 07:57:40,281 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toShort().div((Foo(416482559, {a: Int -> 23}).state).toByte())
2021-03-12 07:57:40,281 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@529bf692]]
2021-03-12 07:57:40,281 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:57:40,281 [main:149] - GENERATING call of type public final operator fun minus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@529bf692]
2021-03-12 07:57:40,474 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:57:40,482 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toInt().minus(-67)
2021-03-12 07:57:40,482 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@6078e75b]]
2021-03-12 07:57:40,482 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:57:40,482 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@6078e75b]
2021-03-12 07:57:40,483 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toLong().countLeadingZeroBits()
2021-03-12 07:57:40,483 [main:113] - Case = [public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16107de0]]
2021-03-12 07:57:40,483 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16107de0]
2021-03-12 07:57:40,483 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toInt()
2021-03-12 07:57:40,483 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@55ba52cc]]
2021-03-12 07:57:40,483 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:57:40,483 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Byte.countTrailingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@55ba52cc]
2021-03-12 07:57:40,483 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toByte().countTrailingZeroBits()
2021-03-12 07:57:40,483 [main:114] - replacement of numberOfSuspensions of type Int is (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('')
2021-03-12 07:57:40,696 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:57:40,697 [main:66] - Compilation checking started
2021-03-12 07:57:41,628 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = true) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:57:41,631 [main:107] - replacing (prope8, Continuation<*>)
2021-03-12 07:57:41,631 [main:50] - replacing prope8 Continuation<*>
2021-03-12 07:57:41,631 [main:54] - Getting value of type Continuation<*>
2021-03-12 07:57:41,825 [main:302] - generating value of type = Continuation<*> false depth = 0
2021-03-12 07:57:42,030 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 07:57:42,040 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 07:57:42,781 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 07:57:42,986 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:57:42,996 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:57:43,478 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 07:57:43,691 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<AbstractCoroutineContextElement>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:57:43,701 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<AbstractCoroutineContextElement>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:57:44,493 [main:302] - generating value of type = Key<AbstractCoroutineContextElement> false depth = 9
2021-03-12 07:57:44,706 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->AbstractCoroutineContextElement): Key<AbstractCoroutineContextElement> = TODO()
2021-03-12 07:57:44,716 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->AbstractCoroutineContextElement): Key<AbstractCoroutineContextElement> = TODO()
2021-03-12 07:57:45,456 [main:302] - generating value of type = Key<ContinuationInterceptor> false depth = 12
2021-03-12 07:57:45,671 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 07:57:45,681 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 07:57:46,421 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->ContinuationInterceptor): Key<ContinuationInterceptor> = TODO()
2021-03-12 07:57:46,421 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<ContinuationInterceptor>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->AbstractCoroutineContextElement): Key<AbstractCoroutineContextElement> = TODO()
2021-03-12 07:57:46,422 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<AbstractCoroutineContextElement>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:57:46,422 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:57:46,422 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 07:57:46,422 [main:58] - GENERATED VALUE OF TYPE Continuation<*> = 
2021-03-12 07:57:46,439 [main:67] - randomType = Float
2021-03-12 07:57:46,633 [main:302] - generating value of type = Float true depth = 0
2021-03-12 07:57:46,678 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:57:46,718 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:57:46,730 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:57:46,731 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:57:46,742 [main:106] - GETTING Continuation<*> from UByte
2021-03-12 07:57:46,779 [main:106] - GETTING Continuation<*> from Kla2
2021-03-12 07:57:46,789 [main:106] - GETTING Continuation<*> from Float
2021-03-12 07:57:46,822 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:57:46,823 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:57:46,824 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:57:46,825 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:57:46,835 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:57:46,836 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:57:46,836 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:57:46,837 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:57:46,838 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:57:46,839 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:57:46,840 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:57:46,841 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:57:46,841 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:57:46,842 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:57:46,843 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:57:46,844 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:57:46,845 [main:106] - GETTING Continuation<*> from UShort
2021-03-12 07:57:46,889 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:57:46,890 [main:106] - GETTING Continuation<*> from Kla0
2021-03-12 07:57:46,895 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:57:46,896 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:57:46,896 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:57:46,897 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:57:46,898 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:57:46,899 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:57:46,900 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:57:46,901 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:57:46,902 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:57:46,903 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:57:46,903 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:57:46,904 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:57:46,905 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:57:46,906 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:57:46,907 [main:106] - GETTING Continuation<*> from Byte
2021-03-12 07:57:46,940 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:57:46,940 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:57:46,941 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:57:46,942 [main:106] - GETTING Continuation<*> from Char
2021-03-12 07:57:46,959 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:57:46,960 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:57:46,961 [main:106] - GETTING Continuation<*> from Kla0
2021-03-12 07:57:46,962 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:57:46,963 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:57:46,964 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:57:46,964 [main:106] - GETTING Continuation<*> from UByte
2021-03-12 07:57:46,964 [main:111] - Cant find and generate replacement for prope8 type Continuation<*>
2021-03-12 07:57:46,964 [main:107] - replacing (suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}, Ty0)
2021-03-12 07:57:46,965 [main:50] - replacing suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
} Ty0
2021-03-12 07:57:46,965 [main:54] - Getting value of type Ty0
2021-03-12 07:57:47,160 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 07:57:47,171 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 07:57:47,188 [main:67] - randomType = UInt
2021-03-12 07:57:47,381 [main:302] - generating value of type = UInt true depth = 0
2021-03-12 07:57:47,415 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:47,422 [main:106] - GETTING Ty0 from Char
2021-03-12 07:57:47,438 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:47,439 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:47,447 [main:106] - GETTING Ty0 from Kla2
2021-03-12 07:57:47,452 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:47,453 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:47,481 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:47,482 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:47,482 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:47,483 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:47,483 [main:106] - GETTING Ty0 from UShort
2021-03-12 07:57:47,505 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:57:47,514 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:47,514 [main:106] - GETTING Ty0 from UByte
2021-03-12 07:57:47,535 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:47,536 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:47,536 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:47,537 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:57:47,538 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:47,538 [main:106] - GETTING Ty0 from Byte
2021-03-12 07:57:47,567 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:47,568 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:47,569 [main:106] - GETTING Ty0 from Kla0
2021-03-12 07:57:47,572 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:47,572 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:47,573 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:57:47,574 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:47,574 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:47,575 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:47,575 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:47,576 [main:106] - GETTING Ty0 from Kla0
2021-03-12 07:57:47,576 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:47,577 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:47,578 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:47,578 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:47,579 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:47,579 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:47,580 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:47,581 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:47,581 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:47,582 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:47,582 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:47,583 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:47,583 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:47,584 [main:106] - GETTING Ty0 from UByte
2021-03-12 07:57:47,585 [main:106] - GETTING Ty0 from Float
2021-03-12 07:57:47,612 [main:106] - GETTING Ty0 from Int
2021-03-12 07:57:47,613 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:47,613 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:57:47,614 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:57:47,615 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:57:47,615 [main:111] - Cant find and generate replacement for suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
} type Ty0
2021-03-12 07:57:47,615 [main:107] - replacing (true, Boolean)
2021-03-12 07:57:47,615 [main:50] - replacing true Boolean
2021-03-12 07:57:47,615 [main:54] - Getting value of type Boolean
2021-03-12 07:57:47,809 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:57:47,817 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:57:47,817 [main:61] - GENERATED IS CALL =false
2021-03-12 07:57:47,834 [main:67] - randomType = String
2021-03-12 07:57:48,028 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:57:48,052 [main:149] - GENERATING call of type public open fun get(index: kotlin.Int): kotlin.Char defined in kotlin.String[DeserializedSimpleFunctionDescriptor@778d9f3d]
2021-03-12 07:57:48,053 [main:149] - GENERATING call of type public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@273e47e2]
2021-03-12 07:57:48,053 [main:78] - Generated call from random type = ("qxfiw").get((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next()))).isTitleCase()
2021-03-12 07:57:48,054 [main:106] - GETTING Boolean from Int
2021-03-12 07:57:48,083 [main:113] - Case = [public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7], public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@54d06bc6]]
2021-03-12 07:57:48,084 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 07:57:48,084 [main:149] - GENERATING call of type public fun kotlin.Float.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@54d06bc6]
2021-03-12 07:57:48,084 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toFloat().isNaN()
2021-03-12 07:57:48,084 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:57:48,084 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:57:48,276 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:57:48,276 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())
2021-03-12 07:57:48,277 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@273e47e2]]
2021-03-12 07:57:48,277 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:57:48,277 [main:149] - GENERATING call of type public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@273e47e2]
2021-03-12 07:57:48,277 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().isTitleCase()
2021-03-12 07:57:48,277 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:57:48,277 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:57:48,277 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:57:48,470 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:48,471 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toInt().equals("steie")
2021-03-12 07:57:48,471 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]]
2021-03-12 07:57:48,471 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f]
2021-03-12 07:57:48,664 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:57:48,672 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]
2021-03-12 07:57:48,673 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).div(0.8829312339241565).isFinite()
2021-03-12 07:57:48,673 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8], public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@37c34207]]
2021-03-12 07:57:48,673 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8]
2021-03-12 07:57:48,866 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:57:48,875 [main:149] - GENERATING call of type public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.IntRange[DeserializedSimpleFunctionDescriptor@37c34207]
2021-03-12 07:57:48,875 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).rangeTo(-118).isEmpty()
2021-03-12 07:57:48,875 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:57:48,875 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:57:49,069 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:57:49,261 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:49,262 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).equals("foutv")
2021-03-12 07:57:49,262 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@34594779]]
2021-03-12 07:57:49,262 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:57:49,262 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@34594779]
2021-03-12 07:57:49,455 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:49,456 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toDouble().equals("aynoc")
2021-03-12 07:57:49,456 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]]
2021-03-12 07:57:49,456 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 07:57:49,456 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]
2021-03-12 07:57:49,456 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toDouble().isInfinite()
2021-03-12 07:57:49,456 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7b609fa2]]
2021-03-12 07:57:49,456 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:57:49,456 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7b609fa2]
2021-03-12 07:57:49,650 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:57:49,651 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toShort().equals("rkinx")
2021-03-12 07:57:49,651 [main:114] - replacement of true of type Boolean is (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())
2021-03-12 07:57:49,865 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:57:49,865 [main:66] - Compilation checking started
2021-03-12 07:57:50,953 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:57:50,957 [main:107] - replacing (EmptyCoroutineContext, EmptyCoroutineContext)
2021-03-12 07:57:50,957 [main:50] - replacing EmptyCoroutineContext EmptyCoroutineContext
2021-03-12 07:57:50,957 [main:54] - Getting value of type EmptyCoroutineContext
2021-03-12 07:57:51,183 [main:302] - generating value of type = EmptyCoroutineContext false depth = 0
2021-03-12 07:57:51,194 [main:58] - GENERATED VALUE OF TYPE EmptyCoroutineContext = 
2021-03-12 07:57:51,508 [main:67] - randomType = HashMap<UInt, Kla12>
2021-03-12 07:57:51,711 [main:302] - generating value of type = HashMap<UInt, Kla12> false depth = 0
2021-03-12 07:57:51,929 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(): HashMap<UInt, Kla12> = TODO()
2021-03-12 07:57:51,940 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(): HashMap<UInt, Kla12> = TODO()
2021-03-12 07:57:52,154 [main:95] - GENERATED = linkedMapOf<UInt, Kla12>()
2021-03-12 07:57:52,277 [main:106] - GETTING EmptyCoroutineContext from UShort
2021-03-12 07:57:52,314 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 07:57:52,325 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 07:57:52,355 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 07:57:52,363 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 07:57:52,364 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 07:57:52,365 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 07:57:52,365 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 07:57:52,366 [main:106] - GETTING EmptyCoroutineContext from Function1<Int, Int>
2021-03-12 07:57:52,376 [main:106] - GETTING EmptyCoroutineContext from Function1<Int, Int>
2021-03-12 07:57:52,377 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 07:57:52,377 [main:106] - GETTING EmptyCoroutineContext from Float
2021-03-12 07:57:52,404 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 07:57:52,405 [main:106] - GETTING EmptyCoroutineContext from Kla0
2021-03-12 07:57:52,408 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 07:57:52,409 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 07:57:52,409 [main:106] - GETTING EmptyCoroutineContext from UByte
2021-03-12 07:57:52,431 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 07:57:52,431 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 07:57:52,432 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 07:57:52,433 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 07:57:52,433 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 07:57:52,434 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 07:57:52,434 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 07:57:52,435 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 07:57:52,436 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 07:57:52,436 [main:106] - GETTING EmptyCoroutineContext from Function1<Int, Int>
2021-03-12 07:57:52,437 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 07:57:52,438 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 07:57:52,438 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 07:57:52,439 [main:106] - GETTING EmptyCoroutineContext from UByte
2021-03-12 07:57:52,440 [main:106] - GETTING EmptyCoroutineContext from Kla2
2021-03-12 07:57:52,445 [main:106] - GETTING EmptyCoroutineContext from Kla0
2021-03-12 07:57:52,446 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 07:57:52,447 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 07:57:52,447 [main:106] - GETTING EmptyCoroutineContext from Char
2021-03-12 07:57:52,464 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 07:57:52,465 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 07:57:52,466 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 07:57:52,466 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 07:57:52,467 [main:106] - GETTING EmptyCoroutineContext from Function1<Int, Int>
2021-03-12 07:57:52,468 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 07:57:52,468 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 07:57:52,469 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 07:57:52,469 [main:106] - GETTING EmptyCoroutineContext from Byte
2021-03-12 07:57:52,499 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 07:57:52,500 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 07:57:52,501 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 07:57:52,501 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 07:57:52,502 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 07:57:52,502 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 07:57:52,503 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 07:57:52,503 [main:111] - Cant find and generate replacement for EmptyCoroutineContext type EmptyCoroutineContext
2021-03-12 07:57:52,503 [main:107] - replacing (s, String)
2021-03-12 07:57:52,503 [main:50] - replacing s String
2021-03-12 07:57:52,503 [main:54] - Getting value of type String
2021-03-12 07:57:52,711 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:57:52,719 [main:58] - GENERATED VALUE OF TYPE String = "vdhni"
2021-03-12 07:57:52,719 [main:61] - GENERATED IS CALL =false
2021-03-12 07:57:52,752 [main:67] - randomType = Kla6
2021-03-12 07:57:52,950 [main:302] - generating value of type = Kla6 false depth = 0
2021-03-12 07:57:52,958 [main:112] - generating klass Kla6 text = class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}
2021-03-12 07:57:52,966 [main:149] - GENERATING call of type public final suspend fun fu11(): kotlin.String defined in Kla6[SimpleFunctionDescriptorImpl@74dacae4]
2021-03-12 07:57:52,966 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.removeRange(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1091d790]
2021-03-12 07:57:52,967 [main:78] - Generated call from random type = (Kla6()).fu11().removeRange((f).next(), Kla3().prope6)
2021-03-12 07:57:52,967 [main:106] - GETTING String from Boolean
2021-03-12 07:57:52,978 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:57:52,978 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:57:53,202 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:57:53,210 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:57:53,404 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:57:53,413 [main:117] - GENERATED CALL = (Kla2().fu4()).compareTo(true).toString(-689615333)
2021-03-12 07:57:53,413 [main:114] - replacement of s of type String is (Kla2().fu4()).compareTo(true).toString(-689615333)
2021-03-12 07:57:53,609 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:57:53,609 [main:66] - Compilation checking started
2021-03-12 07:57:54,179 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().(Kla2().fu4()).compareTo(true).toString(-689615333)
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "FAIL 3"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:57:54,182 [main:107] - replacing ("FAIL 3", String)
2021-03-12 07:57:54,182 [main:50] - replacing "FAIL 3" String
2021-03-12 07:57:54,182 [main:54] - Getting value of type String
2021-03-12 07:57:54,382 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:57:54,390 [main:58] - GENERATED VALUE OF TYPE String = "scvwa"
2021-03-12 07:57:54,390 [main:61] - GENERATED IS CALL =false
2021-03-12 07:57:55,572 [main:67] - randomType = Function2<Boolean, List<Function2<Kla12, Kla7, UInt>>, Short?>
2021-03-12 07:57:55,573 [main:106] - GETTING String from Foo
2021-03-12 07:57:55,581 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:57:55,581 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338]
2021-03-12 07:57:55,582 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:57:55,582 [main:117] - GENERATED CALL = ((f)).next().toString(Foo(416482559, {a: Int -> 23}).state)
2021-03-12 07:57:55,582 [main:114] - replacement of "FAIL 3" of type String is "scvwa"
2021-03-12 07:57:55,781 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(STRING_TEMPLATE)
2021-03-12 07:57:55,782 [main:66] - Compilation checking started
2021-03-12 07:57:56,688 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:57:56,691 [main:107] - replacing ({}, Function0<Unit>)
2021-03-12 07:57:56,692 [main:50] - replacing {} Function0<Unit>
2021-03-12 07:57:56,692 [main:54] - Getting value of type Function0<Unit>
2021-03-12 07:57:56,896 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 07:57:56,904 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 07:57:57,116 [main:43] - GENERATING CALL OF fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-12 07:57:57,126 [main:61] - WITHOUT TYPE PARAMS = fun contract(builder: kotlin.contracts.ContractBuilder.()->kotlin.Unit): Unit = TODO()
2021-03-12 07:57:57,591 [main:302] - generating value of type = [@kotlin.ExtensionFunctionType] Function1<ContractBuilder, Unit> false depth = 4
2021-03-12 07:57:57,600 [main:302] - generating value of type = Unit false depth = 5
2021-03-12 07:57:57,811 [main:43] - GENERATING CALL OF fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 07:57:57,821 [main:61] - WITHOUT TYPE PARAMS = fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 07:57:58,274 [main:302] - generating value of type = Any false depth = 8
2021-03-12 07:57:58,274 [main:95] - GENERATED = print("vomsd")
2021-03-12 07:57:58,274 [main:95] - GENERATED = contract({ print("vomsd")})
2021-03-12 07:57:58,274 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { contract({ print("vomsd")})}
2021-03-12 07:57:58,275 [main:61] - GENERATED IS CALL =false
2021-03-12 07:57:59,518 [main:67] - randomType = Map<Function1<String, Kla9>, Triple<Char, Short, Function1<UShort, Short>>>
2021-03-12 07:57:59,520 [main:106] - GETTING Function0<Unit> from Kla0
2021-03-12 07:57:59,524 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:59,532 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:59,533 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:59,564 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:59,565 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:59,566 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:59,596 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:59,597 [main:106] - GETTING Function0<Unit> from UShort
2021-03-12 07:57:59,620 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:59,620 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:59,621 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:57:59,631 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:59,632 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:59,633 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:59,634 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:59,635 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:59,636 [main:106] - GETTING Function0<Unit> from UByte
2021-03-12 07:57:59,658 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:57:59,659 [main:106] - GETTING Function0<Unit> from Char
2021-03-12 07:57:59,676 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:59,677 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:59,678 [main:106] - GETTING Function0<Unit> from UByte
2021-03-12 07:57:59,679 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:59,680 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:59,681 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:59,682 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:59,683 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:59,684 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:59,685 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:59,686 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:59,687 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:59,688 [main:106] - GETTING Function0<Unit> from Kla2
2021-03-12 07:57:59,694 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:57:59,695 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:59,696 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:59,697 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:57:59,698 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:59,699 [main:106] - GETTING Function0<Unit> from Float
2021-03-12 07:57:59,727 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:59,728 [main:106] - GETTING Function0<Unit> from Kla0
2021-03-12 07:57:59,728 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:59,729 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:59,730 [main:106] - GETTING Function0<Unit> from Byte
2021-03-12 07:57:59,761 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:59,762 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:59,763 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:59,764 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:59,765 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:57:59,766 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:57:59,767 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:59,768 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:57:59,768 [main:114] - replacement of {} of type Function0<Unit> is { contract({ print("vomsd")})}
2021-03-12 07:57:59,961 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 07:57:59,962 [main:66] - Compilation checking started
2021-03-12 07:58:00,524 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = { contract({ print("vomsd")})}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:00,527 [main:107] - replacing ("Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got ", String)
2021-03-12 07:58:00,528 [main:50] - replacing "Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " String
2021-03-12 07:58:00,528 [main:54] - Getting value of type String
2021-03-12 07:58:00,727 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:58:00,740 [main:58] - GENERATED VALUE OF TYPE String = "xbnkb"
2021-03-12 07:58:00,741 [main:61] - GENERATED IS CALL =false
2021-03-12 07:58:00,781 [main:67] - randomType = Foo
2021-03-12 07:58:00,984 [main:302] - generating value of type = Foo false depth = 0
2021-03-12 07:58:00,993 [main:112] - generating klass Foo text = class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}
2021-03-12 07:58:01,187 [main:194] - Type params = []
2021-03-12 07:58:01,385 [main:302] - generating value of type = Int true depth = 2
2021-03-12 07:58:01,393 [main:302] - generating value of type = Function1<Int, Int> false depth = 2
2021-03-12 07:58:01,402 [main:302] - generating value of type = Int true depth = 3
2021-03-12 07:58:01,417 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@324fc569]
2021-03-12 07:58:01,418 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:58:01,613 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:58:01,622 [main:78] - Generated call from random type = (Foo(-926850363, {a: Int -> 1661994320})).next().toString(-1273651275)
2021-03-12 07:58:01,623 [main:106] - GETTING String from Function1<Int, Int>
2021-03-12 07:58:01,632 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@6766b81], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:58:01,632 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@6766b81]
2021-03-12 07:58:01,632 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:58:01,827 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:58:01,835 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).invoke((Foo(655341081, {a: Int -> -655341081}).next())).toString(1251100754)
2021-03-12 07:58:01,835 [main:114] - replacement of "Wrong state-machine generated: suspendHere should be called exactly once in one state. Expected " + i + ", got " of type String is "xbnkb"
2021-03-12 07:58:02,029 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 07:58:02,030 [main:66] - Compilation checking started
2021-03-12 07:58:02,942 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:02,945 [main:107] - replacing (exceptionOrNull(), Throwable?)
2021-03-12 07:58:02,946 [main:50] - replacing exceptionOrNull() Throwable?
2021-03-12 07:58:02,946 [main:54] - Getting value of type Throwable?
2021-03-12 07:58:03,148 [main:302] - generating value of type = Throwable false depth = 0
2021-03-12 07:58:03,355 [main:43] - GENERATING CALL OF fun IllegalStateException(message: kotlin.String?): Throwable = TODO()
2021-03-12 07:58:03,365 [main:61] - WITHOUT TYPE PARAMS = fun IllegalStateException(message: kotlin.String?): Throwable = TODO()
2021-03-12 07:58:03,826 [main:302] - generating value of type = String true depth = 3
2021-03-12 07:58:03,835 [main:95] - GENERATED = IllegalStateException("rxqgt")
2021-03-12 07:58:03,835 [main:58] - GENERATED VALUE OF TYPE Throwable? = IllegalStateException("rxqgt")
2021-03-12 07:58:03,835 [main:61] - GENERATED IS CALL =true
2021-03-12 07:58:03,852 [main:67] - randomType = UInt
2021-03-12 07:58:04,049 [main:302] - generating value of type = UInt true depth = 0
2021-03-12 07:58:04,084 [main:106] - GETTING Throwable? from Boolean
2021-03-12 07:58:04,092 [main:106] - GETTING Throwable? from Boolean
2021-03-12 07:58:04,092 [main:106] - GETTING Throwable? from Function1<Int, Int>
2021-03-12 07:58:04,102 [main:106] - GETTING Throwable? from UShort
2021-03-12 07:58:04,123 [main:106] - GETTING Throwable? from UByte
2021-03-12 07:58:04,144 [main:106] - GETTING Throwable? from Int
2021-03-12 07:58:04,172 [main:106] - GETTING Throwable? from Boolean
2021-03-12 07:58:04,173 [main:106] - GETTING Throwable? from Boolean
2021-03-12 07:58:04,174 [main:106] - GETTING Throwable? from Boolean
2021-03-12 07:58:04,174 [main:106] - GETTING Throwable? from Int
2021-03-12 07:58:04,175 [main:106] - GETTING Throwable? from Foo
2021-03-12 07:58:04,183 [main:106] - GETTING Throwable? from Foo
2021-03-12 07:58:04,183 [main:106] - GETTING Throwable? from Float
2021-03-12 07:58:04,211 [main:106] - GETTING Throwable? from Foo
2021-03-12 07:58:04,212 [main:106] - GETTING Throwable? from Int
2021-03-12 07:58:04,212 [main:106] - GETTING Throwable? from Boolean
2021-03-12 07:58:04,213 [main:106] - GETTING Throwable? from Boolean
2021-03-12 07:58:04,213 [main:106] - GETTING Throwable? from Boolean
2021-03-12 07:58:04,214 [main:106] - GETTING Throwable? from Boolean
2021-03-12 07:58:04,215 [main:106] - GETTING Throwable? from Boolean
2021-03-12 07:58:04,215 [main:106] - GETTING Throwable? from Int
2021-03-12 07:58:04,216 [main:106] - GETTING Throwable? from Foo
2021-03-12 07:58:04,217 [main:106] - GETTING Throwable? from Boolean
2021-03-12 07:58:04,217 [main:106] - GETTING Throwable? from Foo
2021-03-12 07:58:04,218 [main:106] - GETTING Throwable? from Boolean
2021-03-12 07:58:04,219 [main:106] - GETTING Throwable? from Foo
2021-03-12 07:58:04,219 [main:106] - GETTING Throwable? from Kla0
2021-03-12 07:58:04,223 [main:106] - GETTING Throwable? from Foo
2021-03-12 07:58:04,224 [main:106] - GETTING Throwable? from Byte
2021-03-12 07:58:04,253 [main:106] - GETTING Throwable? from Foo
2021-03-12 07:58:04,253 [main:106] - GETTING Throwable? from Function1<Int, Int>
2021-03-12 07:58:04,254 [main:106] - GETTING Throwable? from Boolean
2021-03-12 07:58:04,255 [main:106] - GETTING Throwable? from Boolean
2021-03-12 07:58:04,255 [main:106] - GETTING Throwable? from Function1<Int, Int>
2021-03-12 07:58:04,256 [main:106] - GETTING Throwable? from Kla2
2021-03-12 07:58:04,262 [main:106] - GETTING Throwable? from Kla0
2021-03-12 07:58:04,262 [main:106] - GETTING Throwable? from Function1<Int, Int>
2021-03-12 07:58:04,263 [main:106] - GETTING Throwable? from Int
2021-03-12 07:58:04,264 [main:106] - GETTING Throwable? from Int
2021-03-12 07:58:04,264 [main:106] - GETTING Throwable? from Int
2021-03-12 07:58:04,265 [main:106] - GETTING Throwable? from Int
2021-03-12 07:58:04,266 [main:106] - GETTING Throwable? from Int
2021-03-12 07:58:04,266 [main:106] - GETTING Throwable? from Int
2021-03-12 07:58:04,267 [main:106] - GETTING Throwable? from Foo
2021-03-12 07:58:04,267 [main:106] - GETTING Throwable? from Int
2021-03-12 07:58:04,268 [main:106] - GETTING Throwable? from Char
2021-03-12 07:58:04,286 [main:106] - GETTING Throwable? from Boolean
2021-03-12 07:58:04,286 [main:106] - GETTING Throwable? from Foo
2021-03-12 07:58:04,287 [main:106] - GETTING Throwable? from Int
2021-03-12 07:58:04,288 [main:106] - GETTING Throwable? from Int
2021-03-12 07:58:04,288 [main:106] - GETTING Throwable? from UByte
2021-03-12 07:58:04,289 [main:106] - GETTING Throwable? from Foo
2021-03-12 07:58:04,289 [main:114] - replacement of exceptionOrNull() of type Throwable? is IllegalStateException("rxqgt")
2021-03-12 07:58:04,484 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:58:04,484 [main:66] - Compilation checking started
2021-03-12 07:58:05,048 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope11.isSuccess) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.IllegalStateException("rxqgt")!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:05,051 [main:107] - replacing (prope11.isSuccess, Boolean)
2021-03-12 07:58:05,051 [main:50] - replacing prope11.isSuccess Boolean
2021-03-12 07:58:05,051 [main:54] - Getting value of type Boolean
2021-03-12 07:58:05,250 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:58:05,258 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:58:05,259 [main:61] - GENERATED IS CALL =false
2021-03-12 07:58:05,506 [main:67] - randomType = ULong
2021-03-12 07:58:05,729 [main:302] - generating value of type = ULong true depth = 0
2021-03-12 07:58:05,763 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toDouble(): kotlin.Double defined in kotlin.ULong[DeserializedSimpleFunctionDescriptor@1b8ef26f]
2021-03-12 07:58:05,763 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]
2021-03-12 07:58:05,763 [main:78] - Generated call from random type = (2756467179684034162.toULong()).toDouble().isInfinite()
2021-03-12 07:58:05,764 [main:106] - GETTING Boolean from Byte
2021-03-12 07:58:05,792 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2b2220c], public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7dece268]]
2021-03-12 07:58:05,792 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2b2220c]
2021-03-12 07:58:05,792 [main:149] - GENERATING call of type public fun kotlin.Char.isLetterOrDigit(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7dece268]
2021-03-12 07:58:05,792 [main:117] - GENERATED CALL = ((Foo(416482559, {a: Int -> 23}).state).toByte()).toChar().isLetterOrDigit()
2021-03-12 07:58:05,792 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2b2220c], public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@9f659]]
2021-03-12 07:58:05,793 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2b2220c]
2021-03-12 07:58:05,793 [main:149] - GENERATING call of type public fun kotlin.Char.isDefined(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@9f659]
2021-03-12 07:58:05,793 [main:117] - GENERATED CALL = ((Foo(416482559, {a: Int -> 23}).state).toByte()).toChar().isDefined()
2021-03-12 07:58:05,793 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:58:05,793 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:58:05,793 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:58:05,991 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:58:05,991 [main:117] - GENERATED CALL = ((Foo(416482559, {a: Int -> 23}).state).toByte()).toInt().equals("iylug")
2021-03-12 07:58:05,991 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2b2220c], public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@53d33965]]
2021-03-12 07:58:05,991 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2b2220c]
2021-03-12 07:58:05,991 [main:149] - GENERATING call of type public fun kotlin.Char.isWhitespace(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@53d33965]
2021-03-12 07:58:05,992 [main:117] - GENERATED CALL = ((Foo(416482559, {a: Int -> 23}).state).toByte()).toChar().isWhitespace()
2021-03-12 07:58:05,992 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2b2220c], public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@39e29b5e]]
2021-03-12 07:58:05,992 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2b2220c]
2021-03-12 07:58:05,992 [main:149] - GENERATING call of type public fun kotlin.Char.isISOControl(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@39e29b5e]
2021-03-12 07:58:05,992 [main:117] - GENERATED CALL = ((Foo(416482559, {a: Int -> 23}).state).toByte()).toChar().isISOControl()
2021-03-12 07:58:05,992 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2b2220c], public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3bbcbd00]]
2021-03-12 07:58:05,992 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2b2220c]
2021-03-12 07:58:05,992 [main:149] - GENERATING call of type public fun kotlin.Char.equals(other: kotlin.Char, ignoreCase: kotlin.Boolean = ...): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3bbcbd00]
2021-03-12 07:58:05,993 [main:117] - GENERATED CALL = ((Foo(416482559, {a: Int -> 23}).state).toByte()).toChar().equals((f.next()).toChar(), Kla1().fu4())
2021-03-12 07:58:05,993 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2c045eae], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]]
2021-03-12 07:58:05,993 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2c045eae]
2021-03-12 07:58:06,189 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:58:06,198 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]
2021-03-12 07:58:06,198 [main:117] - GENERATED CALL = ((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()
2021-03-12 07:58:06,198 [main:113] - Case = [public abstract fun toByte(): kotlin.Byte defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@3d4fc9f5], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2c57ad81]]
2021-03-12 07:58:06,198 [main:149] - GENERATING call of type public abstract fun toByte(): kotlin.Byte defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@3d4fc9f5]
2021-03-12 07:58:06,198 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2c57ad81]
2021-03-12 07:58:06,393 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:58:06,393 [main:117] - GENERATED CALL = ((Foo(416482559, {a: Int -> 23}).state).toByte()).toByte().equals("qiemj")
2021-03-12 07:58:06,393 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2c57ad81], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:58:06,393 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2c57ad81]
2021-03-12 07:58:06,589 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:58:06,590 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:58:06,785 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:58:06,794 [main:117] - GENERATED CALL = ((Foo(416482559, {a: Int -> 23}).state).toByte()).equals("knkqz").xor(false)
2021-03-12 07:58:06,794 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2c045eae], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@34594779]]
2021-03-12 07:58:06,794 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@2c045eae]
2021-03-12 07:58:06,992 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:58:07,000 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@34594779]
2021-03-12 07:58:07,197 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:58:07,198 [main:117] - GENERATED CALL = ((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.16061297456726087).equals("eawlc")
2021-03-12 07:58:07,198 [main:114] - replacement of prope11.isSuccess of type Boolean is ((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()
2021-03-12 07:58:07,392 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:58:07,392 [main:66] - Compilation checking started
2021-03-12 07:58:08,283 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + prope13)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:08,286 [main:107] - replacing (prope13, Int)
2021-03-12 07:58:08,287 [main:50] - replacing prope13 Int
2021-03-12 07:58:08,287 [main:54] - Getting value of type Int
2021-03-12 07:58:08,493 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:58:08,502 [main:58] - GENERATED VALUE OF TYPE Int = -807117176
2021-03-12 07:58:08,502 [main:61] - GENERATED IS CALL =false
2021-03-12 07:58:08,536 [main:67] - randomType = Kla4
2021-03-12 07:58:08,736 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 07:58:08,745 [main:112] - generating klass Kla4 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)
2021-03-12 07:58:08,945 [main:194] - Type params = []
2021-03-12 07:58:09,165 [main:302] - generating value of type = String true depth = 2
2021-03-12 07:58:09,178 [main:78] - Generated call from random type = (Kla4("qcyax")).s.length
2021-03-12 07:58:09,178 [main:114] - replacement of prope13 of type Int is (Kla4("qcyax")).s.length
2021-03-12 07:58:09,375 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:58:09,375 [main:66] - Compilation checking started
2021-03-12 07:58:10,297 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if (checkFinished && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:10,300 [main:107] - replacing (checkFinished, Boolean)
2021-03-12 07:58:10,300 [main:50] - replacing checkFinished Boolean
2021-03-12 07:58:10,300 [main:54] - Getting value of type Boolean
2021-03-12 07:58:10,503 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:58:10,512 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:58:10,512 [main:61] - GENERATED IS CALL =false
2021-03-12 07:58:10,546 [main:67] - randomType = Kla2
2021-03-12 07:58:10,743 [main:302] - generating value of type = Kla2 false depth = 0
2021-03-12 07:58:10,751 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 07:58:10,758 [main:149] - GENERATING call of type public open fun fu4(): kotlin.Boolean defined in Kla2[SimpleFunctionDescriptorImpl@7799a0e5]
2021-03-12 07:58:10,758 [main:78] - Generated call from random type = (Kla2()).fu4()
2021-03-12 07:58:10,758 [main:106] - GETTING Boolean from Boolean
2021-03-12 07:58:10,765 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:58:10,765 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 07:58:10,963 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:58:10,963 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:58:10,963 [main:117] - GENERATED CALL = (Kla2().fu2()).equals("lozfq").or(prope1.fu4())
2021-03-12 07:58:10,963 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:58:10,963 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:58:11,162 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:58:11,162 [main:117] - GENERATED CALL = (Kla2().fu2()).equals("iqzkb")
2021-03-12 07:58:11,163 [main:113] - Case = [public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:58:11,163 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:58:11,163 [main:117] - GENERATED CALL = (Kla2().fu2()).and(Kla1().fu4())
2021-03-12 07:58:11,163 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:58:11,163 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 07:58:11,359 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:58:11,360 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:58:11,557 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:58:11,557 [main:117] - GENERATED CALL = (Kla2().fu2()).equals("vrmfu").equals("xfuyd")
2021-03-12 07:58:11,557 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:58:11,557 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:58:11,557 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:58:11,755 [main:117] - GENERATED CALL = (Kla2().fu2()).compareTo(Kla2().fu1()).equals(null)
2021-03-12 07:58:11,755 [main:113] - Case = [public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:58:11,755 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:58:11,951 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:58:11,960 [main:117] - GENERATED CALL = (Kla2().fu2()).or(true)
2021-03-12 07:58:11,960 [main:113] - Case = [public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:58:11,960 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:58:12,157 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:58:12,166 [main:117] - GENERATED CALL = (Kla2().fu2()).xor(true)
2021-03-12 07:58:12,166 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:58:12,166 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 07:58:12,383 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:58:12,383 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:58:12,384 [main:117] - GENERATED CALL = (Kla2().fu2()).equals("xmaug").and(Kla1().fu4())
2021-03-12 07:58:12,384 [main:113] - Case = [public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:58:12,384 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:58:12,384 [main:117] - GENERATED CALL = (Kla2().fu2()).not()
2021-03-12 07:58:12,384 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:58:12,384 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 07:58:12,582 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:58:12,582 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:58:12,582 [main:117] - GENERATED CALL = (Kla2().fu2()).equals("dlidy").xor(Kla2().fu2())
2021-03-12 07:58:12,582 [main:114] - replacement of checkFinished of type Boolean is (Kla2().fu2()).equals("xmaug").and(Kla1().fu4())
2021-03-12 07:58:12,783 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:58:12,784 [main:66] - Compilation checking started
2021-03-12 07:58:13,686 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:13,689 [main:107] - replacing ("FAIL 2 $prope11", String)
2021-03-12 07:58:13,689 [main:50] - replacing "FAIL 2 $prope11" String
2021-03-12 07:58:13,689 [main:54] - Getting value of type String
2021-03-12 07:58:13,887 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:58:13,896 [main:58] - GENERATED VALUE OF TYPE String = "vfdoy"
2021-03-12 07:58:13,896 [main:61] - GENERATED IS CALL =false
2021-03-12 07:58:13,929 [main:67] - randomType = Kla4
2021-03-12 07:58:14,126 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 07:58:14,135 [main:112] - generating klass Kla4 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)
2021-03-12 07:58:14,331 [main:194] - Type params = []
2021-03-12 07:58:14,526 [main:302] - generating value of type = String true depth = 2
2021-03-12 07:58:14,539 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline fun kotlin.String.concat(str: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@233eb34c]
2021-03-12 07:58:14,750 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:58:14,758 [main:78] - Generated call from random type = (Kla4("xgusr")).s.concat("nzwae")
2021-03-12 07:58:14,758 [main:114] - replacement of "FAIL 2 $prope11" of type String is (Kla4("xgusr")).s.concat("nzwae")
2021-03-12 07:58:14,955 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:58:14,955 [main:66] - Compilation checking started
2021-03-12 07:58:15,518 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return (Kla4("xgusr")).s.concat("nzwae")

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4("OK"))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:15,521 [main:107] - replacing ("OK", String)
2021-03-12 07:58:15,521 [main:50] - replacing "OK" String
2021-03-12 07:58:15,521 [main:54] - Getting value of type String
2021-03-12 07:58:15,739 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:58:15,747 [main:58] - GENERATED VALUE OF TYPE String = "ipcxf"
2021-03-12 07:58:15,747 [main:61] - GENERATED IS CALL =false
2021-03-12 07:58:15,765 [main:67] - randomType = Char
2021-03-12 07:58:15,961 [main:302] - generating value of type = Char true depth = 0
2021-03-12 07:58:15,988 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@57514114]
2021-03-12 07:58:15,988 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:58:16,187 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:58:16,196 [main:78] - Generated call from random type = ('').compareTo((f.next()).toChar()).toString(1002407261)
2021-03-12 07:58:16,197 [main:106] - GETTING String from Int
2021-03-12 07:58:16,226 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:58:16,226 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:58:16,226 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:58:16,226 [main:117] - GENERATED CALL = ((f).next()).toLong().toString(Foo(1397637829, {a: Int -> -710498597}).state)
2021-03-12 07:58:16,226 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 07:58:16,226 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:58:16,226 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 07:58:16,426 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:58:16,435 [main:117] - GENERATED CALL = ((f).next()).toChar().plus("wgcyf")
2021-03-12 07:58:16,435 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:58:16,435 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:58:16,435 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:58:16,631 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:58:16,639 [main:117] - GENERATED CALL = ((f).next()).compareTo(Foo(416482559, {a: Int -> 23}).state).toString(-962228742)
2021-03-12 07:58:16,640 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 07:58:16,640 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:58:16,640 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 07:58:16,640 [main:117] - GENERATED CALL = ((f).next()).toChar().lowercase()
2021-03-12 07:58:16,640 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 07:58:16,640 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:58:16,640 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:58:16,640 [main:117] - GENERATED CALL = ((f).next()).toShort().toString(Kla3().prope6)
2021-03-12 07:58:16,640 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:58:16,640 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 07:58:16,838 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:58:16,846 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:58:16,847 [main:117] - GENERATED CALL = ((f).next()).div(5076096487516889982).toString(Foo(1397637829, {a: Int -> -710498597}).next())
2021-03-12 07:58:16,847 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 07:58:16,847 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:58:16,847 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 07:58:16,847 [main:117] - GENERATED CALL = ((f).next()).toChar().titlecase()
2021-03-12 07:58:16,847 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]]
2021-03-12 07:58:16,847 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:58:16,847 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]
2021-03-12 07:58:16,847 [main:117] - GENERATED CALL = ((f).next()).toChar().uppercase()
2021-03-12 07:58:16,847 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:58:16,847 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:58:16,847 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:58:16,847 [main:117] - GENERATED CALL = ((f).next()).toByte().toString((f).next())
2021-03-12 07:58:16,848 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:58:16,848 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:58:16,848 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:58:17,047 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:58:17,055 [main:117] - GENERATED CALL = ((f).next()).toInt().toString(1992471937)
2021-03-12 07:58:17,055 [main:114] - replacement of "OK" of type String is ((f).next()).toChar().plus("wgcyf")
2021-03-12 07:58:17,250 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:58:17,251 [main:66] - Compilation checking started
2021-03-12 07:58:18,185 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:18,188 [main:107] - replacing (fu6<String>(), String)
2021-03-12 07:58:18,188 [main:50] - replacing fu6<String>() String
2021-03-12 07:58:18,188 [main:54] - Getting value of type String
2021-03-12 07:58:18,387 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:58:18,395 [main:58] - GENERATED VALUE OF TYPE String = "tiile"
2021-03-12 07:58:18,396 [main:61] - GENERATED IS CALL =false
2021-03-12 07:58:18,430 [main:67] - randomType = Kla6
2021-03-12 07:58:18,644 [main:302] - generating value of type = Kla6 false depth = 0
2021-03-12 07:58:18,652 [main:112] - generating klass Kla6 text = class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = fu6<String>()

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}
2021-03-12 07:58:18,658 [main:149] - GENERATING call of type public final suspend fun fu11(): kotlin.String defined in Kla6[SimpleFunctionDescriptorImpl@6862be1a]
2021-03-12 07:58:18,658 [main:149] - GENERATING call of type public fun kotlin.String.drop(n: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7d2f837f]
2021-03-12 07:58:18,864 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:58:18,873 [main:78] - Generated call from random type = (Kla6()).fu11().drop(1591122681)
2021-03-12 07:58:18,874 [main:106] - GETTING String from Foo
2021-03-12 07:58:18,883 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:58:18,883 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338]
2021-03-12 07:58:18,883 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:58:19,105 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:58:19,114 [main:117] - GENERATED CALL = (Foo(416482559, {a: Int -> -655341081})).next().toString(453805245)
2021-03-12 07:58:19,114 [main:114] - replacement of fu6<String>() of type String is (Kla6()).fu11().drop(1591122681)
2021-03-12 07:58:19,311 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:58:19,312 [main:66] - Compilation checking started
2021-03-12 07:58:20,213 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        return fu9(fu10(fu11()))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:20,216 [main:107] - replacing (fu11(), String)
2021-03-12 07:58:20,217 [main:50] - replacing fu11() String
2021-03-12 07:58:20,217 [main:54] - Getting value of type String
2021-03-12 07:58:20,430 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:58:20,439 [main:58] - GENERATED VALUE OF TYPE String = "mcdyo"
2021-03-12 07:58:20,439 [main:61] - GENERATED IS CALL =false
2021-03-12 07:58:20,457 [main:67] - randomType = Short
2021-03-12 07:58:20,659 [main:302] - generating value of type = Short true depth = 0
2021-03-12 07:58:20,698 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:58:20,698 [main:78] - Generated call from random type = (-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())
2021-03-12 07:58:20,698 [main:114] - replacement of fu11() of type String is (-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())
2021-03-12 07:58:20,898 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:58:20,899 [main:66] - Compilation checking started
2021-03-12 07:58:21,786 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:21,790 [main:107] - replacing ("UNCHECKED_CAST", String)
2021-03-12 07:58:21,790 [main:50] - replacing "UNCHECKED_CAST" String
2021-03-12 07:58:21,790 [main:54] - Getting value of type String
2021-03-12 07:58:21,998 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:58:22,006 [main:58] - GENERATED VALUE OF TYPE String = "bgcqp"
2021-03-12 07:58:22,006 [main:61] - GENERATED IS CALL =false
2021-03-12 07:58:22,295 [main:67] - randomType = Kla1?
2021-03-12 07:58:22,519 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 07:58:22,528 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}
2021-03-12 07:58:22,535 [main:106] - GETTING String from Int
2021-03-12 07:58:22,563 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:58:22,563 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:58:22,563 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:58:22,563 [main:117] - GENERATED CALL = ((f.next())).toInt().toString((Foo(655341081, {a: Int -> -655341081}).next()))
2021-03-12 07:58:22,563 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 07:58:22,564 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:58:22,564 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 07:58:22,767 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:58:22,776 [main:117] - GENERATED CALL = ((f.next())).toChar().plus("hhfdh")
2021-03-12 07:58:22,776 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:58:22,776 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:58:22,776 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:58:22,777 [main:117] - GENERATED CALL = ((f.next())).toLong().toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())))
2021-03-12 07:58:22,777 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:58:22,777 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:58:22,777 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:58:22,777 [main:117] - GENERATED CALL = ((f.next())).compareTo(Foo(1397637829, {a: Int -> -710498597}).next()).toString(Foo(416482559, {a: Int -> 23}).state)
2021-03-12 07:58:22,777 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 07:58:22,777 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:58:22,777 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 07:58:22,778 [main:117] - GENERATED CALL = ((f.next())).toChar().titlecase()
2021-03-12 07:58:22,778 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 07:58:22,778 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:58:22,778 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 07:58:22,778 [main:117] - GENERATED CALL = ((f.next())).toChar().lowercase()
2021-03-12 07:58:22,778 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:58:22,778 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 07:58:22,981 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:58:22,990 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:58:22,991 [main:117] - GENERATED CALL = ((f.next())).div(-7233282041830680021).toString(Foo(1397637829, {a: Int -> -710498597}).next())
2021-03-12 07:58:22,991 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 07:58:22,991 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:58:22,991 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:58:22,991 [main:117] - GENERATED CALL = ((f.next())).toShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:58:22,991 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:58:22,991 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:58:22,991 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:58:22,991 [main:117] - GENERATED CALL = ((f.next())).toByte().toString((f.next()))
2021-03-12 07:58:22,991 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]]
2021-03-12 07:58:22,991 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:58:22,992 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]
2021-03-12 07:58:22,992 [main:117] - GENERATED CALL = ((f.next())).toChar().uppercase()
2021-03-12 07:58:22,992 [main:114] - replacement of "UNCHECKED_CAST" of type String is ((f.next())).toChar().lowercase()
2021-03-12 07:58:23,198 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:58:23,198 [main:66] - Compilation checking started
2021-03-12 07:58:23,784 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress(((f.next())).toChar().lowercase())
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { prope8.resume(Unit) }
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:23,788 [main:107] - replacing (t, Ty0)
2021-03-12 07:58:23,788 [main:50] - replacing t Ty0
2021-03-12 07:58:23,788 [main:54] - Getting value of type Ty0
2021-03-12 07:58:23,993 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 07:58:24,004 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 07:58:26,144 [main:67] - randomType = Function1<Map<Triple<Foo, Kla6, UByte>, ULong?>?, Map<Int, Kla6>>
2021-03-12 07:58:26,145 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:26,174 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:58:26,183 [main:106] - GETTING Ty0 from Kla0
2021-03-12 07:58:26,186 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:26,194 [main:106] - GETTING Ty0 from Kla2
2021-03-12 07:58:26,199 [main:106] - GETTING Ty0 from UByte
2021-03-12 07:58:26,220 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:26,221 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:26,228 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:26,229 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:26,230 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:26,230 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:58:26,231 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:26,231 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:26,232 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:26,232 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:26,233 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:26,234 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:26,234 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:26,235 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:26,235 [main:106] - GETTING Ty0 from Char
2021-03-12 07:58:26,253 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:26,253 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:26,254 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:26,255 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:26,255 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:26,256 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:26,256 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:26,257 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:26,258 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:26,258 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:26,259 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:26,259 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:26,260 [main:106] - GETTING Ty0 from Kla0
2021-03-12 07:58:26,260 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:26,261 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:26,262 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:26,262 [main:106] - GETTING Ty0 from Float
2021-03-12 07:58:26,291 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:26,292 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:26,293 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:26,293 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:26,294 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:26,294 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:26,295 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:58:26,296 [main:106] - GETTING Ty0 from Byte
2021-03-12 07:58:26,327 [main:106] - GETTING Ty0 from UShort
2021-03-12 07:58:26,348 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:58:26,349 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:26,349 [main:106] - GETTING Ty0 from UByte
2021-03-12 07:58:26,350 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:26,350 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:26,350 [main:111] - Cant find and generate replacement for t type Ty0
2021-03-12 07:58:26,350 [main:107] - replacing (value, Ty0)
2021-03-12 07:58:26,351 [main:50] - replacing value Ty0
2021-03-12 07:58:26,351 [main:54] - Getting value of type Ty0
2021-03-12 07:58:26,553 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 07:58:26,565 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 07:58:26,839 [main:67] - randomType = Byte?
2021-03-12 07:58:27,041 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:58:27,083 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:27,090 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:27,091 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:27,119 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:27,120 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:27,128 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:27,128 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:27,129 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:27,130 [main:106] - GETTING Ty0 from Byte
2021-03-12 07:58:27,158 [main:106] - GETTING Ty0 from Kla2
2021-03-12 07:58:27,163 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:27,164 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:27,165 [main:106] - GETTING Ty0 from Kla0
2021-03-12 07:58:27,168 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:27,168 [main:106] - GETTING Ty0 from UByte
2021-03-12 07:58:27,189 [main:106] - GETTING Ty0 from UShort
2021-03-12 07:58:27,210 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:27,211 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:27,211 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:27,212 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:27,213 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:27,213 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:27,214 [main:106] - GETTING Ty0 from Float
2021-03-12 07:58:27,241 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:27,241 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:27,242 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:27,243 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:27,243 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:58:27,252 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:27,253 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:27,254 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:58:27,254 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:27,255 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:27,255 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:27,256 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:27,257 [main:106] - GETTING Ty0 from UByte
2021-03-12 07:58:27,257 [main:106] - GETTING Ty0 from Kla0
2021-03-12 07:58:27,258 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:27,258 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:27,259 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:27,259 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:58:27,260 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:27,261 [main:106] - GETTING Ty0 from Char
2021-03-12 07:58:27,278 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:27,279 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:27,279 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:27,280 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:27,280 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:58:27,281 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:27,282 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:27,282 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:27,283 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:27,283 [main:111] - Cant find and generate replacement for value type Ty0
2021-03-12 07:58:27,283 [main:107] - replacing ({ prope8.resume(Unit) }, Function0<Unit>)
2021-03-12 07:58:27,283 [main:50] - replacing { prope8.resume(Unit) } Function0<Unit>
2021-03-12 07:58:27,283 [main:54] - Getting value of type Function0<Unit>
2021-03-12 07:58:27,484 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 07:58:27,493 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 07:58:27,707 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 07:58:27,718 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 07:58:28,190 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 07:58:28,199 [main:95] - GENERATED = require(false)
2021-03-12 07:58:28,199 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { require(false)}
2021-03-12 07:58:28,199 [main:61] - GENERATED IS CALL =false
2021-03-12 07:58:28,233 [main:67] - randomType = Kla1
2021-03-12 07:58:28,455 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 07:58:28,464 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}
2021-03-12 07:58:28,470 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:58:28,479 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:58:28,480 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:58:28,481 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:58:28,489 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:58:28,498 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:58:28,499 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:58:28,500 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:58:28,501 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:58:28,502 [main:106] - GETTING Function0<Unit> from Float
2021-03-12 07:58:28,530 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:58:28,531 [main:106] - GETTING Function0<Unit> from UByte
2021-03-12 07:58:28,552 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:58:28,582 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:58:28,583 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:58:28,584 [main:106] - GETTING Function0<Unit> from Byte
2021-03-12 07:58:28,614 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:58:28,615 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:58:28,616 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:58:28,617 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:58:28,618 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:58:28,619 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:58:28,620 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:58:28,621 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:58:28,622 [main:106] - GETTING Function0<Unit> from Kla0
2021-03-12 07:58:28,626 [main:106] - GETTING Function0<Unit> from Char
2021-03-12 07:58:28,643 [main:106] - GETTING Function0<Unit> from UShort
2021-03-12 07:58:28,665 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:58:28,666 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:58:28,667 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:58:28,668 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:58:28,668 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:58:28,669 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:58:28,670 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:58:28,671 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:58:28,672 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:58:28,673 [main:106] - GETTING Function0<Unit> from UByte
2021-03-12 07:58:28,674 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:58:28,675 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:58:28,676 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:58:28,677 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:58:28,678 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:58:28,679 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:58:28,680 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:58:28,682 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:58:28,684 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:58:28,685 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:58:28,687 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:58:28,689 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:58:28,690 [main:106] - GETTING Function0<Unit> from Kla0
2021-03-12 07:58:28,692 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:58:28,694 [main:106] - GETTING Function0<Unit> from Kla2
2021-03-12 07:58:28,699 [main:114] - replacement of { prope8.resume(Unit) } of type Function0<Unit> is { require(false)}
2021-03-12 07:58:28,905 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 07:58:28,906 [main:66] - Compilation checking started
2021-03-12 07:58:29,787 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {
        fu16(it)
    }

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:29,790 [main:107] - replacing (prope8, Continuation<*>)
2021-03-12 07:58:29,790 [main:50] - replacing prope8 Continuation<*>
2021-03-12 07:58:29,790 [main:54] - Getting value of type Continuation<*>
2021-03-12 07:58:29,993 [main:302] - generating value of type = Continuation<*> false depth = 0
2021-03-12 07:58:30,207 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 07:58:30,218 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 07:58:30,987 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 07:58:31,201 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:58:31,212 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:58:31,743 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 07:58:31,966 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:58:31,977 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:58:32,754 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:58:32,754 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:58:32,754 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any?>)->kotlin.Unit): Contuation<*> = TODO()
2021-03-12 07:58:32,754 [main:58] - GENERATED VALUE OF TYPE Continuation<*> = 
2021-03-12 07:58:32,772 [main:67] - randomType = UInt
2021-03-12 07:58:32,980 [main:302] - generating value of type = UInt true depth = 0
2021-03-12 07:58:33,016 [main:106] - GETTING Continuation<*> from UByte
2021-03-12 07:58:33,038 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:58:33,046 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:58:33,055 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:58:33,086 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:58:33,087 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:58:33,088 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:58:33,095 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:58:33,096 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:58:33,097 [main:106] - GETTING Continuation<*> from Byte
2021-03-12 07:58:33,127 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:58:33,128 [main:106] - GETTING Continuation<*> from Kla2
2021-03-12 07:58:33,134 [main:106] - GETTING Continuation<*> from Float
2021-03-12 07:58:33,160 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:58:33,161 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:58:33,162 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:58:33,163 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:58:33,164 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:58:33,165 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:58:33,166 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:58:33,166 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:58:33,167 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:58:33,168 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:58:33,169 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:58:33,170 [main:106] - GETTING Continuation<*> from UByte
2021-03-12 07:58:33,171 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:58:33,171 [main:106] - GETTING Continuation<*> from Kla0
2021-03-12 07:58:33,176 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:58:33,176 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:58:33,177 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:58:33,178 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:58:33,179 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:58:33,180 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:58:33,181 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:58:33,181 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:58:33,182 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:58:33,183 [main:106] - GETTING Continuation<*> from Char
2021-03-12 07:58:33,201 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:58:33,202 [main:106] - GETTING Continuation<*> from UShort
2021-03-12 07:58:33,224 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:58:33,224 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:58:33,226 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:58:33,226 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:58:33,227 [main:106] - GETTING Continuation<*> from Kla0
2021-03-12 07:58:33,228 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:58:33,229 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:58:33,230 [main:106] - GETTING Continuation<*> from Function1<Int, Int>
2021-03-12 07:58:33,231 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:58:33,231 [main:106] - GETTING Continuation<*> from Boolean
2021-03-12 07:58:33,232 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:58:33,233 [main:106] - GETTING Continuation<*> from Foo
2021-03-12 07:58:33,234 [main:106] - GETTING Continuation<*> from Int
2021-03-12 07:58:33,234 [main:111] - Cant find and generate replacement for prope8 type Continuation<*>
2021-03-12 07:58:33,234 [main:107] - replacing ({
        fu16(it)
    }, Function1<Continuation<Unit>, Unit>)
2021-03-12 07:58:33,234 [main:50] - replacing {
        fu16(it)
    } Function1<Continuation<Unit>, Unit>
2021-03-12 07:58:33,234 [main:54] - Getting value of type Function1<Continuation<Unit>, Unit>
2021-03-12 07:58:33,437 [main:302] - generating value of type = Function1<Continuation<Unit>, Unit> false depth = 0
2021-03-12 07:58:33,446 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 07:58:33,661 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 07:58:33,671 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 07:58:34,439 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 07:58:34,448 [main:302] - generating value of type = Function0<Any> false depth = 4
2021-03-12 07:58:34,457 [main:302] - generating value of type = Any false depth = 5
2021-03-12 07:58:34,457 [main:95] - GENERATED = check(false, { "iqgeu"})
2021-03-12 07:58:34,457 [main:58] - GENERATED VALUE OF TYPE Function1<Continuation<Unit>, Unit> = {a: Continuation<Unit> -> check(false, { "iqgeu"})}
2021-03-12 07:58:34,457 [main:61] - GENERATED IS CALL =false
2021-03-12 07:58:34,784 [main:67] - randomType = HashMap<Kla9, Boolean>
2021-03-12 07:58:34,987 [main:302] - generating value of type = HashMap<Kla9, Boolean> false depth = 0
2021-03-12 07:58:35,210 [main:43] - GENERATING CALL OF fun <K, V> hashMapOf(pairs: Pair<Kla9, Boolean>): HashMap<Kla9, Boolean> = TODO()
2021-03-12 07:58:35,221 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> hashMapOf(pairs: Pair<Kla9, Boolean>): HashMap<Kla9, Boolean> = TODO()
2021-03-12 07:58:35,441 [main:302] - generating value of type = Pair<Kla9, Boolean> false depth = 3
2021-03-12 07:58:35,657 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Kla9, second: Boolean): Pair<Kla9, Boolean> = TODO()
2021-03-12 07:58:35,667 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Kla9, second: Boolean): Pair<Kla9, Boolean> = TODO()
2021-03-12 07:58:35,890 [main:302] - generating value of type = Kla9 false depth = 6
2021-03-12 07:58:35,899 [main:112] - generating klass Kla9 text = class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}
2021-03-12 07:58:35,899 [main:302] - generating value of type = Boolean true depth = 6
2021-03-12 07:58:35,908 [main:95] - GENERATED = Pair<Kla9, Boolean>(Kla9(), true)
2021-03-12 07:58:35,908 [main:95] - GENERATED = hashMapOf<Kla9, Boolean>(Pair<Kla9, Boolean>(Kla9(), true))
2021-03-12 07:58:35,998 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Boolean
2021-03-12 07:58:36,007 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Boolean
2021-03-12 07:58:36,008 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Boolean
2021-03-12 07:58:36,010 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from UByte
2021-03-12 07:58:36,033 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Kla0
2021-03-12 07:58:36,037 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int
2021-03-12 07:58:36,068 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int
2021-03-12 07:58:36,070 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int
2021-03-12 07:58:36,071 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Function1<Int, Int>
2021-03-12 07:58:36,082 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from UByte
2021-03-12 07:58:36,083 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Foo
2021-03-12 07:58:36,092 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Foo
2021-03-12 07:58:36,093 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Kla2
2021-03-12 07:58:36,100 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Function1<Int, Int>
2021-03-12 07:58:36,101 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Function1<Int, Int>
2021-03-12 07:58:36,103 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Boolean
2021-03-12 07:58:36,104 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Float
2021-03-12 07:58:36,132 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int
2021-03-12 07:58:36,134 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int
2021-03-12 07:58:36,135 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int
2021-03-12 07:58:36,137 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int
2021-03-12 07:58:36,138 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Foo
2021-03-12 07:58:36,139 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Boolean
2021-03-12 07:58:36,141 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Foo
2021-03-12 07:58:36,142 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int
2021-03-12 07:58:36,144 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Boolean
2021-03-12 07:58:36,145 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int
2021-03-12 07:58:36,146 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Boolean
2021-03-12 07:58:36,148 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int
2021-03-12 07:58:36,149 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Foo
2021-03-12 07:58:36,151 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Boolean
2021-03-12 07:58:36,152 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Char
2021-03-12 07:58:36,170 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Function1<Int, Int>
2021-03-12 07:58:36,172 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Boolean
2021-03-12 07:58:36,173 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Boolean
2021-03-12 07:58:36,174 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int
2021-03-12 07:58:36,176 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Kla0
2021-03-12 07:58:36,177 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Foo
2021-03-12 07:58:36,179 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Byte
2021-03-12 07:58:36,209 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int
2021-03-12 07:58:36,211 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Foo
2021-03-12 07:58:36,212 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Foo
2021-03-12 07:58:36,214 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Foo
2021-03-12 07:58:36,215 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Boolean
2021-03-12 07:58:36,216 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Foo
2021-03-12 07:58:36,218 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Foo
2021-03-12 07:58:36,219 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Boolean
2021-03-12 07:58:36,222 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Boolean
2021-03-12 07:58:36,224 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Int
2021-03-12 07:58:36,227 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Boolean
2021-03-12 07:58:36,229 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from Boolean
2021-03-12 07:58:36,231 [main:106] - GETTING Function1<Continuation<Unit>, Unit> from UShort
2021-03-12 07:58:36,252 [main:114] - replacement of {
        fu16(it)
    } of type Function1<Continuation<Unit>, Unit> is {a: Continuation<Unit> -> check(false, { "iqgeu"})}
2021-03-12 07:58:36,454 [main:33] - Trying to replace LAMBDA_EXPRESSION on LAMBDA_EXPRESSION
2021-03-12 07:58:36,455 [main:66] - Compilation checking started
2021-03-12 07:58:37,381 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:37,384 [main:107] - replacing (prope11.getOrThrow(), Ty0)
2021-03-12 07:58:37,385 [main:50] - replacing prope11.getOrThrow() Ty0
2021-03-12 07:58:37,385 [main:54] - Getting value of type Ty0
2021-03-12 07:58:37,609 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 07:58:37,621 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 07:58:37,899 [main:67] - randomType = UByte?
2021-03-12 07:58:38,107 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 07:58:38,143 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:58:38,152 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:38,160 [main:106] - GETTING Ty0 from UByte
2021-03-12 07:58:38,181 [main:106] - GETTING Ty0 from UShort
2021-03-12 07:58:38,201 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:38,202 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:38,203 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:58:38,203 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:38,211 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:38,239 [main:106] - GETTING Ty0 from Kla2
2021-03-12 07:58:38,244 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:38,245 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:38,246 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:38,246 [main:106] - GETTING Ty0 from Char
2021-03-12 07:58:38,263 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:38,263 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:38,264 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:38,265 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:38,265 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:38,266 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:38,266 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:38,267 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:38,267 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:38,268 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:58:38,269 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:38,269 [main:106] - GETTING Ty0 from Kla0
2021-03-12 07:58:38,273 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:38,274 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:38,274 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:38,275 [main:106] - GETTING Ty0 from Byte
2021-03-12 07:58:38,304 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:38,304 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:38,305 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:38,306 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:38,306 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:38,307 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:38,308 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:38,308 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:38,309 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:38,309 [main:106] - GETTING Ty0 from Float
2021-03-12 07:58:38,337 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:58:38,337 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:38,338 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:38,338 [main:106] - GETTING Ty0 from Kla0
2021-03-12 07:58:38,339 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:38,340 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:38,340 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:38,341 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:58:38,341 [main:106] - GETTING Ty0 from Int
2021-03-12 07:58:38,342 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:38,342 [main:106] - GETTING Ty0 from UByte
2021-03-12 07:58:38,343 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:58:38,343 [main:111] - Cant find and generate replacement for prope11.getOrThrow() type Ty0
2021-03-12 07:58:38,343 [main:107] - replacing (prope8, Continuation<Any>?)
2021-03-12 07:58:38,343 [main:50] - replacing prope8 Continuation<Any>?
2021-03-12 07:58:38,343 [main:54] - Getting value of type Continuation<Any>?
2021-03-12 07:58:38,548 [main:302] - generating value of type = Continuation<Any> false depth = 0
2021-03-12 07:58:38,765 [main:43] - GENERATING CALL OF fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any>)->kotlin.Unit): Contuation<Any> = TODO()
2021-03-12 07:58:38,776 [main:61] - WITHOUT TYPE PARAMS = fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any>)->kotlin.Unit): Contuation<Any> = TODO()
2021-03-12 07:58:39,545 [main:302] - generating value of type = CoroutineContext false depth = 3
2021-03-12 07:58:39,761 [main:43] - GENERATING CALL OF fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:58:39,771 [main:61] - WITHOUT TYPE PARAMS = fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:58:40,274 [main:302] - generating value of type = Key<*> false depth = 6
2021-03-12 07:58:40,533 [main:43] - GENERATING CALL OF fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:58:40,544 [main:61] - WITHOUT TYPE PARAMS = fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:58:41,325 [main:385] - Cant generate call of fun <B, E> AbstractCoroutineContextKey(baseKey: kotlin.coroutines.CoroutineContext.Key<Element>, safeCast: (element: kotlin.coroutines.CoroutineContext.Element)->*): Key<*> = TODO()
2021-03-12 07:58:41,325 [main:385] - Cant generate call of fun AbstractCoroutineContextElement(key: kotlin.coroutines.CoroutineContext.Key<*>): CoroutineContext = TODO()
2021-03-12 07:58:41,325 [main:385] - Cant generate call of fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, resumeWith: (kotlin.Result<Any>)->kotlin.Unit): Contuation<Any> = TODO()
2021-03-12 07:58:41,325 [main:58] - GENERATED VALUE OF TYPE Continuation<Any>? = 
2021-03-12 07:58:41,343 [main:67] - randomType = Char
2021-03-12 07:58:41,550 [main:302] - generating value of type = Char true depth = 0
2021-03-12 07:58:41,577 [main:106] - GETTING Continuation<Any>? from Boolean
2021-03-12 07:58:41,586 [main:106] - GETTING Continuation<Any>? from Boolean
2021-03-12 07:58:41,587 [main:106] - GETTING Continuation<Any>? from Function1<Int, Int>
2021-03-12 07:58:41,597 [main:106] - GETTING Continuation<Any>? from Int
2021-03-12 07:58:41,626 [main:106] - GETTING Continuation<Any>? from Boolean
2021-03-12 07:58:41,627 [main:106] - GETTING Continuation<Any>? from Int
2021-03-12 07:58:41,628 [main:106] - GETTING Continuation<Any>? from Foo
2021-03-12 07:58:41,636 [main:106] - GETTING Continuation<Any>? from Foo
2021-03-12 07:58:41,637 [main:106] - GETTING Continuation<Any>? from Boolean
2021-03-12 07:58:41,638 [main:106] - GETTING Continuation<Any>? from Char
2021-03-12 07:58:41,656 [main:106] - GETTING Continuation<Any>? from Foo
2021-03-12 07:58:41,657 [main:106] - GETTING Continuation<Any>? from Foo
2021-03-12 07:58:41,658 [main:106] - GETTING Continuation<Any>? from Boolean
2021-03-12 07:58:41,659 [main:106] - GETTING Continuation<Any>? from Boolean
2021-03-12 07:58:41,660 [main:106] - GETTING Continuation<Any>? from Int
2021-03-12 07:58:41,661 [main:106] - GETTING Continuation<Any>? from Boolean
2021-03-12 07:58:41,662 [main:106] - GETTING Continuation<Any>? from UByte
2021-03-12 07:58:41,684 [main:106] - GETTING Continuation<Any>? from Boolean
2021-03-12 07:58:41,685 [main:106] - GETTING Continuation<Any>? from Int
2021-03-12 07:58:41,686 [main:106] - GETTING Continuation<Any>? from Foo
2021-03-12 07:58:41,687 [main:106] - GETTING Continuation<Any>? from Int
2021-03-12 07:58:41,688 [main:106] - GETTING Continuation<Any>? from Boolean
2021-03-12 07:58:41,689 [main:106] - GETTING Continuation<Any>? from Byte
2021-03-12 07:58:41,719 [main:106] - GETTING Continuation<Any>? from Int
2021-03-12 07:58:41,720 [main:106] - GETTING Continuation<Any>? from Int
2021-03-12 07:58:41,721 [main:106] - GETTING Continuation<Any>? from Foo
2021-03-12 07:58:41,722 [main:106] - GETTING Continuation<Any>? from Function1<Int, Int>
2021-03-12 07:58:41,723 [main:106] - GETTING Continuation<Any>? from Foo
2021-03-12 07:58:41,724 [main:106] - GETTING Continuation<Any>? from Boolean
2021-03-12 07:58:41,725 [main:106] - GETTING Continuation<Any>? from Boolean
2021-03-12 07:58:41,726 [main:106] - GETTING Continuation<Any>? from Boolean
2021-03-12 07:58:41,727 [main:106] - GETTING Continuation<Any>? from Int
2021-03-12 07:58:41,727 [main:106] - GETTING Continuation<Any>? from Foo
2021-03-12 07:58:41,728 [main:106] - GETTING Continuation<Any>? from Kla0
2021-03-12 07:58:41,733 [main:106] - GETTING Continuation<Any>? from Kla2
2021-03-12 07:58:41,738 [main:106] - GETTING Continuation<Any>? from Float
2021-03-12 07:58:41,765 [main:106] - GETTING Continuation<Any>? from Boolean
2021-03-12 07:58:41,766 [main:106] - GETTING Continuation<Any>? from Int
2021-03-12 07:58:41,767 [main:106] - GETTING Continuation<Any>? from Boolean
2021-03-12 07:58:41,768 [main:106] - GETTING Continuation<Any>? from Int
2021-03-12 07:58:41,769 [main:106] - GETTING Continuation<Any>? from Function1<Int, Int>
2021-03-12 07:58:41,770 [main:106] - GETTING Continuation<Any>? from Boolean
2021-03-12 07:58:41,771 [main:106] - GETTING Continuation<Any>? from Foo
2021-03-12 07:58:41,772 [main:106] - GETTING Continuation<Any>? from Kla0
2021-03-12 07:58:41,773 [main:106] - GETTING Continuation<Any>? from Function1<Int, Int>
2021-03-12 07:58:41,774 [main:106] - GETTING Continuation<Any>? from Foo
2021-03-12 07:58:41,775 [main:106] - GETTING Continuation<Any>? from Int
2021-03-12 07:58:41,776 [main:106] - GETTING Continuation<Any>? from UByte
2021-03-12 07:58:41,777 [main:106] - GETTING Continuation<Any>? from Int
2021-03-12 07:58:41,778 [main:106] - GETTING Continuation<Any>? from Int
2021-03-12 07:58:41,779 [main:106] - GETTING Continuation<Any>? from UShort
2021-03-12 07:58:41,802 [main:106] - GETTING Continuation<Any>? from Foo
2021-03-12 07:58:41,802 [main:111] - Cant find and generate replacement for prope8 type Continuation<Any>?
2021-03-12 07:58:41,802 [main:107] - replacing (prope11, String)
2021-03-12 07:58:41,802 [main:50] - replacing prope11 String
2021-03-12 07:58:41,802 [main:54] - Getting value of type String
2021-03-12 07:58:42,007 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:58:42,016 [main:58] - GENERATED VALUE OF TYPE String = "scyoj"
2021-03-12 07:58:42,016 [main:61] - GENERATED IS CALL =false
2021-03-12 07:58:42,292 [main:67] - randomType = Kla13
2021-03-12 07:58:42,496 [main:302] - generating value of type = Kla13 false depth = 0
2021-03-12 07:58:42,504 [main:112] - generating klass Kla13 text = object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}
2021-03-12 07:58:42,522 [main:106] - GETTING String from Int
2021-03-12 07:58:42,550 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:58:42,550 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:58:42,550 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:58:42,551 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toInt().toString((Foo(416482559, {a: Int -> 23}).state))
2021-03-12 07:58:42,551 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 07:58:42,551 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:58:42,551 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:58:42,755 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:58:42,764 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toShort().toString(427043819)
2021-03-12 07:58:42,764 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:58:42,764 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:58:42,765 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toString(f.next())
2021-03-12 07:58:42,765 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]]
2021-03-12 07:58:42,765 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:58:42,765 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]
2021-03-12 07:58:42,765 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().uppercase()
2021-03-12 07:58:42,765 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:58:42,765 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:58:42,765 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:58:42,765 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next())
2021-03-12 07:58:42,766 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 07:58:42,766 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:58:42,766 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 07:58:42,766 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().lowercase()
2021-03-12 07:58:42,766 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:58:42,766 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:58:42,970 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:58:42,979 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:58:42,979 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).compareTo(122788251).toString((Foo(-655341081, {a: Int -> 120045518}).state))
2021-03-12 07:58:42,979 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 07:58:42,979 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:58:42,979 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 07:58:42,979 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().titlecase()
2021-03-12 07:58:42,979 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:58:42,979 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 07:58:43,184 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:58:43,193 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:58:43,426 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:58:43,435 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).div(8332609178956470).toString(-1509955185)
2021-03-12 07:58:43,435 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:58:43,435 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:58:43,435 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:58:43,435 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toLong().toString(Foo(416482559, {a: Int -> 23}).state)
2021-03-12 07:58:43,435 [main:114] - replacement of prope11 of type String is (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().titlecase()
2021-03-12 07:58:43,648 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:58:43,648 [main:66] - Compilation checking started
2021-03-12 07:58:44,231 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().titlecase() = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:44,235 [main:107] - replacing (fu12().s, String)
2021-03-12 07:58:44,235 [main:50] - replacing fu12().s String
2021-03-12 07:58:44,235 [main:54] - Getting value of type String
2021-03-12 07:58:44,440 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:58:44,448 [main:58] - GENERATED VALUE OF TYPE String = "kpysd"
2021-03-12 07:58:44,449 [main:61] - GENERATED IS CALL =false
2021-03-12 07:58:44,483 [main:67] - randomType = Kla1
2021-03-12 07:58:44,691 [main:302] - generating value of type = Kla1 false depth = 0
2021-03-12 07:58:44,699 [main:112] - generating klass Kla1 text = class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}
2021-03-12 07:58:44,706 [main:106] - GETTING String from Int
2021-03-12 07:58:44,734 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:58:44,734 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 07:58:44,941 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:58:44,950 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:58:44,950 [main:117] - GENERATED CALL = ((f.next())).div(2570773418923731934).toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:58:44,950 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:58:44,950 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:58:44,950 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:58:45,164 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:58:45,173 [main:117] - GENERATED CALL = ((f.next())).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(1064327488)
2021-03-12 07:58:45,173 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:58:45,173 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:58:45,173 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:58:45,387 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:58:45,396 [main:117] - GENERATED CALL = ((f.next())).toLong().toString(-791780144)
2021-03-12 07:58:45,396 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:58:45,396 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:58:45,397 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:58:45,397 [main:117] - GENERATED CALL = ((f.next())).toByte().toString((Foo(655341081, {a: Int -> -655341081}).next()))
2021-03-12 07:58:45,397 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 07:58:45,397 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:58:45,397 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 07:58:45,397 [main:117] - GENERATED CALL = ((f.next())).toChar().titlecase()
2021-03-12 07:58:45,397 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:58:45,397 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:58:45,397 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:58:45,398 [main:117] - GENERATED CALL = ((f.next())).toInt().toString(Foo(1397637829, {a: Int -> -710498597}).next())
2021-03-12 07:58:45,398 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 07:58:45,398 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:58:45,398 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:58:45,398 [main:117] - GENERATED CALL = ((f.next())).toShort().toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())
2021-03-12 07:58:45,398 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:58:45,398 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:58:45,398 [main:117] - GENERATED CALL = ((f.next())).toString(Kla3().prope6)
2021-03-12 07:58:45,398 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 07:58:45,398 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:58:45,399 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 07:58:45,399 [main:117] - GENERATED CALL = ((f.next())).toChar().lowercase()
2021-03-12 07:58:45,399 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 07:58:45,399 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:58:45,399 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 07:58:45,604 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:58:45,613 [main:117] - GENERATED CALL = ((f.next())).toChar().plus("otfaz")
2021-03-12 07:58:45,613 [main:114] - replacement of fu12().s of type String is ((f.next())).toLong().toString(-791780144)
2021-03-12 07:58:45,817 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:58:45,818 [main:66] - Compilation checking started
2021-03-12 07:58:46,404 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = ((f.next())).toLong().toString(-791780144)
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:46,407 [main:107] - replacing (prope11, Result<Any?>)
2021-03-12 07:58:46,408 [main:50] - replacing prope11 Result<Any?>
2021-03-12 07:58:46,408 [main:54] - Getting value of type Result<Any?>
2021-03-12 07:58:46,622 [main:302] - generating value of type = Result<Any?> false depth = 0
2021-03-12 07:58:46,858 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 07:58:46,868 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 07:58:47,361 [main:302] - generating value of type = Function0<Any?> false depth = 3
2021-03-12 07:58:47,370 [main:302] - generating value of type = Any false depth = 4
2021-03-12 07:58:47,370 [main:95] - GENERATED = runCatching<Any?>({ "tsegi"})
2021-03-12 07:58:47,370 [main:58] - GENERATED VALUE OF TYPE Result<Any?> = runCatching<Any?>({ "tsegi"})
2021-03-12 07:58:47,370 [main:61] - GENERATED IS CALL =true
2021-03-12 07:58:47,405 [main:67] - randomType = Kla2
2021-03-12 07:58:47,612 [main:302] - generating value of type = Kla2 false depth = 0
2021-03-12 07:58:47,621 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 07:58:47,632 [main:106] - GETTING Result<Any?> from Int
2021-03-12 07:58:47,662 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 07:58:47,671 [main:106] - GETTING Result<Any?> from Int
2021-03-12 07:58:47,672 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 07:58:47,673 [main:106] - GETTING Result<Any?> from Int
2021-03-12 07:58:47,675 [main:106] - GETTING Result<Any?> from Int
2021-03-12 07:58:47,676 [main:106] - GETTING Result<Any?> from UByte
2021-03-12 07:58:47,699 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 07:58:47,707 [main:106] - GETTING Result<Any?> from UByte
2021-03-12 07:58:47,708 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 07:58:47,709 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 07:58:47,710 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 07:58:47,712 [main:106] - GETTING Result<Any?> from Function1<Int, Int>
2021-03-12 07:58:47,722 [main:106] - GETTING Result<Any?> from Char
2021-03-12 07:58:47,740 [main:106] - GETTING Result<Any?> from Int
2021-03-12 07:58:47,741 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 07:58:47,742 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 07:58:47,743 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 07:58:47,744 [main:106] - GETTING Result<Any?> from Function1<Int, Int>
2021-03-12 07:58:47,745 [main:106] - GETTING Result<Any?> from Int
2021-03-12 07:58:47,747 [main:106] - GETTING Result<Any?> from Int
2021-03-12 07:58:47,748 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 07:58:47,749 [main:106] - GETTING Result<Any?> from Float
2021-03-12 07:58:47,777 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 07:58:47,778 [main:106] - GETTING Result<Any?> from Kla0
2021-03-12 07:58:47,782 [main:106] - GETTING Result<Any?> from Function1<Int, Int>
2021-03-12 07:58:47,783 [main:106] - GETTING Result<Any?> from Int
2021-03-12 07:58:47,785 [main:106] - GETTING Result<Any?> from Int
2021-03-12 07:58:47,786 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 07:58:47,787 [main:106] - GETTING Result<Any?> from Int
2021-03-12 07:58:47,788 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 07:58:47,789 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 07:58:47,790 [main:106] - GETTING Result<Any?> from Byte
2021-03-12 07:58:47,821 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 07:58:47,822 [main:106] - GETTING Result<Any?> from Function1<Int, Int>
2021-03-12 07:58:47,823 [main:106] - GETTING Result<Any?> from Kla0
2021-03-12 07:58:47,824 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 07:58:47,826 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 07:58:47,827 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 07:58:47,828 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 07:58:47,829 [main:106] - GETTING Result<Any?> from UShort
2021-03-12 07:58:47,852 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 07:58:47,853 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 07:58:47,854 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 07:58:47,856 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 07:58:47,857 [main:106] - GETTING Result<Any?> from Int
2021-03-12 07:58:47,858 [main:106] - GETTING Result<Any?> from Int
2021-03-12 07:58:47,859 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 07:58:47,860 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 07:58:47,861 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 07:58:47,863 [main:106] - GETTING Result<Any?> from Kla2
2021-03-12 07:58:47,869 [main:106] - GETTING Result<Any?> from Int
2021-03-12 07:58:47,869 [main:114] - replacement of prope11 of type Result<Any?> is runCatching<Any?>({ "tsegi"})
2021-03-12 07:58:48,077 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:58:48,077 [main:66] - Compilation checking started
2021-03-12 07:58:48,974 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = fu12().s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
runCatching<Any?>({ "tsegi"}).getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:48,978 [main:107] - replacing (fu12(), Kla4)
2021-03-12 07:58:48,978 [main:50] - replacing fu12() Kla4
2021-03-12 07:58:48,978 [main:54] - Getting value of type Kla4
2021-03-12 07:58:49,186 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 07:58:49,195 [main:112] - generating klass Kla4 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)
2021-03-12 07:58:49,401 [main:194] - Type params = []
2021-03-12 07:58:49,608 [main:302] - generating value of type = String true depth = 2
2021-03-12 07:58:49,617 [main:58] - GENERATED VALUE OF TYPE Kla4 = Kla4("tfgaa")
2021-03-12 07:58:49,617 [main:61] - GENERATED IS CALL =true
2021-03-12 07:58:49,919 [main:67] - randomType = Short?
2021-03-12 07:58:50,128 [main:302] - generating value of type = Short true depth = 0
2021-03-12 07:58:50,175 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:58:50,184 [main:106] - GETTING Kla4 from Int
2021-03-12 07:58:50,213 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:58:50,221 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:58:50,221 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:58:50,222 [main:106] - GETTING Kla4 from Int
2021-03-12 07:58:50,222 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:58:50,230 [main:106] - GETTING Kla4 from Char
2021-03-12 07:58:50,246 [main:106] - GETTING Kla4 from Float
2021-03-12 07:58:50,273 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:58:50,274 [main:106] - GETTING Kla4 from Int
2021-03-12 07:58:50,274 [main:106] - GETTING Kla4 from UByte
2021-03-12 07:58:50,295 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:58:50,296 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:58:50,296 [main:106] - GETTING Kla4 from Kla2
2021-03-12 07:58:50,302 [main:106] - GETTING Kla4 from UByte
2021-03-12 07:58:50,302 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:58:50,303 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:58:50,304 [main:106] - GETTING Kla4 from Int
2021-03-12 07:58:50,304 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:58:50,305 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:58:50,305 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:58:50,306 [main:106] - GETTING Kla4 from Int
2021-03-12 07:58:50,306 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:58:50,307 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:58:50,308 [main:106] - GETTING Kla4 from Int
2021-03-12 07:58:50,308 [main:106] - GETTING Kla4 from Byte
2021-03-12 07:58:50,338 [main:106] - GETTING Kla4 from Int
2021-03-12 07:58:50,338 [main:106] - GETTING Kla4 from Int
2021-03-12 07:58:50,339 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:58:50,339 [main:106] - GETTING Kla4 from Int
2021-03-12 07:58:50,340 [main:106] - GETTING Kla4 from UShort
2021-03-12 07:58:50,361 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:58:50,362 [main:106] - GETTING Kla4 from Kla0
2021-03-12 07:58:50,365 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:58:50,366 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:58:50,366 [main:106] - GETTING Kla4 from Int
2021-03-12 07:58:50,367 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:58:50,367 [main:106] - GETTING Kla4 from Int
2021-03-12 07:58:50,368 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:58:50,369 [main:106] - GETTING Kla4 from Int
2021-03-12 07:58:50,369 [main:106] - GETTING Kla4 from Int
2021-03-12 07:58:50,370 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:58:50,370 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:58:50,371 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:58:50,371 [main:106] - GETTING Kla4 from Kla0
2021-03-12 07:58:50,372 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:58:50,373 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:58:50,373 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:58:50,374 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:58:50,374 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:58:50,375 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:58:50,375 [main:114] - replacement of fu12() of type Kla4 is Kla4("tfgaa")
2021-03-12 07:58:50,579 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:58:50,580 [main:66] - Compilation checking started
2021-03-12 07:58:51,480 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
runCatching<Any?>({ "tsegi"}).getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != numberOfSuspensions)
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:51,485 [main:107] - replacing (numberOfSuspensions, Int)
2021-03-12 07:58:51,485 [main:50] - replacing numberOfSuspensions Int
2021-03-12 07:58:51,485 [main:54] - Getting value of type Int
2021-03-12 07:58:51,718 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:58:51,728 [main:58] - GENERATED VALUE OF TYPE Int = 1046643554
2021-03-12 07:58:51,728 [main:61] - GENERATED IS CALL =false
2021-03-12 07:58:53,455 [main:67] - randomType = ArrayDeque<Function2<ArrayDeque<ULong>, UInt, Collection<String>>>?
2021-03-12 07:58:53,664 [main:302] - generating value of type = ArrayDeque<Function2<ArrayDeque<ULong>, UInt, Collection<String>>> false depth = 0
2021-03-12 07:58:53,883 [main:43] - GENERATING CALL OF fun <E> ArrayDeque(elements: kotlin.collections.Collection<Function2<ArrayDeque<ULong>, UInt, Collection<String>>>): ArrayDeque<Function2<ArrayDeque<ULong>, UInt, Collection<String>>> = TODO()
2021-03-12 07:58:53,894 [main:61] - WITHOUT TYPE PARAMS = fun <E> ArrayDeque(elements: kotlin.collections.Collection<Function2<ArrayDeque<ULong>, UInt, Collection<String>>>): ArrayDeque<Function2<ArrayDeque<ULong>, UInt, Collection<String>>> = TODO()
2021-03-12 07:58:54,425 [main:302] - generating value of type = Collection<Function2<ArrayDeque<ULong>, UInt, Collection<String>>> false depth = 3
2021-03-12 07:58:54,649 [main:43] - GENERATING CALL OF fun <T> linkedSetOf(elements: Function2<ArrayDeque<ULong>, UInt, Collection<String>>): Collection<Function2<ArrayDeque<ULong>, UInt, Collection<Strg>>> = TODO()
2021-03-12 07:58:54,659 [main:61] - WITHOUT TYPE PARAMS = fun <T> linkedSetOf(elements: Function2<ArrayDeque<ULong>, UInt, Collection<String>>): Collection<Function2<ArrayDeque<ULong>, UInt, Collection<Strg>>> = TODO()
2021-03-12 07:58:54,883 [main:302] - generating value of type = Function2<ArrayDeque<ULong>, UInt, Collection<String>> false depth = 6
2021-03-12 07:58:54,892 [main:302] - generating value of type = Collection<String> false depth = 7
2021-03-12 07:58:55,112 [main:43] - GENERATING CALL OF fun ULongArray(size: kotlin.Int): Collection<String> = TODO()
2021-03-12 07:58:55,123 [main:61] - WITHOUT TYPE PARAMS = fun ULongArray(size: kotlin.Int): Collection<String> = TODO()
2021-03-12 07:58:55,608 [main:302] - generating value of type = Int true depth = 10
2021-03-12 07:58:55,617 [main:95] - GENERATED = ULongArray(665432647)
2021-03-12 07:58:55,617 [main:95] - GENERATED = linkedSetOf<Function2<ArrayDeque<ULong>, UInt, Collection<String>>>({a: ArrayDeque<ULong>, b: UInt -> ULongArray(665432647)})
2021-03-12 07:58:55,617 [main:95] - GENERATED = ArrayDeque<Function2<ArrayDeque<ULong>, UInt, Collection<String>>>(linkedSetOf<Function2<ArrayDeque<ULong>, UInt, Collection<String>>>({a: ArrayDeque<ULong>, b: UInt -> ULongArray(665432647)}))
2021-03-12 07:58:55,888 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@62f7e5f9]
2021-03-12 07:58:56,121 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:58:56,130 [main:78] - Generated call from random type = (ArrayDeque<Function2<ArrayDeque<ULong>, UInt, Collection<String>>>(linkedSetOf<Function2<ArrayDeque<ULong>, UInt, Collection<String>>>({a: ArrayDeque<ULong>, b: UInt -> ULongArray(665432647)})))?.modCount.ushr(-916948291)
2021-03-12 07:58:56,131 [main:106] - GETTING Int from Boolean
2021-03-12 07:58:56,140 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public val kotlin.Int.absoluteValue: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@918d98b]]
2021-03-12 07:58:56,140 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:58:56,140 [main:117] - GENERATED CALL = (Kla1().fu1()).compareTo(Kla2().fu4()).absoluteValue
2021-03-12 07:58:56,140 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7b0a48e6]]
2021-03-12 07:58:56,140 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:58:56,348 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:58:56,357 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7b0a48e6]
2021-03-12 07:58:56,358 [main:117] - GENERATED CALL = (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next())
2021-03-12 07:58:56,358 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7bf4ba17]]
2021-03-12 07:58:56,358 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:58:56,566 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:58:56,575 [main:149] - GENERATING call of type public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7bf4ba17]
2021-03-12 07:58:56,575 [main:117] - GENERATED CALL = (Kla1().fu1()).compareTo(false).inv()
2021-03-12 07:58:56,575 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@55e60c72]]
2021-03-12 07:58:56,575 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:58:56,782 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:58:56,791 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@55e60c72]
2021-03-12 07:58:56,791 [main:117] - GENERATED CALL = (Kla1().fu1()).compareTo(true).div((Foo(416482559, {a: Int -> 23}).state).toByte())
2021-03-12 07:58:56,791 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@62f7e5f9]]
2021-03-12 07:58:56,791 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:58:56,791 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@62f7e5f9]
2021-03-12 07:58:56,792 [main:117] - GENERATED CALL = (Kla1().fu1()).compareTo(Kla2().fu2()).ushr((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())))
2021-03-12 07:58:56,792 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7ad8c23d]]
2021-03-12 07:58:56,792 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:58:56,792 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7ad8c23d]
2021-03-12 07:58:56,792 [main:117] - GENERATED CALL = (Kla1().fu1()).compareTo(Kla1().fu2()).dec()
2021-03-12 07:58:56,792 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@36ee2e3a]]
2021-03-12 07:58:56,792 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:58:56,792 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Int.takeLowestOneBit(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@36ee2e3a]
2021-03-12 07:58:56,792 [main:117] - GENERATED CALL = (Kla1().fu1()).compareTo(Kla1().fu3()).takeLowestOneBit()
2021-03-12 07:58:56,792 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3495fc12]]
2021-03-12 07:58:56,792 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:58:56,999 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:58:57,008 [main:149] - GENERATING call of type public final operator fun times(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3495fc12]
2021-03-12 07:58:57,008 [main:117] - GENERATED CALL = (Kla1().fu1()).compareTo(false).times((Foo(416482559, {a: Int -> 23}).state).toByte())
2021-03-12 07:58:57,008 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]]
2021-03-12 07:58:57,008 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 07:58:57,216 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:58:57,217 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:58:57,422 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:58:57,431 [main:117] - GENERATED CALL = (Kla1().fu1()).equals("jwhmw").compareTo(true)
2021-03-12 07:58:57,431 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], @kotlin.SinceKotlin public val kotlin.Int.sign: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@4b82cbd8]]
2021-03-12 07:58:57,432 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:58:57,432 [main:117] - GENERATED CALL = (Kla1().fu1()).compareTo(Kla2().fu2()).sign
2021-03-12 07:58:57,432 [main:114] - replacement of numberOfSuspensions of type Int is (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next())
2021-03-12 07:58:57,637 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:58:57,638 [main:66] - Compilation checking started
2021-03-12 07:58:58,533 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = "FAIL"
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
runCatching<Any?>({ "tsegi"}).getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:58:58,536 [main:107] - replacing ("FAIL", String)
2021-03-12 07:58:58,537 [main:50] - replacing "FAIL" String
2021-03-12 07:58:58,537 [main:54] - Getting value of type String
2021-03-12 07:58:58,748 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:58:58,757 [main:58] - GENERATED VALUE OF TYPE String = "tkalp"
2021-03-12 07:58:58,757 [main:61] - GENERATED IS CALL =false
2021-03-12 07:58:59,059 [main:67] - randomType = HashSet<Kla11>
2021-03-12 07:58:59,268 [main:302] - generating value of type = HashSet<Kla11> false depth = 0
2021-03-12 07:58:59,511 [main:43] - GENERATING CALL OF fun <E> LinkedHashSet(): HashSet<Kla11> = TODO()
2021-03-12 07:58:59,522 [main:61] - WITHOUT TYPE PARAMS = fun <E> LinkedHashSet(): HashSet<Kla11> = TODO()
2021-03-12 07:58:59,746 [main:95] - GENERATED = LinkedHashSet<Kla11>()
2021-03-12 07:58:59,861 [main:149] - GENERATING call of type @kotlin.js.JsName protected open fun toArray(): kotlin.Array<kotlin.Any?> defined in kotlin.collections.HashSet[DeserializedSimpleFunctionDescriptor@50ecc8ff]
2021-03-12 07:58:59,861 [main:149] - GENERATING call of type public fun <T> kotlin.Array<out T>.joinToString(separator: kotlin.CharSequence = ..., prefix: kotlin.CharSequence = ..., postfix: kotlin.CharSequence = ..., limit: kotlin.Int = ..., truncated: kotlin.CharSequence = ..., transform: ((T) -> kotlin.CharSequence)? = ...): kotlin.String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@e5b24e9]
2021-03-12 07:59:00,070 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 07:59:00,289 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 07:59:00,509 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 07:59:00,729 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:59:00,946 [main:302] - generating value of type = CharSequence false depth = 0
2021-03-12 07:59:01,166 [main:302] - generating value of type = Function1<T, CharSequence> false depth = 0
2021-03-12 07:59:01,174 [main:302] - generating value of type = CharSequence false depth = 1
2021-03-12 07:59:01,393 [main:43] - GENERATING CALL OF fun StringBuilder(capacity: kotlin.Int): CharSequence = TODO()
2021-03-12 07:59:01,403 [main:61] - WITHOUT TYPE PARAMS = fun StringBuilder(capacity: kotlin.Int): CharSequence = TODO()
2021-03-12 07:59:01,890 [main:302] - generating value of type = Int true depth = 4
2021-03-12 07:59:01,899 [main:95] - GENERATED = StringBuilder(1682115546)
2021-03-12 07:59:01,899 [main:78] - Generated call from random type = (LinkedHashSet<Kla11>()).toArray().joinToString("crnzs", "roawm", "phkot", 732988726, "jlqdn", {a: T -> StringBuilder(1682115546)})
2021-03-12 07:59:01,900 [main:106] - GETTING String from Int
2021-03-12 07:59:01,930 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 07:59:01,930 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 07:59:01,930 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:59:01,930 [main:117] - GENERATED CALL = (f.next()).toShort().toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())))
2021-03-12 07:59:01,930 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:59:01,930 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:59:01,930 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:59:01,931 [main:117] - GENERATED CALL = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
2021-03-12 07:59:01,931 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]]
2021-03-12 07:59:01,931 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:59:01,931 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]
2021-03-12 07:59:01,931 [main:117] - GENERATED CALL = (f.next()).toChar().uppercase()
2021-03-12 07:59:01,931 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 07:59:01,931 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:59:01,931 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 07:59:01,931 [main:117] - GENERATED CALL = (f.next()).toChar().lowercase()
2021-03-12 07:59:01,931 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:59:01,931 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:59:01,931 [main:117] - GENERATED CALL = (f.next()).toString(Kla3().prope6)
2021-03-12 07:59:01,931 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:59:01,931 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:59:01,931 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:59:01,932 [main:117] - GENERATED CALL = (f.next()).toByte().toString((f).next())
2021-03-12 07:59:01,932 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:59:01,932 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:59:01,932 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:59:01,932 [main:117] - GENERATED CALL = (f.next()).compareTo(Foo(1397637829, {a: Int -> -710498597}).next()).toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:59:01,932 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 07:59:01,932 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:59:01,932 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 07:59:02,141 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:59:02,150 [main:117] - GENERATED CALL = (f.next()).toChar().plus("qamct")
2021-03-12 07:59:02,150 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 07:59:02,150 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:59:02,150 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 07:59:02,150 [main:117] - GENERATED CALL = (f.next()).toChar().titlecase()
2021-03-12 07:59:02,150 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:59:02,150 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 07:59:02,358 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:59:02,367 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:59:02,367 [main:117] - GENERATED CALL = (f.next()).div(-3592521362420478841).toString(f.next())
2021-03-12 07:59:02,367 [main:114] - replacement of "FAIL" of type String is (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
2021-03-12 07:59:02,575 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:59:02,575 [main:66] - Compilation checking started
2021-03-12 07:59:03,520 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = fu12().s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
runCatching<Any?>({ "tsegi"}).getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:03,523 [main:107] - replacing (fu12(), Kla4)
2021-03-12 07:59:03,523 [main:50] - replacing fu12() Kla4
2021-03-12 07:59:03,523 [main:54] - Getting value of type Kla4
2021-03-12 07:59:03,740 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 07:59:03,749 [main:112] - generating klass Kla4 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)
2021-03-12 07:59:03,958 [main:194] - Type params = []
2021-03-12 07:59:04,168 [main:302] - generating value of type = String true depth = 2
2021-03-12 07:59:04,177 [main:58] - GENERATED VALUE OF TYPE Kla4 = Kla4("pmsta")
2021-03-12 07:59:04,177 [main:61] - GENERATED IS CALL =true
2021-03-12 07:59:04,196 [main:67] - randomType = Long
2021-03-12 07:59:04,405 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:59:04,443 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:04,450 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:04,457 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:04,486 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:04,487 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:04,487 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:04,488 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:04,488 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:04,489 [main:106] - GETTING Kla4 from UShort
2021-03-12 07:59:04,511 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:04,512 [main:106] - GETTING Kla4 from Char
2021-03-12 07:59:04,528 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:04,529 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:04,530 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:04,531 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:04,532 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:04,533 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:04,534 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:04,535 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:04,536 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:04,537 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:04,538 [main:106] - GETTING Kla4 from UByte
2021-03-12 07:59:04,565 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:04,566 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:04,566 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:04,567 [main:106] - GETTING Kla4 from Byte
2021-03-12 07:59:04,600 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:04,601 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:04,601 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:04,602 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:04,603 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:04,603 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:04,604 [main:106] - GETTING Kla4 from Kla0
2021-03-12 07:59:04,608 [main:106] - GETTING Kla4 from Kla2
2021-03-12 07:59:04,613 [main:106] - GETTING Kla4 from Float
2021-03-12 07:59:04,639 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:04,640 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:04,641 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:04,641 [main:106] - GETTING Kla4 from Kla0
2021-03-12 07:59:04,642 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:59:04,651 [main:106] - GETTING Kla4 from UByte
2021-03-12 07:59:04,652 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:59:04,653 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:04,653 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:04,654 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:04,654 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:04,655 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:04,656 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:59:04,656 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:04,657 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:59:04,657 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:04,658 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:04,658 [main:114] - replacement of fu12() of type Kla4 is Kla4("pmsta")
2021-03-12 07:59:04,867 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:59:04,867 [main:66] - Compilation checking started
2021-03-12 07:59:05,785 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
runCatching<Any?>({ "tsegi"}).getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:05,788 [main:107] - replacing (prope11.getOrThrow(), Ty0)
2021-03-12 07:59:05,788 [main:50] - replacing prope11.getOrThrow() Ty0
2021-03-12 07:59:05,788 [main:54] - Getting value of type Ty0
2021-03-12 07:59:06,002 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 07:59:06,013 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 07:59:06,069 [main:67] - randomType = Kla5
2021-03-12 07:59:06,281 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 07:59:06,290 [main:112] - generating klass Kla5 text = class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}
2021-03-12 07:59:06,500 [main:194] - Type params = []
2021-03-12 07:59:06,722 [main:149] - GENERATING call of type public final suspend fun <Ty0> fu11(t: Ty0): Ty0 defined in Kla5[SimpleFunctionDescriptorImpl@6facf600]
2021-03-12 07:59:06,932 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 07:59:06,944 [main:158] - CANT GENERATE PARAMS FOR public final suspend fun <Ty0> fu11(t: Ty0): Ty0 defined in Kla5[SimpleFunctionDescriptorImpl@6facf600]
2021-03-12 07:59:06,944 [main:78] - Generated call from random type = (Kla5()).null
2021-03-12 07:59:06,945 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:06,952 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:59:06,962 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:06,969 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:06,970 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:06,971 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:06,971 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:06,972 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:59:06,972 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:06,973 [main:106] - GETTING Ty0 from Char
2021-03-12 07:59:06,990 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:59:06,991 [main:106] - GETTING Ty0 from Kla2
2021-03-12 07:59:06,996 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:06,997 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:06,998 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:06,998 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:06,999 [main:106] - GETTING Ty0 from Float
2021-03-12 07:59:07,027 [main:106] - GETTING Ty0 from UByte
2021-03-12 07:59:07,048 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:07,049 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:07,050 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:07,080 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:07,081 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:07,082 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:07,082 [main:106] - GETTING Ty0 from Kla0
2021-03-12 07:59:07,086 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:07,086 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:07,087 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:07,087 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:07,088 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:07,088 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:07,089 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:07,090 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:07,090 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:07,091 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:07,091 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:07,092 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:07,092 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:07,093 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:07,094 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:07,094 [main:106] - GETTING Ty0 from Kla0
2021-03-12 07:59:07,095 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:59:07,095 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:07,096 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:07,097 [main:106] - GETTING Ty0 from Byte
2021-03-12 07:59:07,126 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:07,127 [main:106] - GETTING Ty0 from UByte
2021-03-12 07:59:07,128 [main:106] - GETTING Ty0 from UShort
2021-03-12 07:59:07,149 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:07,150 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:07,150 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:07,151 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:07,151 [main:114] - replacement of prope11.getOrThrow() of type Ty0 is (Kla5()).null
2021-03-12 07:59:07,360 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:59:07,361 [main:66] - Compilation checking started
2021-03-12 07:59:07,959 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    prope8?.resume(Kla4("OK"))

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x((Kla5()).null)
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
runCatching<Any?>({ "tsegi"}).getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:07,963 [main:107] - replacing (prope8?.resume(Kla4("OK")), Unit?)
2021-03-12 07:59:07,963 [main:50] - replacing prope8?.resume(Kla4("OK")) Unit?
2021-03-12 07:59:07,963 [main:54] - Getting value of type Unit?
2021-03-12 07:59:08,179 [main:302] - generating value of type = Unit false depth = 0
2021-03-12 07:59:08,399 [main:43] - GENERATING CALL OF fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 07:59:08,410 [main:61] - WITHOUT TYPE PARAMS = fun println(message: kotlin.Any?): Unit = TODO()
2021-03-12 07:59:08,900 [main:302] - generating value of type = Any false depth = 3
2021-03-12 07:59:08,900 [main:95] - GENERATED = println("fktzz")
2021-03-12 07:59:08,900 [main:58] - GENERATED VALUE OF TYPE Unit? = println("fktzz")
2021-03-12 07:59:08,900 [main:61] - GENERATED IS CALL =true
2021-03-12 07:59:09,503 [main:67] - randomType = ArrayDeque<Kla1?>
2021-03-12 07:59:09,712 [main:302] - generating value of type = ArrayDeque<Kla1?> false depth = 0
2021-03-12 07:59:09,933 [main:43] - GENERATING CALL OF fun <E> ArrayDeque(elements: kotlin.collections.Collection<Kla1?>): ArrayDeque<Kla1?> = TODO()
2021-03-12 07:59:09,944 [main:61] - WITHOUT TYPE PARAMS = fun <E> ArrayDeque(elements: kotlin.collections.Collection<Kla1?>): ArrayDeque<Kla1?> = TODO()
2021-03-12 07:59:10,461 [main:302] - generating value of type = Collection<Kla1?> false depth = 3
2021-03-12 07:59:10,690 [main:43] - GENERATING CALL OF fun <T> emptyList(): Collection<Kla1?> = TODO()
2021-03-12 07:59:10,701 [main:61] - WITHOUT TYPE PARAMS = fun <T> emptyList(): Collection<Kla1?> = TODO()
2021-03-12 07:59:10,929 [main:95] - GENERATED = emptyList<Kla1?>()
2021-03-12 07:59:10,929 [main:95] - GENERATED = ArrayDeque<Kla1?>(emptyList<Kla1?>())
2021-03-12 07:59:11,044 [main:149] - GENERATING call of type public open fun subList(fromIndex: kotlin.Int, toIndex: kotlin.Int): kotlin.collections.MutableList<Kla1?> defined in kotlin.collections.ArrayDeque[DeserializedSimpleFunctionDescriptor@6b740764]
2021-03-12 07:59:11,045 [main:149] - GENERATING call of type public inline fun <T, R : kotlin.Comparable<R>> kotlin.collections.MutableList<T>.sortBy(crossinline selector: (T) -> R?): kotlin.Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor@516acd72]
2021-03-12 07:59:11,254 [main:302] - generating value of type = Function1<T, R?> false depth = 0
2021-03-12 07:59:11,263 [main:302] - generating value of type = R false depth = 1
2021-03-12 07:59:12,058 [main:43] - GENERATING CALL OF fun <T, R> with(receiver: Set<UByte?>, block: T.()->Boolean): R = TODO()
2021-03-12 07:59:12,069 [main:61] - WITHOUT TYPE PARAMS = fun <T, R> with(receiver: Set<UByte?>, block: T.()->Boolean): R = TODO()
2021-03-12 07:59:12,723 [main:302] - generating value of type = Set<UByte?> false depth = 4
2021-03-12 07:59:12,972 [main:43] - GENERATING CALL OF fun <T> hashSetOf(elements: UByte?): Set<UByte?> = TODO()
2021-03-12 07:59:12,983 [main:61] - WITHOUT TYPE PARAMS = fun <T> hashSetOf(elements: UByte?): Set<UByte?> = TODO()
2021-03-12 07:59:13,210 [main:302] - generating value of type = UByte true depth = 7
2021-03-12 07:59:13,219 [main:95] - GENERATED = hashSetOf<UByte?>(88.toUByte())
2021-03-12 07:59:13,219 [main:385] - Cant generate call of fun <T, R> with(receiver: Set<UByte?>, block: T.()->Boolean): R = TODO()
2021-03-12 07:59:13,219 [main:78] - Generated call from random type = (ArrayDeque<Kla1?>(emptyList<Kla1?>())).subList((Foo(416482559, {a: Int -> 23}).state), (f).next()).sortBy({a: T -> })
2021-03-12 07:59:13,220 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 07:59:13,231 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:13,260 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:13,268 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:13,269 [main:106] - GETTING Unit? from Char
2021-03-12 07:59:13,286 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:13,293 [main:106] - GETTING Unit? from UByte
2021-03-12 07:59:13,314 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:13,315 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:13,316 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:13,317 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:13,317 [main:106] - GETTING Unit? from Byte
2021-03-12 07:59:13,347 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:13,348 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:13,349 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:13,349 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:13,350 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:13,351 [main:106] - GETTING Unit? from Float
2021-03-12 07:59:13,379 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:13,380 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:13,380 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:13,381 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:13,382 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:13,383 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 07:59:13,384 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:13,384 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:13,385 [main:106] - GETTING Unit? from Kla2
2021-03-12 07:59:13,391 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:13,392 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:13,393 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 07:59:13,394 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:13,395 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:13,396 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:13,396 [main:106] - GETTING Unit? from Kla0
2021-03-12 07:59:13,400 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 07:59:13,401 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:13,402 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:13,403 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:13,403 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:13,404 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:13,405 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:13,406 [main:106] - GETTING Unit? from UByte
2021-03-12 07:59:13,407 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:13,408 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:13,408 [main:106] - GETTING Unit? from UShort
2021-03-12 07:59:13,431 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:13,432 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:13,432 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:13,433 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:13,434 [main:106] - GETTING Unit? from Kla0
2021-03-12 07:59:13,435 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:13,436 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:13,436 [main:114] - replacement of prope8?.resume(Kla4("OK")) of type Unit? is println("fktzz")
2021-03-12 07:59:13,644 [main:33] - Trying to replace Element(SAFE_ACCESS_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:59:13,644 [main:66] - Compilation checking started
2021-03-12 07:59:14,589 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
runCatching<Any?>({ "tsegi"}).getOrThrow()
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:14,593 [main:107] - replacing (runCatching<Any?>({ "tsegi"}).getOrThrow(), Any?)
2021-03-12 07:59:14,593 [main:50] - replacing runCatching<Any?>({ "tsegi"}).getOrThrow() Any?
2021-03-12 07:59:14,593 [main:54] - Getting value of type Any?
2021-03-12 07:59:14,803 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:59:14,803 [main:58] - GENERATED VALUE OF TYPE Any? = "uzone"
2021-03-12 07:59:14,803 [main:61] - GENERATED IS CALL =false
2021-03-12 07:59:14,821 [main:67] - randomType = UInt
2021-03-12 07:59:15,031 [main:302] - generating value of type = UInt true depth = 0
2021-03-12 07:59:15,068 [main:106] - GETTING Any? from Int
2021-03-12 07:59:15,097 [main:106] - GETTING Any? from Boolean
2021-03-12 07:59:15,105 [main:106] - GETTING Any? from Int
2021-03-12 07:59:15,106 [main:106] - GETTING Any? from Int
2021-03-12 07:59:15,107 [main:106] - GETTING Any? from Int
2021-03-12 07:59:15,108 [main:106] - GETTING Any? from Boolean
2021-03-12 07:59:15,109 [main:106] - GETTING Any? from Foo
2021-03-12 07:59:15,117 [main:106] - GETTING Any? from Boolean
2021-03-12 07:59:15,119 [main:106] - GETTING Any? from Int
2021-03-12 07:59:15,120 [main:106] - GETTING Any? from Int
2021-03-12 07:59:15,121 [main:106] - GETTING Any? from Int
2021-03-12 07:59:15,122 [main:106] - GETTING Any? from Boolean
2021-03-12 07:59:15,123 [main:106] - GETTING Any? from Foo
2021-03-12 07:59:15,124 [main:106] - GETTING Any? from Foo
2021-03-12 07:59:15,125 [main:106] - GETTING Any? from Boolean
2021-03-12 07:59:15,126 [main:106] - GETTING Any? from Kla0
2021-03-12 07:59:15,130 [main:106] - GETTING Any? from Boolean
2021-03-12 07:59:15,131 [main:106] - GETTING Any? from UByte
2021-03-12 07:59:15,153 [main:106] - GETTING Any? from Boolean
2021-03-12 07:59:15,154 [main:106] - GETTING Any? from Boolean
2021-03-12 07:59:15,155 [main:106] - GETTING Any? from Foo
2021-03-12 07:59:15,156 [main:106] - GETTING Any? from Foo
2021-03-12 07:59:15,157 [main:106] - GETTING Any? from Boolean
2021-03-12 07:59:15,158 [main:106] - GETTING Any? from Boolean
2021-03-12 07:59:15,159 [main:106] - GETTING Any? from Int
2021-03-12 07:59:15,160 [main:106] - GETTING Any? from Int
2021-03-12 07:59:15,161 [main:106] - GETTING Any? from Kla0
2021-03-12 07:59:15,162 [main:106] - GETTING Any? from Foo
2021-03-12 07:59:15,163 [main:106] - GETTING Any? from Boolean
2021-03-12 07:59:15,164 [main:106] - GETTING Any? from Kla2
2021-03-12 07:59:15,170 [main:106] - GETTING Any? from Function1<Int, Int>
2021-03-12 07:59:15,185 [main:106] - GETTING Any? from Char
2021-03-12 07:59:15,205 [main:106] - GETTING Any? from Int
2021-03-12 07:59:15,207 [main:106] - GETTING Any? from Boolean
2021-03-12 07:59:15,208 [main:106] - GETTING Any? from Function1<Int, Int>
2021-03-12 07:59:15,209 [main:106] - GETTING Any? from Foo
2021-03-12 07:59:15,210 [main:106] - GETTING Any? from Int
2021-03-12 07:59:15,211 [main:106] - GETTING Any? from Boolean
2021-03-12 07:59:15,212 [main:106] - GETTING Any? from Function1<Int, Int>
2021-03-12 07:59:15,213 [main:106] - GETTING Any? from Int
2021-03-12 07:59:15,214 [main:106] - GETTING Any? from UByte
2021-03-12 07:59:15,215 [main:106] - GETTING Any? from Int
2021-03-12 07:59:15,216 [main:106] - GETTING Any? from Foo
2021-03-12 07:59:15,217 [main:106] - GETTING Any? from Boolean
2021-03-12 07:59:15,218 [main:106] - GETTING Any? from Float
2021-03-12 07:59:15,246 [main:106] - GETTING Any? from UShort
2021-03-12 07:59:15,267 [main:106] - GETTING Any? from Function1<Int, Int>
2021-03-12 07:59:15,269 [main:106] - GETTING Any? from Foo
2021-03-12 07:59:15,270 [main:106] - GETTING Any? from Foo
2021-03-12 07:59:15,271 [main:106] - GETTING Any? from Boolean
2021-03-12 07:59:15,272 [main:106] - GETTING Any? from Byte
2021-03-12 07:59:15,301 [main:106] - GETTING Any? from Foo
2021-03-12 07:59:15,301 [main:114] - replacement of runCatching<Any?>({ "tsegi"}).getOrThrow() of type Any? is "uzone"
2021-03-12 07:59:15,510 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 07:59:15,510 [main:66] - Compilation checking started
2021-03-12 07:59:16,453 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:16,457 [main:107] - replacing (prope15, Function0<Unit>)
2021-03-12 07:59:16,457 [main:50] - replacing prope15 Function0<Unit>
2021-03-12 07:59:16,457 [main:54] - Getting value of type Function0<Unit>
2021-03-12 07:59:16,677 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 07:59:16,686 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 07:59:16,906 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 07:59:16,917 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean): Unit = TODO()
2021-03-12 07:59:17,404 [main:302] - generating value of type = Boolean true depth = 4
2021-03-12 07:59:17,413 [main:95] - GENERATED = require(true)
2021-03-12 07:59:17,413 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { require(true)}
2021-03-12 07:59:17,413 [main:61] - GENERATED IS CALL =false
2021-03-12 07:59:17,449 [main:67] - randomType = Kla4
2021-03-12 07:59:17,660 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 07:59:17,669 [main:112] - generating klass Kla4 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)
2021-03-12 07:59:17,877 [main:194] - Type params = []
2021-03-12 07:59:18,085 [main:302] - generating value of type = String true depth = 2
2021-03-12 07:59:18,100 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:18,108 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:18,137 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:18,138 [main:106] - GETTING Function0<Unit> from UByte
2021-03-12 07:59:18,160 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:18,167 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:18,168 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:18,169 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:59:18,179 [main:106] - GETTING Function0<Unit> from Char
2021-03-12 07:59:18,196 [main:106] - GETTING Function0<Unit> from Byte
2021-03-12 07:59:18,225 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:18,226 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:59:18,227 [main:106] - GETTING Function0<Unit> from UByte
2021-03-12 07:59:18,228 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:18,229 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:18,230 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:18,231 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:18,232 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:18,233 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:18,234 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:18,235 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:18,236 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:18,237 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:18,238 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:18,239 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:18,239 [main:106] - GETTING Function0<Unit> from Kla0
2021-03-12 07:59:18,244 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:18,245 [main:106] - GETTING Function0<Unit> from Float
2021-03-12 07:59:18,272 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:18,273 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:18,274 [main:106] - GETTING Function0<Unit> from Kla0
2021-03-12 07:59:18,275 [main:106] - GETTING Function0<Unit> from UShort
2021-03-12 07:59:18,302 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:18,303 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:59:18,304 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:18,305 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:18,306 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:18,307 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:18,308 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:18,309 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:59:18,310 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:18,311 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:18,312 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:18,313 [main:106] - GETTING Function0<Unit> from Kla2
2021-03-12 07:59:18,321 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:18,322 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:18,323 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:18,324 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:18,325 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:18,326 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:18,327 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:18,328 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:18,328 [main:114] - replacement of prope15 of type Function0<Unit> is { require(true)}
2021-03-12 07:59:18,540 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 07:59:18,541 [main:66] - Compilation checking started
2021-03-12 07:59:19,156 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + method + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            { require(true)}()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:19,159 [main:107] - replacing (method, String)
2021-03-12 07:59:19,159 [main:50] - replacing method String
2021-03-12 07:59:19,159 [main:54] - Getting value of type String
2021-03-12 07:59:19,397 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:59:19,407 [main:58] - GENERATED VALUE OF TYPE String = "attcs"
2021-03-12 07:59:19,407 [main:61] - GENERATED IS CALL =false
2021-03-12 07:59:21,283 [main:67] - randomType = Pair<LinkedHashSet<Int>, Function1<Set<Boolean>, MutableMap<Pair<String, Char>, Kla2>>>
2021-03-12 07:59:21,491 [main:302] - generating value of type = Pair<LinkedHashSet<Int>, Function1<Set<Boolean>, MutableMap<Pair<String, Char>, Kla2>>> false depth = 0
2021-03-12 07:59:21,715 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: LinkedHashSet<Int>, second: Function1<Set<Boolean>, MutableMap<Pair<String, Char>, Kla2>>): Pair<LinkedHashSet<Int>, Function1<Set<Boolean>, MutableMap<Pair<String, Char>, Kla2>>> = TODO()
2021-03-12 07:59:21,726 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: LinkedHashSet<Int>, second: Function1<Set<Boolean>, MutableMap<Pair<String, Char>, Kla2>>): Pair<LinkedHashSet<Int>, Function1<Set<Boolean>, MutableMap<Pair<String, Char>, Kla2>>> = TODO()
2021-03-12 07:59:21,951 [main:302] - generating value of type = LinkedHashSet<Int> false depth = 3
2021-03-12 07:59:22,172 [main:43] - GENERATING CALL OF fun <T> linkedSetOf(elements: Int): LkedHashSet<Int> = TODO()
2021-03-12 07:59:22,183 [main:61] - WITHOUT TYPE PARAMS = fun <T> linkedSetOf(elements: Int): LkedHashSet<Int> = TODO()
2021-03-12 07:59:22,405 [main:302] - generating value of type = Int true depth = 6
2021-03-12 07:59:22,414 [main:95] - GENERATED = linkedSetOf<Int>(1864511803)
2021-03-12 07:59:22,415 [main:302] - generating value of type = Function1<Set<Boolean>, MutableMap<Pair<String, Char>, Kla2>> false depth = 3
2021-03-12 07:59:22,423 [main:302] - generating value of type = MutableMap<Pair<String, Char>, Kla2> false depth = 4
2021-03-12 07:59:22,642 [main:43] - GENERATING CALL OF fun <K, V> LinkedHashMap(): MutableMap<Pair<String, Char>, Kla2> = TODO()
2021-03-12 07:59:22,653 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> LinkedHashMap(): MutableMap<Pair<String, Char>, Kla2> = TODO()
2021-03-12 07:59:22,909 [main:95] - GENERATED = LinkedHashMap<Pair<String, Char>, Kla2>()
2021-03-12 07:59:22,909 [main:95] - GENERATED = Pair<LinkedHashSet<Int>, Function1<Set<Boolean>, MutableMap<Pair<String, Char>, Kla2>>>(linkedSetOf<Int>(1864511803), {a: Set<Boolean> -> LinkedHashMap<Pair<String, Char>, Kla2>()})
2021-03-12 07:59:22,938 [main:106] - GETTING String from UByte
2021-03-12 07:59:22,959 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline operator fun div(other: kotlin.UByte): kotlin.UInt defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@364b9340], @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.UInt.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3a53e1de]]
2021-03-12 07:59:22,959 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun div(other: kotlin.UByte): kotlin.UInt defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@364b9340]
2021-03-12 07:59:22,959 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.UInt.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3a53e1de]
2021-03-12 07:59:22,959 [main:117] - GENERATED CALL = (5.toUByte()).div(5.toUByte()).toString((f).next())
2021-03-12 07:59:22,959 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toShort(): kotlin.Short defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@6d92d846], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 07:59:22,959 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toShort(): kotlin.Short defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@6d92d846]
2021-03-12 07:59:22,959 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:59:22,960 [main:117] - GENERATED CALL = (5.toUByte()).toShort().toString(Foo(1397637829, {a: Int -> -710498597}).state)
2021-03-12 07:59:22,960 [main:113] - Case = [@kotlin.internal.InlineOnly public open inline fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@5d0b66cc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:59:22,960 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public open inline fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@5d0b66cc]
2021-03-12 07:59:22,960 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:59:22,960 [main:117] - GENERATED CALL = (5.toUByte()).compareTo(5.toUByte()).toString((f).next())
2021-03-12 07:59:22,960 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@46fd2c0e]]
2021-03-12 07:59:22,960 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@46fd2c0e]
2021-03-12 07:59:22,961 [main:117] - GENERATED CALL = (5.toUByte()).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())
2021-03-12 07:59:22,961 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@f9632ac], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:59:22,961 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@f9632ac]
2021-03-12 07:59:22,961 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:59:22,961 [main:117] - GENERATED CALL = (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next())
2021-03-12 07:59:22,961 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toUShort(): kotlin.UShort defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@6f378f77], @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShort.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7a750e9d]]
2021-03-12 07:59:22,961 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toUShort(): kotlin.UShort defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@6f378f77]
2021-03-12 07:59:22,961 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShort.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7a750e9d]
2021-03-12 07:59:23,168 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:59:23,177 [main:117] - GENERATED CALL = (5.toUByte()).toUShort().toString(1332827269)
2021-03-12 07:59:23,178 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toLong(): kotlin.Long defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@11039eb9], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:59:23,178 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toLong(): kotlin.Long defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@11039eb9]
2021-03-12 07:59:23,178 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:59:23,385 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:59:23,394 [main:117] - GENERATED CALL = (5.toUByte()).toLong().toString(1072973447)
2021-03-12 07:59:23,394 [main:114] - replacement of method of type String is (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next())
2021-03-12 07:59:23,600 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:59:23,601 [main:66] - Compilation checking started
2021-03-12 07:59:24,517 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = true
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:24,521 [main:107] - replacing (true, Boolean)
2021-03-12 07:59:24,521 [main:50] - replacing true Boolean
2021-03-12 07:59:24,521 [main:54] - Getting value of type Boolean
2021-03-12 07:59:24,731 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:59:24,740 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 07:59:24,740 [main:61] - GENERATED IS CALL =false
2021-03-12 07:59:24,758 [main:67] - randomType = Boolean
2021-03-12 07:59:24,968 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:59:24,985 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:59:25,194 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:59:25,203 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:59:25,412 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:59:25,412 [main:78] - Generated call from random type = (false).compareTo(true).equals("zyuue")
2021-03-12 07:59:25,413 [main:106] - GETTING Boolean from Function1<Int, Int>
2021-03-12 07:59:25,422 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 07:59:25,422 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:59:25,632 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:59:25,632 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 07:59:25,632 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).f).equals("xbcgt").not()
2021-03-12 07:59:25,632 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 07:59:25,632 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:59:25,842 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:59:25,842 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:59:26,052 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:59:26,061 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).f).equals("vaulu").or(true)
2021-03-12 07:59:26,061 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@206509a5], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 07:59:26,061 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@206509a5]
2021-03-12 07:59:26,061 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 07:59:26,291 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:59:26,291 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).f).invoke((Foo(655341081, {a: Int -> -655341081}).next())).equals("izjod")
2021-03-12 07:59:26,291 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]]
2021-03-12 07:59:26,291 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:59:26,501 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:59:26,502 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).f).equals("ympbp")
2021-03-12 07:59:26,502 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 07:59:26,502 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:59:26,711 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:59:26,711 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 07:59:26,921 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:59:26,930 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).f).equals("ejrzf").xor(false)
2021-03-12 07:59:26,930 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 07:59:26,931 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:59:27,139 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:59:27,140 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 07:59:27,348 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:59:27,349 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).f).equals("odfov").equals("spiyd")
2021-03-12 07:59:27,349 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 07:59:27,349 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Function1[DeserializedSimpleFunctionDescriptor@134323ec]
2021-03-12 07:59:27,557 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:59:27,557 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 07:59:27,557 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
2021-03-12 07:59:27,557 [main:114] - replacement of true of type Boolean is (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
2021-03-12 07:59:27,764 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:59:27,765 [main:66] - Compilation checking started
2021-03-12 07:59:28,670 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:28,674 [main:107] - replacing (resume("OK"), Unit?)
2021-03-12 07:59:28,675 [main:50] - replacing resume("OK") Unit?
2021-03-12 07:59:28,675 [main:54] - Getting value of type Unit?
2021-03-12 07:59:28,890 [main:302] - generating value of type = Unit false depth = 0
2021-03-12 07:59:29,112 [main:43] - GENERATING CALL OF fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 07:59:29,123 [main:61] - WITHOUT TYPE PARAMS = fun require(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 07:59:29,914 [main:302] - generating value of type = Boolean true depth = 3
2021-03-12 07:59:29,923 [main:302] - generating value of type = Function0<Any> false depth = 3
2021-03-12 07:59:29,932 [main:302] - generating value of type = Any false depth = 4
2021-03-12 07:59:29,932 [main:95] - GENERATED = require(false, { "cmycd"})
2021-03-12 07:59:29,932 [main:58] - GENERATED VALUE OF TYPE Unit? = require(false, { "cmycd"})
2021-03-12 07:59:29,932 [main:61] - GENERATED IS CALL =true
2021-03-12 07:59:29,968 [main:67] - randomType = Kla12
2021-03-12 07:59:30,179 [main:302] - generating value of type = Kla12 false depth = 0
2021-03-12 07:59:30,188 [main:112] - generating klass Kla12 text = class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 07:59:30,194 [main:149] - GENERATING call of type public final suspend fun fu20(): kotlin.Unit defined in Kla12[SimpleFunctionDescriptorImpl@4bd1813e]
2021-03-12 07:59:30,195 [main:78] - Generated call from random type = (Kla12()).fu20()
2021-03-12 07:59:30,196 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:30,203 [main:106] - GETTING Unit? from Kla2
2021-03-12 07:59:30,209 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:30,209 [main:106] - GETTING Unit? from Float
2021-03-12 07:59:30,236 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:30,237 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:30,245 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:30,246 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:30,247 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:30,276 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:30,277 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:30,278 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:30,278 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:30,279 [main:106] - GETTING Unit? from UByte
2021-03-12 07:59:30,301 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:30,302 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 07:59:30,311 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:30,312 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:30,313 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:30,314 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:30,314 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 07:59:30,315 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:30,316 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:30,317 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:30,318 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:30,318 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:30,319 [main:106] - GETTING Unit? from Kla0
2021-03-12 07:59:30,323 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:30,324 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:30,325 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:30,326 [main:106] - GETTING Unit? from Char
2021-03-12 07:59:30,343 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:30,344 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:30,345 [main:106] - GETTING Unit? from Byte
2021-03-12 07:59:30,374 [main:106] - GETTING Unit? from UByte
2021-03-12 07:59:30,375 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:30,376 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:30,377 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:30,378 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:30,378 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:30,379 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:30,380 [main:106] - GETTING Unit? from UShort
2021-03-12 07:59:30,402 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:30,403 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 07:59:30,404 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:30,405 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:30,405 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 07:59:30,406 [main:106] - GETTING Unit? from Int
2021-03-12 07:59:30,407 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:30,408 [main:106] - GETTING Unit? from Boolean
2021-03-12 07:59:30,409 [main:106] - GETTING Unit? from Kla0
2021-03-12 07:59:30,409 [main:106] - GETTING Unit? from Foo
2021-03-12 07:59:30,409 [main:114] - replacement of resume("OK") of type Unit? is require(false, { "cmycd"})
2021-03-12 07:59:30,618 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:59:30,618 [main:66] - Compilation checking started
2021-03-12 07:59:31,219 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.require(false, { "cmycd"})

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:31,223 [main:107] - replacing ("Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got ", String)
2021-03-12 07:59:31,223 [main:50] - replacing "Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " String
2021-03-12 07:59:31,223 [main:54] - Getting value of type String
2021-03-12 07:59:31,434 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:59:31,443 [main:58] - GENERATED VALUE OF TYPE String = "geedb"
2021-03-12 07:59:31,443 [main:61] - GENERATED IS CALL =false
2021-03-12 07:59:31,989 [main:67] - randomType = Kla3?
2021-03-12 07:59:32,200 [main:302] - generating value of type = Kla3 false depth = 0
2021-03-12 07:59:32,209 [main:112] - generating klass Kla3 text = class Kla3 {
    val prope6 by lazy { -655341081}
}
2021-03-12 07:59:32,214 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:59:32,215 [main:78] - Generated call from random type = (Kla3())?.prope6.toString(Kla3().prope6)
2021-03-12 07:59:32,215 [main:106] - GETTING String from Boolean
2021-03-12 07:59:32,223 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:59:32,223 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:59:32,223 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:59:32,223 [main:117] - GENERATED CALL = (Kla1().fu1()).compareTo(Kla2().fu3()).toString((Foo(-655341081, {a: Int -> 120045518}).state))
2021-03-12 07:59:32,223 [main:114] - replacement of "Wrong state-machine generated: wrong number of overall suspensions. Expected " + (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().minus('') + ", got " of type String is "geedb"
2021-03-12 07:59:32,434 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 07:59:32,435 [main:66] - Compilation checking started
2021-03-12 07:59:33,359 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:33,362 [main:107] - replacing (prope11, String)
2021-03-12 07:59:33,363 [main:50] - replacing prope11 String
2021-03-12 07:59:33,363 [main:54] - Getting value of type String
2021-03-12 07:59:33,577 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:59:33,588 [main:58] - GENERATED VALUE OF TYPE String = "xtodu"
2021-03-12 07:59:33,588 [main:61] - GENERATED IS CALL =false
2021-03-12 07:59:33,870 [main:67] - randomType = Double?
2021-03-12 07:59:34,081 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:59:34,119 [main:149] - GENERATING call of type @kotlin.Deprecated public open fun toByte(): kotlin.Byte defined in kotlin.Double[DeserializedSimpleFunctionDescriptor@6effce89]
2021-03-12 07:59:34,119 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:59:34,329 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:59:34,338 [main:78] - Generated call from random type = (0.8937719037436361)?.toByte().toString(-499936844)
2021-03-12 07:59:34,338 [main:114] - replacement of prope11 of type String is (0.8937719037436361)?.toByte().toString(-499936844)
2021-03-12 07:59:34,548 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:59:34,548 [main:66] - Compilation checking started
2021-03-12 07:59:35,151 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        (0.8937719037436361)?.toByte().toString(-499936844) = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = "\n")) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:35,155 [main:107] - replacing ("\n", String)
2021-03-12 07:59:35,156 [main:50] - replacing "\n" String
2021-03-12 07:59:35,156 [main:54] - Getting value of type String
2021-03-12 07:59:35,367 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:59:35,376 [main:58] - GENERATED VALUE OF TYPE String = "sirzg"
2021-03-12 07:59:35,376 [main:61] - GENERATED IS CALL =false
2021-03-12 07:59:35,681 [main:67] - randomType = Collection<Kla4>
2021-03-12 07:59:35,682 [main:106] - GETTING String from Foo
2021-03-12 07:59:35,689 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:59:35,689 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338]
2021-03-12 07:59:35,689 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:59:35,690 [main:117] - GENERATED CALL = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state)
2021-03-12 07:59:35,690 [main:114] - replacement of "\n" of type String is ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state)
2021-03-12 07:59:35,901 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:59:35,901 [main:66] - Compilation checking started
2021-03-12 07:59:36,859 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:36,863 [main:107] - replacing (prope15, Function0<Unit>)
2021-03-12 07:59:36,864 [main:50] - replacing prope15 Function0<Unit>
2021-03-12 07:59:36,864 [main:54] - Getting value of type Function0<Unit>
2021-03-12 07:59:37,084 [main:302] - generating value of type = Function0<Unit> false depth = 0
2021-03-12 07:59:37,094 [main:302] - generating value of type = Unit false depth = 1
2021-03-12 07:59:37,318 [main:43] - GENERATING CALL OF fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 07:59:37,329 [main:61] - WITHOUT TYPE PARAMS = fun print(message: kotlin.Any?): Unit = TODO()
2021-03-12 07:59:37,828 [main:302] - generating value of type = Any false depth = 4
2021-03-12 07:59:37,828 [main:95] - GENERATED = print("kzxil")
2021-03-12 07:59:37,828 [main:58] - GENERATED VALUE OF TYPE Function0<Unit> = { print("kzxil")}
2021-03-12 07:59:37,828 [main:61] - GENERATED IS CALL =false
2021-03-12 07:59:37,848 [main:67] - randomType = Double
2021-03-12 07:59:38,068 [main:302] - generating value of type = Double true depth = 0
2021-03-12 07:59:38,106 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:38,136 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:38,137 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:38,145 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:38,146 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:38,154 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:38,155 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:38,156 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:38,157 [main:106] - GETTING Function0<Unit> from Char
2021-03-12 07:59:38,174 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:38,175 [main:106] - GETTING Function0<Unit> from Kla0
2021-03-12 07:59:38,179 [main:106] - GETTING Function0<Unit> from Byte
2021-03-12 07:59:38,208 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:38,209 [main:106] - GETTING Function0<Unit> from Float
2021-03-12 07:59:38,236 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:38,237 [main:106] - GETTING Function0<Unit> from Kla2
2021-03-12 07:59:38,243 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:38,244 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:59:38,253 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:59:38,254 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:38,255 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:38,256 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:38,257 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:38,258 [main:106] - GETTING Function0<Unit> from Kla0
2021-03-12 07:59:38,259 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:38,260 [main:106] - GETTING Function0<Unit> from UShort
2021-03-12 07:59:38,282 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:38,283 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:38,284 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:38,285 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:38,286 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:38,287 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:38,288 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:38,288 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:38,289 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:38,290 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:38,291 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:38,292 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:38,293 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:38,294 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:38,295 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:38,296 [main:106] - GETTING Function0<Unit> from Boolean
2021-03-12 07:59:38,297 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:38,298 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:59:38,299 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:38,299 [main:106] - GETTING Function0<Unit> from UByte
2021-03-12 07:59:38,322 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:38,323 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:38,324 [main:106] - GETTING Function0<Unit> from Int
2021-03-12 07:59:38,325 [main:106] - GETTING Function0<Unit> from Function1<Int, Int>
2021-03-12 07:59:38,326 [main:106] - GETTING Function0<Unit> from UByte
2021-03-12 07:59:38,327 [main:106] - GETTING Function0<Unit> from Foo
2021-03-12 07:59:38,327 [main:114] - replacement of prope15 of type Function0<Unit> is { print("kzxil")}
2021-03-12 07:59:38,539 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on LAMBDA_EXPRESSION
2021-03-12 07:59:38,539 [main:66] - Compilation checking started
2021-03-12 07:59:39,163 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.{ print("kzxil")} = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:39,167 [main:107] - replacing (prope11, String)
2021-03-12 07:59:39,167 [main:50] - replacing prope11 String
2021-03-12 07:59:39,167 [main:54] - Getting value of type String
2021-03-12 07:59:39,393 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:59:39,402 [main:58] - GENERATED VALUE OF TYPE String = "kuzin"
2021-03-12 07:59:39,402 [main:61] - GENERATED IS CALL =false
2021-03-12 07:59:39,690 [main:67] - randomType = Char?
2021-03-12 07:59:39,922 [main:302] - generating value of type = Char true depth = 0
2021-03-12 07:59:39,950 [main:149] - GENERATING call of type public final fun toByte(): kotlin.Byte defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@4c28b19f]
2021-03-12 07:59:39,950 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:59:39,951 [main:78] - Generated call from random type = ('')?.toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next())
2021-03-12 07:59:39,951 [main:106] - GETTING String from UByte
2021-03-12 07:59:39,972 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@f9632ac], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:59:39,972 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toByte(): kotlin.Byte defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@f9632ac]
2021-03-12 07:59:39,972 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:59:39,972 [main:117] - GENERATED CALL = ((5.toUByte())).toByte().toString(Foo(416482559, {a: Int -> 23}).state)
2021-03-12 07:59:39,972 [main:113] - Case = [@kotlin.internal.InlineOnly public open inline fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@5d0b66cc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:59:39,972 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public open inline fun compareTo(other: kotlin.UByte): kotlin.Int defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@5d0b66cc]
2021-03-12 07:59:39,972 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:59:39,973 [main:117] - GENERATED CALL = ((5.toUByte())).compareTo(5.toUByte()).toString(Foo(1397637829, {a: Int -> -710498597}).state)
2021-03-12 07:59:39,973 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toLong(): kotlin.Long defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@11039eb9], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:59:39,973 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toLong(): kotlin.Long defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@11039eb9]
2021-03-12 07:59:39,973 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:59:40,185 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:59:40,194 [main:117] - GENERATED CALL = ((5.toUByte())).toLong().toString(-358585539)
2021-03-12 07:59:40,194 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@46fd2c0e]]
2021-03-12 07:59:40,194 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.UByte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@46fd2c0e]
2021-03-12 07:59:40,195 [main:117] - GENERATED CALL = ((5.toUByte())).toString(Kla3().prope6)
2021-03-12 07:59:40,195 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline operator fun div(other: kotlin.UByte): kotlin.UInt defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@364b9340], @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.UInt.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3a53e1de]]
2021-03-12 07:59:40,195 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun div(other: kotlin.UByte): kotlin.UInt defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@364b9340]
2021-03-12 07:59:40,405 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 07:59:40,415 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.UInt.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3a53e1de]
2021-03-12 07:59:40,415 [main:117] - GENERATED CALL = ((5.toUByte())).div(67.toUByte()).toString((Foo(-655341081, {a: Int -> 120045518}).state))
2021-03-12 07:59:40,415 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toShort(): kotlin.Short defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@6d92d846], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 07:59:40,415 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toShort(): kotlin.Short defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@6d92d846]
2021-03-12 07:59:40,415 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 07:59:40,416 [main:117] - GENERATED CALL = ((5.toUByte())).toShort().toString((Foo(416482559, {a: Int -> 23}).state))
2021-03-12 07:59:40,416 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toUShort(): kotlin.UShort defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@6f378f77], @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShort.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7a750e9d]]
2021-03-12 07:59:40,416 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toUShort(): kotlin.UShort defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@6f378f77]
2021-03-12 07:59:40,416 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public fun kotlin.UShort.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@7a750e9d]
2021-03-12 07:59:40,416 [main:117] - GENERATED CALL = ((5.toUByte())).toUShort().toString((f).next())
2021-03-12 07:59:40,416 [main:114] - replacement of prope11 of type String is ('')?.toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next())
2021-03-12 07:59:40,627 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:59:40,627 [main:66] - Compilation checking started
2021-03-12 07:59:41,267 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        ('')?.toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:41,271 [main:107] - replacing (suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}, Ty0)
2021-03-12 07:59:41,271 [main:50] - replacing suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
} Ty0
2021-03-12 07:59:41,271 [main:54] - Getting value of type Ty0
2021-03-12 07:59:41,484 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 07:59:41,496 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 07:59:41,515 [main:67] - randomType = Byte
2021-03-12 07:59:41,729 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 07:59:41,769 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:41,797 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:41,798 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:41,798 [main:106] - GETTING Ty0 from UByte
2021-03-12 07:59:41,820 [main:106] - GETTING Ty0 from UShort
2021-03-12 07:59:41,841 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:41,848 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:59:41,857 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:41,858 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:41,865 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:41,866 [main:106] - GETTING Ty0 from Char
2021-03-12 07:59:41,882 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:41,883 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:59:41,883 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:41,884 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:41,885 [main:106] - GETTING Ty0 from UByte
2021-03-12 07:59:41,885 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:41,886 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:41,886 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:41,887 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:41,888 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:41,888 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:41,889 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:59:41,889 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:41,890 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:41,890 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:41,891 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:41,892 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:41,892 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:41,893 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:41,893 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:41,894 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 07:59:41,894 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:41,895 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:41,896 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:41,896 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:41,897 [main:106] - GETTING Ty0 from Kla0
2021-03-12 07:59:41,901 [main:106] - GETTING Ty0 from Kla2
2021-03-12 07:59:41,906 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:41,906 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:41,907 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:41,908 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:41,908 [main:106] - GETTING Ty0 from Kla0
2021-03-12 07:59:41,909 [main:106] - GETTING Ty0 from Byte
2021-03-12 07:59:41,938 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:41,939 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:41,940 [main:106] - GETTING Ty0 from Int
2021-03-12 07:59:41,940 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:41,941 [main:106] - GETTING Ty0 from Float
2021-03-12 07:59:41,968 [main:106] - GETTING Ty0 from Foo
2021-03-12 07:59:41,968 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:41,969 [main:106] - GETTING Ty0 from Boolean
2021-03-12 07:59:41,969 [main:111] - Cant find and generate replacement for suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
} type Ty0
2021-03-12 07:59:41,969 [main:107] - replacing (s, String)
2021-03-12 07:59:41,969 [main:50] - replacing s String
2021-03-12 07:59:41,969 [main:54] - Getting value of type String
2021-03-12 07:59:42,181 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:59:42,190 [main:58] - GENERATED VALUE OF TYPE String = "wpyqe"
2021-03-12 07:59:42,190 [main:61] - GENERATED IS CALL =false
2021-03-12 07:59:43,070 [main:67] - randomType = Kla10<ArrayList<Int>>?
2021-03-12 07:59:43,304 [main:302] - generating value of type = Kla10<ArrayList<Int>> false depth = 0
2021-03-12 07:59:43,313 [main:112] - generating klass Kla10 text = abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}
2021-03-12 07:59:44,114 [main:302] - generating value of type = Kla13 false depth = 2
2021-03-12 07:59:44,124 [main:112] - generating klass Kla13 text = object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}
2021-03-12 07:59:44,139 [main:106] - GETTING String from Int
2021-03-12 07:59:44,167 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:59:44,167 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 07:59:44,381 [main:302] - generating value of type = Long true depth = 0
2021-03-12 07:59:44,391 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:59:44,391 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).div(-4394684070874270634).toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 07:59:44,392 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 07:59:44,392 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 07:59:44,392 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 07:59:44,392 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toLong().toString((f).next())
2021-03-12 07:59:44,392 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 07:59:44,392 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:59:44,392 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 07:59:44,392 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().lowercase()
2021-03-12 07:59:44,392 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:59:44,392 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 07:59:44,606 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:59:44,615 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:59:44,615 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).compareTo(-1760745745).toString((f.next()))
2021-03-12 07:59:44,615 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:59:44,615 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 07:59:44,616 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:59:44,827 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:59:44,836 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toInt().toString(1893782551)
2021-03-12 07:59:44,836 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 07:59:44,836 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:59:44,836 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 07:59:45,050 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:59:45,060 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().plus("lrkhf")
2021-03-12 07:59:45,060 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]]
2021-03-12 07:59:45,060 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:59:45,060 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]
2021-03-12 07:59:45,060 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().uppercase()
2021-03-12 07:59:45,060 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 07:59:45,060 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 07:59:45,060 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 07:59:45,061 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next())
2021-03-12 07:59:45,061 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:59:45,061 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:59:45,271 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:59:45,280 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toString(-1087348747)
2021-03-12 07:59:45,280 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 07:59:45,280 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 07:59:45,280 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 07:59:45,281 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).next()).toChar().titlecase()
2021-03-12 07:59:45,281 [main:114] - replacement of s of type String is (Foo(1397637829, {a: Int -> -710498597}).next()).toLong().toString((f).next())
2021-03-12 07:59:45,491 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:59:45,492 [main:66] - Compilation checking started
2021-03-12 07:59:46,101 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().(Foo(1397637829, {a: Int -> -710498597}).next()).toLong().toString((f).next())
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = Kla7().fu13()
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:46,105 [main:107] - replacing (Kla6(), Kla6)
2021-03-12 07:59:46,105 [main:50] - replacing Kla6() Kla6
2021-03-12 07:59:46,106 [main:54] - Getting value of type Kla6
2021-03-12 07:59:46,317 [main:302] - generating value of type = Kla6 false depth = 0
2021-03-12 07:59:46,326 [main:112] - generating klass Kla6 text = class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}
2021-03-12 07:59:46,326 [main:58] - GENERATED VALUE OF TYPE Kla6 = Kla6()
2021-03-12 07:59:46,326 [main:61] - GENERATED IS CALL =true
2021-03-12 07:59:46,364 [main:67] - randomType = Kla11
2021-03-12 07:59:46,576 [main:302] - generating value of type = Kla11 false depth = 0
2021-03-12 07:59:46,585 [main:112] - generating klass Kla11 text = class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}
2021-03-12 07:59:46,591 [main:106] - GETTING Kla6 from Boolean
2021-03-12 07:59:46,618 [main:106] - GETTING Kla6 from Boolean
2021-03-12 07:59:46,619 [main:106] - GETTING Kla6 from Int
2021-03-12 07:59:46,656 [main:106] - GETTING Kla6 from Foo
2021-03-12 07:59:46,663 [main:106] - GETTING Kla6 from Boolean
2021-03-12 07:59:46,664 [main:106] - GETTING Kla6 from Kla0
2021-03-12 07:59:46,668 [main:106] - GETTING Kla6 from Foo
2021-03-12 07:59:46,668 [main:106] - GETTING Kla6 from Boolean
2021-03-12 07:59:46,669 [main:106] - GETTING Kla6 from Foo
2021-03-12 07:59:46,670 [main:106] - GETTING Kla6 from Foo
2021-03-12 07:59:46,670 [main:106] - GETTING Kla6 from Byte
2021-03-12 07:59:46,713 [main:106] - GETTING Kla6 from Char
2021-03-12 07:59:46,739 [main:106] - GETTING Kla6 from Boolean
2021-03-12 07:59:46,740 [main:106] - GETTING Kla6 from Foo
2021-03-12 07:59:46,741 [main:106] - GETTING Kla6 from Foo
2021-03-12 07:59:46,741 [main:106] - GETTING Kla6 from Boolean
2021-03-12 07:59:46,742 [main:106] - GETTING Kla6 from UByte
2021-03-12 07:59:46,778 [main:106] - GETTING Kla6 from Boolean
2021-03-12 07:59:46,779 [main:106] - GETTING Kla6 from Float
2021-03-12 07:59:46,826 [main:106] - GETTING Kla6 from Int
2021-03-12 07:59:46,827 [main:106] - GETTING Kla6 from Int
2021-03-12 07:59:46,828 [main:106] - GETTING Kla6 from Boolean
2021-03-12 07:59:46,828 [main:106] - GETTING Kla6 from Function1<Int, Int>
2021-03-12 07:59:46,843 [main:106] - GETTING Kla6 from Int
2021-03-12 07:59:46,844 [main:106] - GETTING Kla6 from UByte
2021-03-12 07:59:46,845 [main:106] - GETTING Kla6 from Int
2021-03-12 07:59:46,845 [main:106] - GETTING Kla6 from Boolean
2021-03-12 07:59:46,846 [main:106] - GETTING Kla6 from Int
2021-03-12 07:59:46,847 [main:106] - GETTING Kla6 from Boolean
2021-03-12 07:59:46,847 [main:106] - GETTING Kla6 from Boolean
2021-03-12 07:59:46,848 [main:106] - GETTING Kla6 from Int
2021-03-12 07:59:46,849 [main:106] - GETTING Kla6 from Foo
2021-03-12 07:59:46,849 [main:106] - GETTING Kla6 from Function1<Int, Int>
2021-03-12 07:59:46,850 [main:106] - GETTING Kla6 from Function1<Int, Int>
2021-03-12 07:59:46,850 [main:106] - GETTING Kla6 from Int
2021-03-12 07:59:46,851 [main:106] - GETTING Kla6 from UShort
2021-03-12 07:59:46,890 [main:106] - GETTING Kla6 from Foo
2021-03-12 07:59:46,891 [main:106] - GETTING Kla6 from Boolean
2021-03-12 07:59:46,891 [main:106] - GETTING Kla6 from Int
2021-03-12 07:59:46,892 [main:106] - GETTING Kla6 from Int
2021-03-12 07:59:46,893 [main:106] - GETTING Kla6 from Kla0
2021-03-12 07:59:46,893 [main:106] - GETTING Kla6 from Foo
2021-03-12 07:59:46,894 [main:106] - GETTING Kla6 from Boolean
2021-03-12 07:59:46,895 [main:106] - GETTING Kla6 from Boolean
2021-03-12 07:59:46,895 [main:106] - GETTING Kla6 from Int
2021-03-12 07:59:46,896 [main:106] - GETTING Kla6 from Foo
2021-03-12 07:59:46,897 [main:106] - GETTING Kla6 from Int
2021-03-12 07:59:46,897 [main:106] - GETTING Kla6 from Kla2
2021-03-12 07:59:46,907 [main:106] - GETTING Kla6 from Int
2021-03-12 07:59:46,908 [main:106] - GETTING Kla6 from Boolean
2021-03-12 07:59:46,908 [main:106] - GETTING Kla6 from Foo
2021-03-12 07:59:46,909 [main:106] - GETTING Kla6 from Function1<Int, Int>
2021-03-12 07:59:46,909 [main:114] - replacement of Kla6() of type Kla6 is Kla6()
2021-03-12 07:59:47,121 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:59:47,125 [main:107] - replacing (Kla7().fu13(), String)
2021-03-12 07:59:47,126 [main:50] - replacing Kla7().fu13() String
2021-03-12 07:59:47,126 [main:54] - Getting value of type String
2021-03-12 07:59:47,337 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:59:47,346 [main:58] - GENERATED VALUE OF TYPE String = "blkpg"
2021-03-12 07:59:47,346 [main:61] - GENERATED IS CALL =false
2021-03-12 07:59:47,384 [main:67] - randomType = Kla9
2021-03-12 07:59:47,594 [main:302] - generating value of type = Kla9 false depth = 0
2021-03-12 07:59:47,604 [main:112] - generating klass Kla9 text = class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}
2021-03-12 07:59:47,618 [main:149] - GENERATING call of type public fun kotlin.Any?.toString(): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@7d7ab689]
2021-03-12 07:59:47,619 [main:78] - Generated call from random type = (Kla9()).prope11?.toString()!!
2021-03-12 07:59:47,619 [main:106] - GETTING String from Boolean
2021-03-12 07:59:47,627 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:59:47,627 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:59:47,838 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:59:47,847 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:59:48,058 [main:302] - generating value of type = Int true depth = 0
2021-03-12 07:59:48,068 [main:117] - GENERATED CALL = (Kla1().fu4()).compareTo(true).toString(-1121496054)
2021-03-12 07:59:48,068 [main:114] - replacement of Kla7().fu13() of type String is "blkpg"
2021-03-12 07:59:48,278 [main:33] - Trying to replace Element(DOT_QUALIFIED_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 07:59:48,279 [main:66] - Compilation checking started
2021-03-12 07:59:49,191 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = false
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:49,194 [main:107] - replacing (false, Boolean)
2021-03-12 07:59:49,194 [main:50] - replacing false Boolean
2021-03-12 07:59:49,194 [main:54] - Getting value of type Boolean
2021-03-12 07:59:49,405 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 07:59:49,414 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 07:59:49,414 [main:61] - GENERATED IS CALL =false
2021-03-12 07:59:50,336 [main:67] - randomType = Pair<Float, String?>?
2021-03-12 07:59:50,547 [main:302] - generating value of type = Pair<Float, String?> false depth = 0
2021-03-12 07:59:50,771 [main:43] - GENERATING CALL OF fun <A, B> Pair(first: Float, second: String?): Pair<Float, String?> = TODO()
2021-03-12 07:59:50,782 [main:61] - WITHOUT TYPE PARAMS = fun <A, B> Pair(first: Float, second: String?): Pair<Float, String?> = TODO()
2021-03-12 07:59:51,013 [main:302] - generating value of type = Float true depth = 3
2021-03-12 07:59:51,022 [main:302] - generating value of type = String true depth = 3
2021-03-12 07:59:51,031 [main:95] - GENERATED = Pair<Float, String?>(0.4163946f, "eegmu")
2021-03-12 07:59:51,046 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor@31830443]
2021-03-12 07:59:51,258 [main:302] - generating value of type = Any false depth = 0
2021-03-12 07:59:51,258 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 07:59:51,258 [main:78] - Generated call from random type = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
2021-03-12 07:59:51,258 [main:114] - replacement of false of type Boolean is (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
2021-03-12 07:59:51,468 [main:33] - Trying to replace Element(BOOLEAN_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:59:51,468 [main:66] - Compilation checking started
2021-03-12 07:59:52,430 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error("tail-call optimization miss: method at " + it + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:52,434 [main:107] - replacing ("tail-call optimization miss: method at " + it, String)
2021-03-12 07:59:52,434 [main:50] - replacing "tail-call optimization miss: method at " + it String
2021-03-12 07:59:52,434 [main:54] - Getting value of type String
2021-03-12 07:59:52,656 [main:302] - generating value of type = String true depth = 0
2021-03-12 07:59:52,666 [main:58] - GENERATED VALUE OF TYPE String = "texnp"
2021-03-12 07:59:52,666 [main:61] - GENERATED IS CALL =false
2021-03-12 07:59:54,020 [main:67] - randomType = Triple<Kla2, Triple<Kla5, Char, ULong>, ArrayDeque<UShort>>
2021-03-12 07:59:54,233 [main:302] - generating value of type = Triple<Kla2, Triple<Kla5, Char, ULong>, ArrayDeque<UShort>> false depth = 0
2021-03-12 07:59:54,461 [main:43] - GENERATING CALL OF fun <A, B, C> Triple(first: Kla2, second: Triple<Kla5, Char, ULong>, third: ArrayDeque<UShort>): Triple<Kla2, Triple<Kla5, Char, ULong>, ArrayDeque<UShort>> = TODO()
2021-03-12 07:59:54,472 [main:61] - WITHOUT TYPE PARAMS = fun <A, B, C> Triple(first: Kla2, second: Triple<Kla5, Char, ULong>, third: ArrayDeque<UShort>): Triple<Kla2, Triple<Kla5, Char, ULong>, ArrayDeque<UShort>> = TODO()
2021-03-12 07:59:54,704 [main:302] - generating value of type = Kla2 false depth = 3
2021-03-12 07:59:54,714 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 07:59:54,714 [main:302] - generating value of type = Triple<Kla5, Char, ULong> false depth = 3
2021-03-12 07:59:54,941 [main:43] - GENERATING CALL OF fun <A, B, C> Triple(first: Kla5, second: Char, third: ULong): Triple<Kla5, Char, ULong> = TODO()
2021-03-12 07:59:54,952 [main:61] - WITHOUT TYPE PARAMS = fun <A, B, C> Triple(first: Kla5, second: Char, third: ULong): Triple<Kla5, Char, ULong> = TODO()
2021-03-12 07:59:55,186 [main:302] - generating value of type = Kla5 false depth = 6
2021-03-12 07:59:55,195 [main:112] - generating klass Kla5 text = class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}
2021-03-12 07:59:55,406 [main:194] - Type params = []
2021-03-12 07:59:55,618 [main:302] - generating value of type = Char true depth = 6
2021-03-12 07:59:55,627 [main:302] - generating value of type = ULong true depth = 6
2021-03-12 07:59:55,637 [main:95] - GENERATED = Triple<Kla5, Char, ULong>(Kla5(), '', 268807931265781491.toULong())
2021-03-12 07:59:55,637 [main:302] - generating value of type = ArrayDeque<UShort> false depth = 3
2021-03-12 07:59:55,862 [main:43] - GENERATING CALL OF fun <E> ArrayDeque(initialCapacity: kotlin.Int): ArrayDeque<UShort> = TODO()
2021-03-12 07:59:55,874 [main:61] - WITHOUT TYPE PARAMS = fun <E> ArrayDeque(initialCapacity: kotlin.Int): ArrayDeque<UShort> = TODO()
2021-03-12 07:59:56,374 [main:302] - generating value of type = Int true depth = 6
2021-03-12 07:59:56,384 [main:95] - GENERATED = ArrayDeque<UShort>(-527478102)
2021-03-12 07:59:56,384 [main:95] - GENERATED = Triple<Kla2, Triple<Kla5, Char, ULong>, ArrayDeque<UShort>>(Kla2(), Triple<Kla5, Char, ULong>(Kla5(), '', 268807931265781491.toULong()), ArrayDeque<UShort>(-527478102))
2021-03-12 07:59:56,409 [main:106] - GETTING String from Boolean
2021-03-12 07:59:56,416 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 07:59:56,416 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 07:59:56,416 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 07:59:56,417 [main:117] - GENERATED CALL = (prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state)
2021-03-12 07:59:56,417 [main:114] - replacement of "tail-call optimization miss: method at " + it of type String is (prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state)
2021-03-12 07:59:56,629 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 07:59:56,629 [main:66] - Compilation checking started
2021-03-12 07:59:57,609 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv())))
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:57,613 [main:107] - replacing (fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()))), Kla4)
2021-03-12 07:59:57,613 [main:50] - replacing fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()))) Kla4
2021-03-12 07:59:57,613 [main:54] - Getting value of type Kla4
2021-03-12 07:59:57,830 [main:302] - generating value of type = Kla4 false depth = 0
2021-03-12 07:59:57,842 [main:112] - generating klass Kla4 text = @Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)
2021-03-12 07:59:58,056 [main:194] - Type params = []
2021-03-12 07:59:58,272 [main:302] - generating value of type = String true depth = 2
2021-03-12 07:59:58,285 [main:58] - GENERATED VALUE OF TYPE Kla4 = Kla4("ocnfy")
2021-03-12 07:59:58,285 [main:61] - GENERATED IS CALL =true
2021-03-12 07:59:58,332 [main:67] - randomType = Kla11
2021-03-12 07:59:58,547 [main:302] - generating value of type = Kla11 false depth = 0
2021-03-12 07:59:58,559 [main:112] - generating klass Kla11 text = class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}
2021-03-12 07:59:58,564 [main:106] - GETTING Kla4 from UByte
2021-03-12 07:59:58,585 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:58,615 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:59:58,624 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:58,632 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:58,632 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:58,633 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:58,633 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:58,641 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:58,641 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:58,642 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:58,642 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:58,643 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:58,643 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:58,644 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:58,645 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:58,645 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:58,646 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:58,646 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:58,647 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:58,647 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:58,648 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:58,649 [main:106] - GETTING Kla4 from Kla0
2021-03-12 07:59:58,652 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:58,653 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:58,654 [main:106] - GETTING Kla4 from Float
2021-03-12 07:59:58,681 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:58,681 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:58,682 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:58,682 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:58,683 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:59:58,683 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:58,684 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:58,685 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:58,685 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:59:58,686 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:58,686 [main:106] - GETTING Kla4 from Char
2021-03-12 07:59:58,704 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:58,704 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:58,705 [main:106] - GETTING Kla4 from Foo
2021-03-12 07:59:58,706 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:58,706 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:58,707 [main:106] - GETTING Kla4 from Byte
2021-03-12 07:59:58,736 [main:106] - GETTING Kla4 from Kla2
2021-03-12 07:59:58,741 [main:106] - GETTING Kla4 from Kla0
2021-03-12 07:59:58,742 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:58,742 [main:106] - GETTING Kla4 from Function1<Int, Int>
2021-03-12 07:59:58,743 [main:106] - GETTING Kla4 from UShort
2021-03-12 07:59:58,764 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:58,765 [main:106] - GETTING Kla4 from Int
2021-03-12 07:59:58,765 [main:106] - GETTING Kla4 from UByte
2021-03-12 07:59:58,766 [main:106] - GETTING Kla4 from Boolean
2021-03-12 07:59:58,766 [main:114] - replacement of fu9(fu10((-30517).toString((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()))) of type Kla4 is Kla4("ocnfy")
2021-03-12 07:59:58,983 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 07:59:58,984 [main:66] - Compilation checking started
2021-03-12 07:59:59,911 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 07:59:59,915 [main:107] - replacing (prope14, Boolean)
2021-03-12 07:59:59,915 [main:50] - replacing prope14 Boolean
2021-03-12 07:59:59,915 [main:54] - Getting value of type Boolean
2021-03-12 08:00:00,131 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:00:00,143 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 08:00:00,143 [main:61] - GENERATED IS CALL =false
2021-03-12 08:00:00,435 [main:67] - randomType = ULong
2021-03-12 08:00:00,674 [main:302] - generating value of type = ULong true depth = 0
2021-03-12 08:00:00,712 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toDouble(): kotlin.Double defined in kotlin.ULong[DeserializedSimpleFunctionDescriptor@4c34a5ba]
2021-03-12 08:00:00,712 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]
2021-03-12 08:00:00,712 [main:78] - Generated call from random type = (8381129047547530670.toULong()).toDouble().isInfinite()
2021-03-12 08:00:00,712 [main:106] - GETTING Boolean from Boolean
2021-03-12 08:00:00,720 [main:113] - Case = [public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 08:00:00,720 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 08:00:00,720 [main:117] - GENERATED CALL = (Kla2().fu2()).xor(Kla2().fu1())
2021-03-12 08:00:00,720 [main:113] - Case = [public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 08:00:00,720 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 08:00:00,721 [main:117] - GENERATED CALL = (Kla2().fu2()).and(Kla2().fu1())
2021-03-12 08:00:00,721 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 08:00:00,721 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 08:00:00,935 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:00,936 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 08:00:00,936 [main:117] - GENERATED CALL = (Kla2().fu2()).equals("vvyzl").not()
2021-03-12 08:00:00,936 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 08:00:00,936 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 08:00:01,149 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:01,150 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 08:00:01,362 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:00:01,374 [main:117] - GENERATED CALL = (Kla2().fu2()).equals("bnkus").or(true)
2021-03-12 08:00:01,374 [main:113] - Case = [public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 08:00:01,374 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 08:00:01,374 [main:117] - GENERATED CALL = (Kla2().fu2()).not()
2021-03-12 08:00:01,375 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 08:00:01,375 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 08:00:01,588 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:01,588 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 08:00:01,589 [main:117] - GENERATED CALL = (Kla2().fu2()).equals("pybru").xor((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy"))
2021-03-12 08:00:01,589 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 08:00:01,589 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 08:00:01,802 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:01,802 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 08:00:01,802 [main:117] - GENERATED CALL = (Kla2().fu2()).equals("hembf").and(Kla1().fu2())
2021-03-12 08:00:01,803 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 08:00:01,803 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:02,015 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:00:02,027 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 08:00:02,243 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:02,243 [main:117] - GENERATED CALL = (Kla2().fu2()).compareTo(true).equals("kzfpx")
2021-03-12 08:00:02,243 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 08:00:02,243 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 08:00:02,459 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:02,459 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 08:00:02,676 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:02,676 [main:117] - GENERATED CALL = (Kla2().fu2()).equals("eifhj").equals("ijtyi")
2021-03-12 08:00:02,676 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 08:00:02,676 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 08:00:02,892 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:02,892 [main:117] - GENERATED CALL = (Kla2().fu2()).equals("hwmip")
2021-03-12 08:00:02,892 [main:114] - replacement of prope14 of type Boolean is (Kla2().fu2()).equals("eifhj").equals("ijtyi")
2021-03-12 08:00:03,107 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:00:03,108 [main:66] - Compilation checking started
2021-03-12 08:00:03,717 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        prope11.exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        (Kla2().fu2()).equals("eifhj").equals("ijtyi") = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:03,722 [main:107] - replacing (prope11, Result<Any?>)
2021-03-12 08:00:03,722 [main:50] - replacing prope11 Result<Any?>
2021-03-12 08:00:03,722 [main:54] - Getting value of type Result<Any?>
2021-03-12 08:00:03,941 [main:302] - generating value of type = Result<Any?> false depth = 0
2021-03-12 08:00:04,192 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 08:00:04,206 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 08:00:04,736 [main:302] - generating value of type = Function0<Any?> false depth = 3
2021-03-12 08:00:04,749 [main:302] - generating value of type = Any false depth = 4
2021-03-12 08:00:04,749 [main:95] - GENERATED = runCatching<Any?>({ "ncjna"})
2021-03-12 08:00:04,749 [main:58] - GENERATED VALUE OF TYPE Result<Any?> = runCatching<Any?>({ "ncjna"})
2021-03-12 08:00:04,749 [main:61] - GENERATED IS CALL =true
2021-03-12 08:00:04,773 [main:67] - randomType = String
2021-03-12 08:00:04,989 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:00:05,019 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:05,049 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:05,050 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:05,051 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:05,061 [main:106] - GETTING Result<Any?> from Function1<Int, Int>
2021-03-12 08:00:05,072 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:05,073 [main:106] - GETTING Result<Any?> from Kla0
2021-03-12 08:00:05,077 [main:106] - GETTING Result<Any?> from UByte
2021-03-12 08:00:05,099 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:05,100 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:05,102 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:05,103 [main:106] - GETTING Result<Any?> from Function1<Int, Int>
2021-03-12 08:00:05,104 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:05,105 [main:106] - GETTING Result<Any?> from Kla2
2021-03-12 08:00:05,112 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:05,120 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:05,121 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:05,122 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:05,123 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:05,125 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:05,126 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:05,127 [main:106] - GETTING Result<Any?> from Char
2021-03-12 08:00:05,148 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:05,149 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:05,150 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:05,152 [main:106] - GETTING Result<Any?> from Function1<Int, Int>
2021-03-12 08:00:05,153 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:05,154 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:05,155 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:05,157 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:05,158 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:05,159 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:05,160 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:05,162 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:05,163 [main:106] - GETTING Result<Any?> from UByte
2021-03-12 08:00:05,164 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:05,165 [main:106] - GETTING Result<Any?> from Float
2021-03-12 08:00:05,214 [main:106] - GETTING Result<Any?> from Byte
2021-03-12 08:00:05,267 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:05,268 [main:106] - GETTING Result<Any?> from Kla0
2021-03-12 08:00:05,269 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:05,270 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:05,272 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:05,273 [main:106] - GETTING Result<Any?> from UShort
2021-03-12 08:00:05,298 [main:106] - GETTING Result<Any?> from Function1<Int, Int>
2021-03-12 08:00:05,299 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:05,300 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:05,301 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:05,302 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:05,304 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:05,305 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:05,306 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:05,306 [main:114] - replacement of prope11 of type Result<Any?> is runCatching<Any?>({ "ncjna"})
2021-03-12 08:00:05,521 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:00:05,521 [main:66] - Compilation checking started
2021-03-12 08:00:06,449 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
runCatching<Any?>({ "ncjna"}).exceptionOrNull()?.let(x)
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:06,453 [main:107] - replacing (runCatching<Any?>({ "ncjna"}).exceptionOrNull()?.let(x), Unit?)
2021-03-12 08:00:06,453 [main:50] - replacing runCatching<Any?>({ "ncjna"}).exceptionOrNull()?.let(x) Unit?
2021-03-12 08:00:06,453 [main:54] - Getting value of type Unit?
2021-03-12 08:00:06,669 [main:58] - GENERATED VALUE OF TYPE Unit? = null
2021-03-12 08:00:06,669 [main:61] - GENERATED IS CALL =false
2021-03-12 08:00:06,979 [main:67] - randomType = Kla7
2021-03-12 08:00:07,195 [main:302] - generating value of type = Kla7 false depth = 0
2021-03-12 08:00:07,207 [main:112] - generating klass Kla7 text = class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}
2021-03-12 08:00:07,215 [main:106] - GETTING Unit? from UByte
2021-03-12 08:00:07,237 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:07,244 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:07,273 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:07,281 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:07,282 [main:106] - GETTING Unit? from Char
2021-03-12 08:00:07,299 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:07,300 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:07,301 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:07,301 [main:106] - GETTING Unit? from Byte
2021-03-12 08:00:07,331 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:07,332 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:07,332 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:07,333 [main:106] - GETTING Unit? from Kla0
2021-03-12 08:00:07,337 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:07,337 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:07,338 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:07,339 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:07,340 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:07,341 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:07,342 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:07,342 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:00:07,353 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:07,354 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:00:07,354 [main:106] - GETTING Unit? from UByte
2021-03-12 08:00:07,355 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:07,356 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:07,357 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:07,358 [main:106] - GETTING Unit? from Float
2021-03-12 08:00:07,404 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:07,405 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:07,406 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:07,407 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:07,408 [main:106] - GETTING Unit? from Kla2
2021-03-12 08:00:07,414 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:07,415 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:07,416 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:07,417 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:07,418 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:07,419 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:07,419 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:07,420 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:07,421 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:07,422 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:07,423 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:07,424 [main:106] - GETTING Unit? from UShort
2021-03-12 08:00:07,446 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:07,447 [main:106] - GETTING Unit? from Kla0
2021-03-12 08:00:07,448 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:07,449 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:07,449 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:00:07,450 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:00:07,450 [main:114] - replacement of runCatching<Any?>({ "ncjna"}).exceptionOrNull()?.let(x) of type Unit? is null
2021-03-12 08:00:07,665 [main:33] - Trying to replace Element(SAFE_ACCESS_EXPRESSION) on Element(NULL)
2021-03-12 08:00:07,665 [main:66] - Compilation checking started
2021-03-12 08:00:08,577 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:08,583 [main:107] - replacing (prope11, Result<Ty0>)
2021-03-12 08:00:08,583 [main:50] - replacing prope11 Result<Ty0>
2021-03-12 08:00:08,583 [main:54] - Getting value of type Result<Ty0>
2021-03-12 08:00:08,801 [main:302] - generating value of type = Result<Ty0> false depth = 0
2021-03-12 08:00:09,032 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 08:00:09,046 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 08:00:09,577 [main:385] - Cant generate call of fun <R> runCatching(block: ()->Ty0): Result<Ty0> = TODO()
2021-03-12 08:00:09,577 [main:58] - GENERATED VALUE OF TYPE Result<Ty0> = 
2021-03-12 08:00:09,627 [main:67] - randomType = Kla9
2021-03-12 08:00:09,849 [main:302] - generating value of type = Kla9 false depth = 0
2021-03-12 08:00:09,862 [main:112] - generating klass Kla9 text = class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}
2021-03-12 08:00:09,877 [main:106] - GETTING Result<Ty0> from Foo
2021-03-12 08:00:09,885 [main:106] - GETTING Result<Ty0> from Kla0
2021-03-12 08:00:09,889 [main:106] - GETTING Result<Ty0> from Function1<Int, Int>
2021-03-12 08:00:09,899 [main:106] - GETTING Result<Ty0> from Foo
2021-03-12 08:00:09,900 [main:106] - GETTING Result<Ty0> from Int
2021-03-12 08:00:09,930 [main:106] - GETTING Result<Ty0> from UShort
2021-03-12 08:00:09,952 [main:106] - GETTING Result<Ty0> from UByte
2021-03-12 08:00:09,973 [main:106] - GETTING Result<Ty0> from Int
2021-03-12 08:00:09,974 [main:106] - GETTING Result<Ty0> from Boolean
2021-03-12 08:00:09,984 [main:106] - GETTING Result<Ty0> from Boolean
2021-03-12 08:00:09,985 [main:106] - GETTING Result<Ty0> from UByte
2021-03-12 08:00:09,986 [main:106] - GETTING Result<Ty0> from Int
2021-03-12 08:00:09,987 [main:106] - GETTING Result<Ty0> from Function1<Int, Int>
2021-03-12 08:00:09,988 [main:106] - GETTING Result<Ty0> from Int
2021-03-12 08:00:09,989 [main:106] - GETTING Result<Ty0> from Foo
2021-03-12 08:00:09,991 [main:106] - GETTING Result<Ty0> from Int
2021-03-12 08:00:09,992 [main:106] - GETTING Result<Ty0> from Function1<Int, Int>
2021-03-12 08:00:09,993 [main:106] - GETTING Result<Ty0> from Int
2021-03-12 08:00:09,994 [main:106] - GETTING Result<Ty0> from Float
2021-03-12 08:00:10,022 [main:106] - GETTING Result<Ty0> from Kla2
2021-03-12 08:00:10,029 [main:106] - GETTING Result<Ty0> from Int
2021-03-12 08:00:10,030 [main:106] - GETTING Result<Ty0> from Foo
2021-03-12 08:00:10,031 [main:106] - GETTING Result<Ty0> from Boolean
2021-03-12 08:00:10,032 [main:106] - GETTING Result<Ty0> from Int
2021-03-12 08:00:10,033 [main:106] - GETTING Result<Ty0> from Kla0
2021-03-12 08:00:10,034 [main:106] - GETTING Result<Ty0> from Int
2021-03-12 08:00:10,035 [main:106] - GETTING Result<Ty0> from Boolean
2021-03-12 08:00:10,036 [main:106] - GETTING Result<Ty0> from Boolean
2021-03-12 08:00:10,038 [main:106] - GETTING Result<Ty0> from Foo
2021-03-12 08:00:10,039 [main:106] - GETTING Result<Ty0> from Function1<Int, Int>
2021-03-12 08:00:10,040 [main:106] - GETTING Result<Ty0> from Boolean
2021-03-12 08:00:10,041 [main:106] - GETTING Result<Ty0> from Boolean
2021-03-12 08:00:10,042 [main:106] - GETTING Result<Ty0> from Int
2021-03-12 08:00:10,043 [main:106] - GETTING Result<Ty0> from Foo
2021-03-12 08:00:10,044 [main:106] - GETTING Result<Ty0> from Boolean
2021-03-12 08:00:10,045 [main:106] - GETTING Result<Ty0> from Boolean
2021-03-12 08:00:10,047 [main:106] - GETTING Result<Ty0> from Foo
2021-03-12 08:00:10,048 [main:106] - GETTING Result<Ty0> from Boolean
2021-03-12 08:00:10,049 [main:106] - GETTING Result<Ty0> from Boolean
2021-03-12 08:00:10,050 [main:106] - GETTING Result<Ty0> from Boolean
2021-03-12 08:00:10,051 [main:106] - GETTING Result<Ty0> from Foo
2021-03-12 08:00:10,052 [main:106] - GETTING Result<Ty0> from Int
2021-03-12 08:00:10,053 [main:106] - GETTING Result<Ty0> from Foo
2021-03-12 08:00:10,054 [main:106] - GETTING Result<Ty0> from Foo
2021-03-12 08:00:10,055 [main:106] - GETTING Result<Ty0> from Byte
2021-03-12 08:00:10,087 [main:106] - GETTING Result<Ty0> from Int
2021-03-12 08:00:10,088 [main:106] - GETTING Result<Ty0> from Foo
2021-03-12 08:00:10,089 [main:106] - GETTING Result<Ty0> from Boolean
2021-03-12 08:00:10,091 [main:106] - GETTING Result<Ty0> from Int
2021-03-12 08:00:10,092 [main:106] - GETTING Result<Ty0> from Boolean
2021-03-12 08:00:10,093 [main:106] - GETTING Result<Ty0> from Boolean
2021-03-12 08:00:10,094 [main:106] - GETTING Result<Ty0> from Char
2021-03-12 08:00:10,111 [main:111] - Cant find and generate replacement for prope11 type Result<Ty0>
2021-03-12 08:00:10,111 [main:107] - replacing ((Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14, Boolean)
2021-03-12 08:00:10,111 [main:50] - replacing (Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14 Boolean
2021-03-12 08:00:10,111 [main:54] - Getting value of type Boolean
2021-03-12 08:00:10,335 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:00:10,347 [main:58] - GENERATED VALUE OF TYPE Boolean = true
2021-03-12 08:00:10,347 [main:61] - GENERATED IS CALL =false
2021-03-12 08:00:10,655 [main:67] - randomType = Kla13
2021-03-12 08:00:10,895 [main:302] - generating value of type = Kla13 false depth = 0
2021-03-12 08:00:10,907 [main:112] - generating klass Kla13 text = object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}
2021-03-12 08:00:10,924 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Kla13[DeserializedSimpleFunctionDescriptor@4ca76513]
2021-03-12 08:00:11,141 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:11,142 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 08:00:11,142 [main:78] - Generated call from random type = (Kla13).equals("zjzbk").or(Kla2().fu4())
2021-03-12 08:00:11,143 [main:106] - GETTING Boolean from Int
2021-03-12 08:00:11,172 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 08:00:11,172 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 08:00:11,395 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:11,395 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 08:00:11,611 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:11,612 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next())).equals("phhsn").equals("aoctn")
2021-03-12 08:00:11,612 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@273e47e2]]
2021-03-12 08:00:11,612 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 08:00:11,612 [main:149] - GENERATING call of type public fun kotlin.Char.isTitleCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@273e47e2]
2021-03-12 08:00:11,612 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next())).toChar().isTitleCase()
2021-03-12 08:00:11,612 [main:113] - Case = [public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f], public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@6970ad8]]
2021-03-12 08:00:11,612 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Double): kotlin.Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@218c547f]
2021-03-12 08:00:11,829 [main:302] - generating value of type = Double true depth = 0
2021-03-12 08:00:11,841 [main:149] - GENERATING call of type public fun kotlin.Double.isNaN(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@6970ad8]
2021-03-12 08:00:11,841 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next())).div(0.5921025499095929).isNaN()
2021-03-12 08:00:11,841 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@48d86ac1]]
2021-03-12 08:00:11,841 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 08:00:11,842 [main:149] - GENERATING call of type public fun kotlin.Char.isSurrogate(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@48d86ac1]
2021-03-12 08:00:11,842 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next())).toChar().isSurrogate()
2021-03-12 08:00:11,842 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 08:00:11,842 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 08:00:12,058 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:12,058 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 08:00:12,059 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next())).equals("rnyky").and(Kla2().fu2())
2021-03-12 08:00:12,059 [main:113] - Case = [public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]]
2021-03-12 08:00:12,059 [main:149] - GENERATING call of type public abstract fun toDouble(): kotlin.Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@7bf1c78]
2021-03-12 08:00:12,059 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]
2021-03-12 08:00:12,059 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next())).toDouble().isInfinite()
2021-03-12 08:00:12,059 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@41df7a0c]]
2021-03-12 08:00:12,059 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 08:00:12,059 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor@41df7a0c]
2021-03-12 08:00:12,274 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:12,275 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next())).toLong().equals("mhppf")
2021-03-12 08:00:12,275 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55530794]]
2021-03-12 08:00:12,275 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 08:00:12,275 [main:149] - GENERATING call of type public fun kotlin.Char.isUpperCase(): kotlin.Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor@55530794]
2021-03-12 08:00:12,275 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next())).toChar().isUpperCase()
2021-03-12 08:00:12,275 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 08:00:12,275 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 08:00:12,492 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:12,492 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 08:00:12,707 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:00:12,720 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next())).equals("rshex").or(false)
2021-03-12 08:00:12,720 [main:113] - Case = [public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.IntRange.contains(element: kotlin.Int?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@2ae1e7e0]]
2021-03-12 08:00:12,720 [main:149] - GENERATING call of type public final operator fun rangeTo(other: kotlin.Byte): kotlin.ranges.IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@40308cf8]
2021-03-12 08:00:12,720 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline operator fun kotlin.ranges.IntRange.contains(element: kotlin.Int?): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@2ae1e7e0]
2021-03-12 08:00:12,943 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next())).rangeTo((Foo(416482559, {a: Int -> 23}).state).toByte()).contains(null)
2021-03-12 08:00:12,943 [main:114] - replacement of (Kla2().fu2()).equals("xmaug").and(Kla1().fu4()) && !prope14 of type Boolean is (Kla13).equals("zjzbk").or(Kla2().fu4())
2021-03-12 08:00:13,160 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:00:13,160 [main:66] - Compilation checking started
2021-03-12 08:00:14,091 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:14,096 [main:107] - replacing (s, String)
2021-03-12 08:00:14,096 [main:50] - replacing s String
2021-03-12 08:00:14,096 [main:54] - Getting value of type String
2021-03-12 08:00:14,316 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:00:14,328 [main:58] - GENERATED VALUE OF TYPE String = "ainjj"
2021-03-12 08:00:14,328 [main:61] - GENERATED IS CALL =false
2021-03-12 08:00:14,685 [main:67] - randomType = Kla9?
2021-03-12 08:00:14,901 [main:302] - generating value of type = Kla9 false depth = 0
2021-03-12 08:00:14,913 [main:112] - generating klass Kla9 text = class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}
2021-03-12 08:00:14,928 [main:149] - GENERATING call of type public fun kotlin.Any?.toString(): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@7d7ab689]
2021-03-12 08:00:14,928 [main:78] - Generated call from random type = (Kla9())?.prope11?.toString()!!
2021-03-12 08:00:14,929 [main:106] - GETTING String from Boolean
2021-03-12 08:00:14,936 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 08:00:14,936 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:14,936 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 08:00:14,936 [main:117] - GENERATED CALL = (Kla2().fu4()).compareTo(Kla1().fu2()).toString(Foo(416482559, {a: Int -> 23}).state)
2021-03-12 08:00:14,936 [main:114] - replacement of s of type String is (Kla9())?.prope11?.toString()!!
2021-03-12 08:00:15,153 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(POSTFIX_EXPRESSION)
2021-03-12 08:00:15,153 [main:66] - Compilation checking started
2021-03-12 08:00:15,772 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").(Kla9())?.prope11?.toString()!!
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = prope11.getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:15,776 [main:107] - replacing (value, Ty0)
2021-03-12 08:00:15,776 [main:50] - replacing value Ty0
2021-03-12 08:00:15,777 [main:54] - Getting value of type Ty0
2021-03-12 08:00:15,997 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 08:00:16,012 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 08:00:16,325 [main:67] - randomType = Kla3
2021-03-12 08:00:16,540 [main:302] - generating value of type = Kla3 false depth = 0
2021-03-12 08:00:16,552 [main:112] - generating klass Kla3 text = class Kla3 {
    val prope6 by lazy { -655341081}
}
2021-03-12 08:00:16,558 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:16,566 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:16,605 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:16,618 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:16,619 [main:106] - GETTING Ty0 from Kla0
2021-03-12 08:00:16,623 [main:106] - GETTING Ty0 from Kla2
2021-03-12 08:00:16,632 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:16,633 [main:106] - GETTING Ty0 from Kla0
2021-03-12 08:00:16,634 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:16,635 [main:106] - GETTING Ty0 from UShort
2021-03-12 08:00:16,670 [main:106] - GETTING Ty0 from Float
2021-03-12 08:00:16,704 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:16,705 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:16,706 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:16,706 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:16,707 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:16,707 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:16,708 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 08:00:16,718 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:16,718 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:16,719 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:16,719 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:16,720 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 08:00:16,721 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:16,721 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:16,722 [main:106] - GETTING Ty0 from UByte
2021-03-12 08:00:16,744 [main:106] - GETTING Ty0 from Byte
2021-03-12 08:00:16,773 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:16,773 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:16,774 [main:106] - GETTING Ty0 from UByte
2021-03-12 08:00:16,774 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:16,775 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:16,776 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:16,776 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:16,777 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 08:00:16,777 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:16,778 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:16,778 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:16,779 [main:106] - GETTING Ty0 from Char
2021-03-12 08:00:16,797 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:16,797 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 08:00:16,798 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:16,798 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:16,799 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:16,800 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:16,800 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:16,801 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:16,801 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:16,802 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:16,802 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:16,803 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:16,804 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:16,804 [main:111] - Cant find and generate replacement for value type Ty0
2021-03-12 08:00:16,804 [main:107] - replacing (prope11, Result<Any?>)
2021-03-12 08:00:16,804 [main:50] - replacing prope11 Result<Any?>
2021-03-12 08:00:16,804 [main:54] - Getting value of type Result<Any?>
2021-03-12 08:00:17,018 [main:302] - generating value of type = Result<Any?> false depth = 0
2021-03-12 08:00:17,247 [main:43] - GENERATING CALL OF fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 08:00:17,261 [main:61] - WITHOUT TYPE PARAMS = fun <R> runCatching(block: ()->Any?): Result<Any?> = TODO()
2021-03-12 08:00:17,804 [main:302] - generating value of type = Function0<Any?> false depth = 3
2021-03-12 08:00:17,816 [main:302] - generating value of type = Any false depth = 4
2021-03-12 08:00:17,816 [main:95] - GENERATED = runCatching<Any?>({ "gfgoz"})
2021-03-12 08:00:17,816 [main:58] - GENERATED VALUE OF TYPE Result<Any?> = runCatching<Any?>({ "gfgoz"})
2021-03-12 08:00:17,816 [main:61] - GENERATED IS CALL =true
2021-03-12 08:00:18,164 [main:67] - randomType = Kla0?
2021-03-12 08:00:18,165 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:18,174 [main:106] - GETTING Result<Any?> from Function1<Int, Int>
2021-03-12 08:00:18,184 [main:106] - GETTING Result<Any?> from Function1<Int, Int>
2021-03-12 08:00:18,185 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:18,194 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:18,224 [main:106] - GETTING Result<Any?> from Kla2
2021-03-12 08:00:18,229 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:18,230 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:18,232 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:18,233 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:18,234 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:18,235 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:18,236 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:18,237 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:18,239 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:18,240 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:18,241 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:18,242 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:18,243 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:18,244 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:18,246 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:18,247 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:18,248 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:18,249 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:18,250 [main:106] - GETTING Result<Any?> from Function1<Int, Int>
2021-03-12 08:00:18,251 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:18,252 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:18,254 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:18,255 [main:106] - GETTING Result<Any?> from Char
2021-03-12 08:00:18,273 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:18,274 [main:106] - GETTING Result<Any?> from Float
2021-03-12 08:00:18,301 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:18,303 [main:106] - GETTING Result<Any?> from Function1<Int, Int>
2021-03-12 08:00:18,304 [main:106] - GETTING Result<Any?> from Byte
2021-03-12 08:00:18,333 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:18,335 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:18,336 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:18,337 [main:106] - GETTING Result<Any?> from UByte
2021-03-12 08:00:18,359 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:18,360 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:18,361 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:18,363 [main:106] - GETTING Result<Any?> from Kla0
2021-03-12 08:00:18,367 [main:106] - GETTING Result<Any?> from Kla0
2021-03-12 08:00:18,368 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:18,369 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:18,370 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:18,371 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:18,373 [main:106] - GETTING Result<Any?> from Int
2021-03-12 08:00:18,374 [main:106] - GETTING Result<Any?> from UShort
2021-03-12 08:00:18,396 [main:106] - GETTING Result<Any?> from Boolean
2021-03-12 08:00:18,398 [main:106] - GETTING Result<Any?> from UByte
2021-03-12 08:00:18,399 [main:106] - GETTING Result<Any?> from Foo
2021-03-12 08:00:18,399 [main:114] - replacement of prope11 of type Result<Any?> is runCatching<Any?>({ "gfgoz"})
2021-03-12 08:00:18,611 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:00:18,612 [main:66] - Compilation checking started
2021-03-12 08:00:19,548 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:19,552 [main:107] - replacing ({
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }, Unit?)
2021-03-12 08:00:19,552 [main:50] - replacing {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    } Unit?
2021-03-12 08:00:19,552 [main:54] - Getting value of type Unit?
2021-03-12 08:00:19,766 [main:302] - generating value of type = Unit false depth = 0
2021-03-12 08:00:19,994 [main:43] - GENERATING CALL OF fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 08:00:20,008 [main:61] - WITHOUT TYPE PARAMS = fun check(value: kotlin.Boolean, lazyMessage: ()->kotlin.Any): Unit = TODO()
2021-03-12 08:00:20,842 [main:302] - generating value of type = Boolean true depth = 3
2021-03-12 08:00:20,854 [main:302] - generating value of type = Function0<Any> false depth = 3
2021-03-12 08:00:20,866 [main:302] - generating value of type = Any false depth = 4
2021-03-12 08:00:20,866 [main:95] - GENERATED = check(true, { "mmplv"})
2021-03-12 08:00:20,866 [main:58] - GENERATED VALUE OF TYPE Unit? = check(true, { "mmplv"})
2021-03-12 08:00:20,866 [main:61] - GENERATED IS CALL =true
2021-03-12 08:00:21,174 [main:67] - randomType = Kla3
2021-03-12 08:00:21,412 [main:302] - generating value of type = Kla3 false depth = 0
2021-03-12 08:00:21,423 [main:112] - generating klass Kla3 text = class Kla3 {
    val prope6 by lazy { -655341081}
}
2021-03-12 08:00:21,429 [main:106] - GETTING Unit? from Kla0
2021-03-12 08:00:21,432 [main:106] - GETTING Unit? from Kla0
2021-03-12 08:00:21,433 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:21,442 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:21,449 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:21,478 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:21,479 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:21,480 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:21,481 [main:106] - GETTING Unit? from Kla2
2021-03-12 08:00:21,486 [main:106] - GETTING Unit? from Byte
2021-03-12 08:00:21,515 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:21,516 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:21,517 [main:106] - GETTING Unit? from UByte
2021-03-12 08:00:21,538 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:21,539 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:00:21,549 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:21,549 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:00:21,550 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:21,551 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:21,552 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:21,553 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:21,554 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:21,554 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:21,555 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:21,556 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:21,557 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:21,558 [main:106] - GETTING Unit? from UShort
2021-03-12 08:00:21,580 [main:106] - GETTING Unit? from UByte
2021-03-12 08:00:21,581 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:21,582 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:21,583 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:21,583 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:21,584 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:21,585 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:21,586 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:00:21,587 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:00:21,587 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:21,588 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:21,589 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:21,590 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:21,591 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:21,591 [main:106] - GETTING Unit? from Int
2021-03-12 08:00:21,592 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:21,593 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:21,594 [main:106] - GETTING Unit? from Float
2021-03-12 08:00:21,623 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:21,624 [main:106] - GETTING Unit? from Char
2021-03-12 08:00:21,641 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:21,642 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:21,643 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:21,643 [main:106] - GETTING Unit? from Foo
2021-03-12 08:00:21,644 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:00:21,644 [main:114] - replacement of {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    } of type Unit? is check(true, { "mmplv"})
2021-03-12 08:00:21,857 [main:33] - Trying to replace BLOCK on Element(CALL_EXPRESSION)
2021-03-12 08:00:21,857 [main:66] - Compilation checking started
2021-03-12 08:00:21,876 [main:71] - Wrong syntax or breaks conditions
2021-03-12 08:00:21,876 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) check(true, { "mmplv"})
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:21,880 [main:107] - replacing (Kla8, Kla14)
2021-03-12 08:00:21,881 [main:50] - replacing Kla8 Kla14
2021-03-12 08:00:21,881 [main:54] - Getting value of type Kla14
2021-03-12 08:00:22,104 [main:302] - generating value of type = Kla14 false depth = 0
2021-03-12 08:00:22,116 [main:112] - generating klass Kla14 text = companion object Kla14 : Kla8()
2021-03-12 08:00:22,116 [main:58] - GENERATED VALUE OF TYPE Kla14 = 
2021-03-12 08:00:22,744 [main:67] - randomType = Array<Kla2>
2021-03-12 08:00:22,960 [main:302] - generating value of type = Array<Kla2> false depth = 0
2021-03-12 08:00:23,192 [main:43] - GENERATING CALL OF fun <T> Array(size: kotlin.Int, init: (kotlin.Int)->Kla2): Array<Kla2> = TODO()
2021-03-12 08:00:23,206 [main:61] - WITHOUT TYPE PARAMS = fun <T> Array(size: kotlin.Int, init: (kotlin.Int)->Kla2): Array<Kla2> = TODO()
2021-03-12 08:00:24,038 [main:302] - generating value of type = Int true depth = 3
2021-03-12 08:00:24,051 [main:302] - generating value of type = Function1<Int, Kla2> false depth = 3
2021-03-12 08:00:24,063 [main:302] - generating value of type = Kla2 false depth = 4
2021-03-12 08:00:24,075 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 08:00:24,075 [main:95] - GENERATED = Array<Kla2>(286265826, {a: Int -> Kla2()})
2021-03-12 08:00:24,086 [main:106] - GETTING Kla14 from Kla0
2021-03-12 08:00:24,089 [main:106] - GETTING Kla14 from Boolean
2021-03-12 08:00:24,097 [main:106] - GETTING Kla14 from Foo
2021-03-12 08:00:24,104 [main:106] - GETTING Kla14 from Int
2021-03-12 08:00:24,133 [main:106] - GETTING Kla14 from Byte
2021-03-12 08:00:24,161 [main:106] - GETTING Kla14 from Foo
2021-03-12 08:00:24,162 [main:106] - GETTING Kla14 from UShort
2021-03-12 08:00:24,182 [main:106] - GETTING Kla14 from Boolean
2021-03-12 08:00:24,183 [main:106] - GETTING Kla14 from Function1<Int, Int>
2021-03-12 08:00:24,192 [main:106] - GETTING Kla14 from Kla0
2021-03-12 08:00:24,193 [main:106] - GETTING Kla14 from Boolean
2021-03-12 08:00:24,193 [main:106] - GETTING Kla14 from Int
2021-03-12 08:00:24,194 [main:106] - GETTING Kla14 from Int
2021-03-12 08:00:24,194 [main:106] - GETTING Kla14 from Int
2021-03-12 08:00:24,195 [main:106] - GETTING Kla14 from Int
2021-03-12 08:00:24,196 [main:106] - GETTING Kla14 from Function1<Int, Int>
2021-03-12 08:00:24,196 [main:106] - GETTING Kla14 from Boolean
2021-03-12 08:00:24,197 [main:106] - GETTING Kla14 from Foo
2021-03-12 08:00:24,197 [main:106] - GETTING Kla14 from Boolean
2021-03-12 08:00:24,198 [main:106] - GETTING Kla14 from Int
2021-03-12 08:00:24,199 [main:106] - GETTING Kla14 from Boolean
2021-03-12 08:00:24,199 [main:106] - GETTING Kla14 from UByte
2021-03-12 08:00:24,221 [main:106] - GETTING Kla14 from Boolean
2021-03-12 08:00:24,222 [main:106] - GETTING Kla14 from Foo
2021-03-12 08:00:24,222 [main:106] - GETTING Kla14 from Foo
2021-03-12 08:00:24,223 [main:106] - GETTING Kla14 from Boolean
2021-03-12 08:00:24,223 [main:106] - GETTING Kla14 from Foo
2021-03-12 08:00:24,224 [main:106] - GETTING Kla14 from Int
2021-03-12 08:00:24,224 [main:106] - GETTING Kla14 from Int
2021-03-12 08:00:24,225 [main:106] - GETTING Kla14 from Boolean
2021-03-12 08:00:24,226 [main:106] - GETTING Kla14 from Float
2021-03-12 08:00:24,253 [main:106] - GETTING Kla14 from Function1<Int, Int>
2021-03-12 08:00:24,253 [main:106] - GETTING Kla14 from Boolean
2021-03-12 08:00:24,254 [main:106] - GETTING Kla14 from Boolean
2021-03-12 08:00:24,255 [main:106] - GETTING Kla14 from Foo
2021-03-12 08:00:24,255 [main:106] - GETTING Kla14 from UByte
2021-03-12 08:00:24,256 [main:106] - GETTING Kla14 from Int
2021-03-12 08:00:24,256 [main:106] - GETTING Kla14 from Boolean
2021-03-12 08:00:24,257 [main:106] - GETTING Kla14 from Int
2021-03-12 08:00:24,258 [main:106] - GETTING Kla14 from Foo
2021-03-12 08:00:24,258 [main:106] - GETTING Kla14 from Char
2021-03-12 08:00:24,275 [main:106] - GETTING Kla14 from Int
2021-03-12 08:00:24,276 [main:106] - GETTING Kla14 from Foo
2021-03-12 08:00:24,277 [main:106] - GETTING Kla14 from Function1<Int, Int>
2021-03-12 08:00:24,277 [main:106] - GETTING Kla14 from Boolean
2021-03-12 08:00:24,278 [main:106] - GETTING Kla14 from Boolean
2021-03-12 08:00:24,278 [main:106] - GETTING Kla14 from Boolean
2021-03-12 08:00:24,279 [main:106] - GETTING Kla14 from Int
2021-03-12 08:00:24,280 [main:106] - GETTING Kla14 from Foo
2021-03-12 08:00:24,280 [main:106] - GETTING Kla14 from Int
2021-03-12 08:00:24,281 [main:106] - GETTING Kla14 from Foo
2021-03-12 08:00:24,281 [main:106] - GETTING Kla14 from Kla2
2021-03-12 08:00:24,286 [main:111] - Cant find and generate replacement for Kla8 type Kla14
2021-03-12 08:00:24,287 [main:107] - replacing (prope11.getOrThrow(), Ty0)
2021-03-12 08:00:24,287 [main:50] - replacing prope11.getOrThrow() Ty0
2021-03-12 08:00:24,287 [main:54] - Getting value of type Ty0
2021-03-12 08:00:24,524 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 08:00:24,539 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 08:00:24,564 [main:67] - randomType = Int
2021-03-12 08:00:24,781 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:24,823 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:24,852 [main:106] - GETTING Ty0 from Kla0
2021-03-12 08:00:24,855 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:24,862 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:24,870 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 08:00:24,879 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:24,879 [main:106] - GETTING Ty0 from Float
2021-03-12 08:00:24,906 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:24,907 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:24,907 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:24,908 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:24,908 [main:106] - GETTING Ty0 from UShort
2021-03-12 08:00:24,930 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 08:00:24,931 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:24,931 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:24,932 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:24,933 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:24,933 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:24,934 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:24,934 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:24,935 [main:106] - GETTING Ty0 from Char
2021-03-12 08:00:24,952 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:24,953 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:24,953 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:24,954 [main:106] - GETTING Ty0 from Kla0
2021-03-12 08:00:24,955 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:24,955 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:24,956 [main:106] - GETTING Ty0 from Byte
2021-03-12 08:00:24,985 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:24,986 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:24,986 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:24,987 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 08:00:24,988 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:24,988 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 08:00:24,989 [main:106] - GETTING Ty0 from UByte
2021-03-12 08:00:25,011 [main:106] - GETTING Ty0 from UByte
2021-03-12 08:00:25,011 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:25,015 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:25,016 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:25,016 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:25,017 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:25,018 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:25,018 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:25,019 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:00:25,019 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:25,020 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:25,020 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:25,021 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:25,022 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:25,022 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:00:25,023 [main:106] - GETTING Ty0 from Kla2
2021-03-12 08:00:25,029 [main:106] - GETTING Ty0 from Int
2021-03-12 08:00:25,029 [main:111] - Cant find and generate replacement for prope11.getOrThrow() type Ty0
2021-03-12 08:00:25,029 [main:107] - replacing (prope13, Int)
2021-03-12 08:00:25,029 [main:50] - replacing prope13 Int
2021-03-12 08:00:25,029 [main:54] - Getting value of type Int
2021-03-12 08:00:25,247 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:25,259 [main:58] - GENERATED VALUE OF TYPE Int = 1749178943
2021-03-12 08:00:25,259 [main:61] - GENERATED IS CALL =false
2021-03-12 08:00:25,284 [main:67] - randomType = String
2021-03-12 08:00:25,500 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:00:25,529 [main:149] - GENERATING call of type public open fun subSequence(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.CharSequence defined in kotlin.String[DeserializedSimpleFunctionDescriptor@72dc7ea1]
2021-03-12 08:00:25,746 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:25,975 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:25,987 [main:149] - GENERATING call of type public inline fun kotlin.CharSequence.indexOfLast(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor@269fc5df]
2021-03-12 08:00:26,205 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 08:00:26,217 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 08:00:26,229 [main:78] - Generated call from random type = ("kaxqs").subSequence(97348836, 245494500).indexOfLast({a: Char -> true})
2021-03-12 08:00:26,230 [main:106] - GETTING Int from Foo
2021-03-12 08:00:26,237 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338], @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@7921f7e4]]
2021-03-12 08:00:26,237 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338]
2021-03-12 08:00:26,237 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental @kotlin.internal.InlineOnly public inline fun kotlin.Int.countLeadingZeroBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@7921f7e4]
2021-03-12 08:00:26,238 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> 655341081})).next().countLeadingZeroBits()
2021-03-12 08:00:26,238 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@206be60b]]
2021-03-12 08:00:26,238 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338]
2021-03-12 08:00:26,238 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@206be60b]
2021-03-12 08:00:26,238 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> 655341081})).next().rotateRight((f).next())
2021-03-12 08:00:26,238 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338], public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@63d279b5]]
2021-03-12 08:00:26,238 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338]
2021-03-12 08:00:26,238 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@63d279b5]
2021-03-12 08:00:26,238 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> 655341081})).next().and(Foo(416482559, {a: Int -> 23}).state)
2021-03-12 08:00:26,238 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338], public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@75eb3fad]]
2021-03-12 08:00:26,239 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338]
2021-03-12 08:00:26,239 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@75eb3fad]
2021-03-12 08:00:26,239 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> 655341081})).next().inc()
2021-03-12 08:00:26,239 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338], public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16107de0]]
2021-03-12 08:00:26,239 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338]
2021-03-12 08:00:26,239 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16107de0]
2021-03-12 08:00:26,239 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> 655341081})).next().toInt()
2021-03-12 08:00:26,239 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@50acbd67], public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]]
2021-03-12 08:00:26,239 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in Foo[DeserializedSimpleFunctionDescriptor@50acbd67]
2021-03-12 08:00:26,455 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:26,456 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:26,456 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> 655341081})).equals("jfdux").compareTo(Kla2().fu1())
2021-03-12 08:00:26,456 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@35d0f108]]
2021-03-12 08:00:26,456 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338]
2021-03-12 08:00:26,456 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@35d0f108]
2021-03-12 08:00:26,456 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> 655341081})).next().unaryPlus()
2021-03-12 08:00:26,456 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338], public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@77d252d6]]
2021-03-12 08:00:26,456 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338]
2021-03-12 08:00:26,456 [main:149] - GENERATING call of type public final infix fun shr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@77d252d6]
2021-03-12 08:00:26,457 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> 655341081})).next().shr((f).next())
2021-03-12 08:00:26,457 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338], public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fd6caab]]
2021-03-12 08:00:26,457 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338]
2021-03-12 08:00:26,457 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fd6caab]
2021-03-12 08:00:26,457 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> 655341081})).next().or((f).next())
2021-03-12 08:00:26,457 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public val kotlin.Int.absoluteValue: kotlin.Int defined in kotlin.math[DeserializedPropertyDescriptor@918d98b]]
2021-03-12 08:00:26,457 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338]
2021-03-12 08:00:26,457 [main:117] - GENERATED CALL = (Foo(655341081, {a: Int -> 655341081})).next().absoluteValue
2021-03-12 08:00:26,457 [main:114] - replacement of prope13 of type Int is (Foo(655341081, {a: Int -> 655341081})).next().toInt()
2021-03-12 08:00:26,674 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:00:26,674 [main:66] - Compilation checking started
2021-03-12 08:00:27,286 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
(Foo(655341081, {a: Int -> 655341081})).next().toInt() = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:27,290 [main:107] - replacing (getOrThrow(), Any?)
2021-03-12 08:00:27,290 [main:50] - replacing getOrThrow() Any?
2021-03-12 08:00:27,291 [main:54] - Getting value of type Any?
2021-03-12 08:00:27,508 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:27,508 [main:58] - GENERATED VALUE OF TYPE Any? = "wbpnu"
2021-03-12 08:00:27,508 [main:61] - GENERATED IS CALL =false
2021-03-12 08:00:28,142 [main:67] - randomType = LinkedHashSet<Short?>
2021-03-12 08:00:28,361 [main:302] - generating value of type = LinkedHashSet<Short?> false depth = 0
2021-03-12 08:00:28,594 [main:43] - GENERATING CALL OF fun <T> linkedSetOf(elements: Short?): LkedHashSet<Short?> = TODO()
2021-03-12 08:00:28,609 [main:61] - WITHOUT TYPE PARAMS = fun <T> linkedSetOf(elements: Short?): LkedHashSet<Short?> = TODO()
2021-03-12 08:00:28,846 [main:302] - generating value of type = Short true depth = 3
2021-03-12 08:00:28,858 [main:95] - GENERATED = linkedSetOf<Short?>(-7341)
2021-03-12 08:00:28,978 [main:149] - GENERATING call of type @kotlin.js.JsName protected open fun toArray(): kotlin.Array<kotlin.Any?> defined in kotlin.collections.LinkedHashSet[DeserializedSimpleFunctionDescriptor@77fee99f]
2021-03-12 08:00:28,979 [main:149] - GENERATING call of type public final operator fun get(index: kotlin.Int): kotlin.Any? defined in kotlin.Array[DeserializedSimpleFunctionDescriptor@10ebd94a]
2021-03-12 08:00:28,979 [main:78] - Generated call from random type = (linkedSetOf<Short?>(-7341)).toArray().get(f.next())
2021-03-12 08:00:28,980 [main:106] - GETTING Any? from Kla0
2021-03-12 08:00:28,984 [main:106] - GETTING Any? from Boolean
2021-03-12 08:00:28,992 [main:106] - GETTING Any? from Boolean
2021-03-12 08:00:28,993 [main:106] - GETTING Any? from Boolean
2021-03-12 08:00:28,994 [main:106] - GETTING Any? from Function1<Int, Int>
2021-03-12 08:00:29,004 [main:106] - GETTING Any? from Int
2021-03-12 08:00:29,034 [main:106] - GETTING Any? from Foo
2021-03-12 08:00:29,041 [main:106] - GETTING Any? from Int
2021-03-12 08:00:29,042 [main:106] - GETTING Any? from Boolean
2021-03-12 08:00:29,043 [main:106] - GETTING Any? from Int
2021-03-12 08:00:29,044 [main:106] - GETTING Any? from Int
2021-03-12 08:00:29,045 [main:106] - GETTING Any? from Boolean
2021-03-12 08:00:29,046 [main:106] - GETTING Any? from Foo
2021-03-12 08:00:29,047 [main:106] - GETTING Any? from Int
2021-03-12 08:00:29,048 [main:106] - GETTING Any? from Foo
2021-03-12 08:00:29,049 [main:106] - GETTING Any? from UShort
2021-03-12 08:00:29,074 [main:106] - GETTING Any? from Foo
2021-03-12 08:00:29,075 [main:106] - GETTING Any? from Boolean
2021-03-12 08:00:29,076 [main:106] - GETTING Any? from Byte
2021-03-12 08:00:29,106 [main:106] - GETTING Any? from Kla2
2021-03-12 08:00:29,111 [main:106] - GETTING Any? from Int
2021-03-12 08:00:29,112 [main:106] - GETTING Any? from Int
2021-03-12 08:00:29,113 [main:106] - GETTING Any? from Function1<Int, Int>
2021-03-12 08:00:29,114 [main:106] - GETTING Any? from UByte
2021-03-12 08:00:29,136 [main:106] - GETTING Any? from Int
2021-03-12 08:00:29,137 [main:106] - GETTING Any? from Foo
2021-03-12 08:00:29,138 [main:106] - GETTING Any? from Foo
2021-03-12 08:00:29,139 [main:106] - GETTING Any? from Foo
2021-03-12 08:00:29,140 [main:106] - GETTING Any? from Boolean
2021-03-12 08:00:29,141 [main:106] - GETTING Any? from Int
2021-03-12 08:00:29,142 [main:106] - GETTING Any? from Boolean
2021-03-12 08:00:29,143 [main:106] - GETTING Any? from Float
2021-03-12 08:00:29,172 [main:106] - GETTING Any? from Int
2021-03-12 08:00:29,173 [main:106] - GETTING Any? from Boolean
2021-03-12 08:00:29,174 [main:106] - GETTING Any? from Char
2021-03-12 08:00:29,191 [main:106] - GETTING Any? from Int
2021-03-12 08:00:29,192 [main:106] - GETTING Any? from Boolean
2021-03-12 08:00:29,193 [main:106] - GETTING Any? from Int
2021-03-12 08:00:29,194 [main:106] - GETTING Any? from Int
2021-03-12 08:00:29,195 [main:106] - GETTING Any? from Boolean
2021-03-12 08:00:29,196 [main:106] - GETTING Any? from Foo
2021-03-12 08:00:29,197 [main:106] - GETTING Any? from Foo
2021-03-12 08:00:29,198 [main:106] - GETTING Any? from Boolean
2021-03-12 08:00:29,199 [main:106] - GETTING Any? from Foo
2021-03-12 08:00:29,200 [main:106] - GETTING Any? from Function1<Int, Int>
2021-03-12 08:00:29,201 [main:106] - GETTING Any? from UByte
2021-03-12 08:00:29,202 [main:106] - GETTING Any? from Boolean
2021-03-12 08:00:29,203 [main:106] - GETTING Any? from Foo
2021-03-12 08:00:29,204 [main:106] - GETTING Any? from Kla0
2021-03-12 08:00:29,205 [main:106] - GETTING Any? from Boolean
2021-03-12 08:00:29,206 [main:106] - GETTING Any? from Function1<Int, Int>
2021-03-12 08:00:29,207 [main:106] - GETTING Any? from Boolean
2021-03-12 08:00:29,207 [main:114] - replacement of getOrThrow() of type Any? is (linkedSetOf<Short?>(-7341)).toArray().get(f.next())
2021-03-12 08:00:29,425 [main:33] - Trying to replace Element(CALL_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:00:29,426 [main:66] - Compilation checking started
2021-03-12 08:00:30,045 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).(linkedSetOf<Short?>(-7341)).toArray().get(f.next())
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:30,050 [main:107] - replacing (prope11, String)
2021-03-12 08:00:30,050 [main:50] - replacing prope11 String
2021-03-12 08:00:30,050 [main:54] - Getting value of type String
2021-03-12 08:00:30,269 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:00:30,282 [main:58] - GENERATED VALUE OF TYPE String = "weejk"
2021-03-12 08:00:30,282 [main:61] - GENERATED IS CALL =false
2021-03-12 08:00:30,591 [main:67] - randomType = Kla7
2021-03-12 08:00:30,808 [main:302] - generating value of type = Kla7 false depth = 0
2021-03-12 08:00:30,820 [main:112] - generating klass Kla7 text = class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}
2021-03-12 08:00:30,827 [main:149] - GENERATING call of type public final suspend fun fu13(): kotlin.String defined in Kla7[SimpleFunctionDescriptorImpl@34037ee0]
2021-03-12 08:00:30,827 [main:149] - GENERATING call of type public inline fun kotlin.String.filterNot(predicate: (kotlin.Char) -> kotlin.Boolean): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@590806a5]
2021-03-12 08:00:31,044 [main:302] - generating value of type = Function1<Char, Boolean> false depth = 0
2021-03-12 08:00:31,056 [main:302] - generating value of type = Boolean true depth = 1
2021-03-12 08:00:31,068 [main:78] - Generated call from random type = (Kla7()).fu13().filterNot({a: Char -> false})
2021-03-12 08:00:31,069 [main:106] - GETTING String from Int
2021-03-12 08:00:31,098 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 08:00:31,098 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 08:00:31,099 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 08:00:31,099 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()).toByte().toString((Foo(655341081, {a: Int -> -655341081}).next()))
2021-03-12 08:00:31,099 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 08:00:31,099 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 08:00:31,099 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 08:00:31,099 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()).toChar().titlecase()
2021-03-12 08:00:31,099 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 08:00:31,099 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 08:00:31,336 [main:302] - generating value of type = Long true depth = 0
2021-03-12 08:00:31,348 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 08:00:31,348 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()).div(5470778633725966575).toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 08:00:31,348 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 08:00:31,349 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 08:00:31,349 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 08:00:31,349 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()).compareTo(Foo(-655341081, {a: Int -> 120045518}).state).toString(f.next())
2021-03-12 08:00:31,349 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 08:00:31,349 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 08:00:31,349 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 08:00:31,570 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:31,583 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()).toShort().toString(2143020074)
2021-03-12 08:00:31,583 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 08:00:31,583 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 08:00:31,583 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 08:00:31,800 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:00:31,812 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()).toChar().plus("fvgdq")
2021-03-12 08:00:31,812 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 08:00:31,812 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 08:00:31,813 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 08:00:31,813 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()).toLong().toString((Foo(655341081, {a: Int -> -655341081}).next()))
2021-03-12 08:00:31,813 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 08:00:31,813 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 08:00:32,031 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:32,043 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()).toString(-1908770460)
2021-03-12 08:00:32,043 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 08:00:32,043 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 08:00:32,044 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 08:00:32,044 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()).toChar().lowercase()
2021-03-12 08:00:32,044 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 08:00:32,044 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 08:00:32,044 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 08:00:32,044 [main:117] - GENERATED CALL = ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
2021-03-12 08:00:32,044 [main:114] - replacement of prope11 of type String is ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()).toChar().titlecase()
2021-03-12 08:00:32,262 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:00:32,262 [main:66] - Compilation checking started
2021-03-12 08:00:32,893 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv()).toChar().titlecase() = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:32,897 [main:107] - replacing (s, String)
2021-03-12 08:00:32,897 [main:50] - replacing s String
2021-03-12 08:00:32,897 [main:54] - Getting value of type String
2021-03-12 08:00:33,114 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:00:33,126 [main:58] - GENERATED VALUE OF TYPE String = "jzljg"
2021-03-12 08:00:33,126 [main:61] - GENERATED IS CALL =false
2021-03-12 08:00:33,150 [main:67] - randomType = Int
2021-03-12 08:00:33,366 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:33,407 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 08:00:33,408 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 08:00:33,408 [main:78] - Generated call from random type = (-1763313636).toChar().lowercase()
2021-03-12 08:00:33,409 [main:106] - GETTING String from Char
2021-03-12 08:00:33,425 [main:113] - Case = [public final fun toLong(): kotlin.Long defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@45ae53aa], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 08:00:33,425 [main:149] - GENERATING call of type public final fun toLong(): kotlin.Long defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@45ae53aa]
2021-03-12 08:00:33,425 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 08:00:33,425 [main:117] - GENERATED CALL = ((f.next()).toChar()).toLong().toString(Kla3().prope6)
2021-03-12 08:00:33,425 [main:113] - Case = [public open fun compareTo(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@57514114], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 08:00:33,425 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Char): kotlin.Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@57514114]
2021-03-12 08:00:33,642 [main:302] - generating value of type = Char true depth = 0
2021-03-12 08:00:33,654 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 08:00:33,654 [main:117] - GENERATED CALL = ((f.next()).toChar()).compareTo('').toString(f.next())
2021-03-12 08:00:33,654 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 08:00:33,654 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 08:00:33,655 [main:117] - GENERATED CALL = ((f.next()).toChar()).titlecase()
2021-03-12 08:00:33,655 [main:113] - Case = [public final fun toShort(): kotlin.Short defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@6432ce09], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 08:00:33,655 [main:149] - GENERATING call of type public final fun toShort(): kotlin.Short defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@6432ce09]
2021-03-12 08:00:33,655 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 08:00:33,655 [main:117] - GENERATED CALL = ((f.next()).toChar()).toShort().toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 08:00:33,655 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 08:00:33,655 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 08:00:33,655 [main:117] - GENERATED CALL = ((f.next()).toChar()).lowercase()
2021-03-12 08:00:33,655 [main:113] - Case = [public final fun toByte(): kotlin.Byte defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@4c28b19f], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 08:00:33,655 [main:149] - GENERATING call of type public final fun toByte(): kotlin.Byte defined in kotlin.Char[DeserializedSimpleFunctionDescriptor@4c28b19f]
2021-03-12 08:00:33,655 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 08:00:33,656 [main:117] - GENERATED CALL = ((f.next()).toChar()).toByte().toString(Kla3().prope6)
2021-03-12 08:00:33,656 [main:113] - Case = [@kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]]
2021-03-12 08:00:33,656 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.uppercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@71e83408]
2021-03-12 08:00:33,656 [main:117] - GENERATED CALL = ((f.next()).toChar()).uppercase()
2021-03-12 08:00:33,656 [main:113] - Case = [@kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 08:00:33,656 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 08:00:33,872 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:00:33,884 [main:117] - GENERATED CALL = ((f.next()).toChar()).plus("cqxmo")
2021-03-12 08:00:33,884 [main:114] - replacement of s of type String is ((f.next()).toChar()).toByte().toString(Kla3().prope6)
2021-03-12 08:00:34,100 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:00:34,101 [main:66] - Compilation checking started
2021-03-12 08:00:34,720 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").((f.next()).toChar()).toByte().toString(Kla3().prope6)
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (prope11 != "OK") return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:34,724 [main:107] - replacing (prope11 != "OK", Boolean)
2021-03-12 08:00:34,724 [main:50] - replacing prope11 != "OK" Boolean
2021-03-12 08:00:34,724 [main:54] - Getting value of type Boolean
2021-03-12 08:00:34,960 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:00:34,972 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 08:00:34,972 [main:61] - GENERATED IS CALL =false
2021-03-12 08:00:35,297 [main:67] - randomType = LinkedHashSet<Float>
2021-03-12 08:00:35,513 [main:302] - generating value of type = LinkedHashSet<Float> false depth = 0
2021-03-12 08:00:35,744 [main:43] - GENERATING CALL OF fun <T> linkedSetOf(elements: Float): LkedHashSet<Float> = TODO()
2021-03-12 08:00:35,758 [main:61] - WITHOUT TYPE PARAMS = fun <T> linkedSetOf(elements: Float): LkedHashSet<Float> = TODO()
2021-03-12 08:00:35,994 [main:302] - generating value of type = Float true depth = 3
2021-03-12 08:00:36,006 [main:95] - GENERATED = linkedSetOf<Float>(0.4599471f)
2021-03-12 08:00:36,117 [main:149] - GENERATING call of type public open fun retainAll(elements: kotlin.collections.Collection<kotlin.Float>): kotlin.Boolean defined in kotlin.collections.LinkedHashSet[DeserializedSimpleFunctionDescriptor@764083d2]
2021-03-12 08:00:36,333 [main:302] - generating value of type = Collection<Float> false depth = 0
2021-03-12 08:00:36,564 [main:43] - GENERATING CALL OF fun UShortArray(size: kotlin.Int): Collection<Float> = TODO()
2021-03-12 08:00:36,578 [main:61] - WITHOUT TYPE PARAMS = fun UShortArray(size: kotlin.Int): Collection<Float> = TODO()
2021-03-12 08:00:37,102 [main:302] - generating value of type = Int true depth = 3
2021-03-12 08:00:37,114 [main:95] - GENERATED = UShortArray(575473507)
2021-03-12 08:00:37,115 [main:78] - Generated call from random type = (linkedSetOf<Float>(0.4599471f)).retainAll(UShortArray(575473507))
2021-03-12 08:00:37,115 [main:106] - GETTING Boolean from Boolean
2021-03-12 08:00:37,123 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 08:00:37,123 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 08:00:37,340 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:37,340 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 08:00:37,556 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:00:37,568 [main:117] - GENERATED CALL = (Kla2().fu4()).equals("edfwa").and(true)
2021-03-12 08:00:37,568 [main:113] - Case = [public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]]
2021-03-12 08:00:37,568 [main:149] - GENERATING call of type public final operator fun not(): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@786a7b]
2021-03-12 08:00:37,568 [main:117] - GENERATED CALL = (Kla2().fu4()).not()
2021-03-12 08:00:37,569 [main:113] - Case = [public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 08:00:37,569 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 08:00:37,569 [main:117] - GENERATED CALL = (Kla2().fu4()).xor(prope1.fu4())
2021-03-12 08:00:37,569 [main:113] - Case = [public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 08:00:37,569 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 08:00:37,569 [main:117] - GENERATED CALL = (Kla2().fu4()).or(Kla1().fu4())
2021-03-12 08:00:37,569 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]]
2021-03-12 08:00:37,569 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:37,569 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3bee1bb3]
2021-03-12 08:00:37,786 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:37,786 [main:117] - GENERATED CALL = (Kla2().fu4()).compareTo(prope1.fu4()).equals("xgctw")
2021-03-12 08:00:37,786 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 08:00:37,786 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 08:00:38,003 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:38,003 [main:117] - GENERATED CALL = (Kla2().fu4()).equals("obskc")
2021-03-12 08:00:38,003 [main:113] - Case = [public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 08:00:38,003 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 08:00:38,003 [main:117] - GENERATED CALL = (Kla2().fu4()).and(Kla2().fu4())
2021-03-12 08:00:38,003 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 08:00:38,003 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 08:00:38,221 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:38,221 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 08:00:38,221 [main:117] - GENERATED CALL = (Kla2().fu4()).equals("vcsjq").or(Kla1().fu2())
2021-03-12 08:00:38,221 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]]
2021-03-12 08:00:38,221 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 08:00:38,458 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:38,458 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@48bbf53e]
2021-03-12 08:00:38,674 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:00:38,686 [main:117] - GENERATED CALL = (Kla2().fu4()).equals("ptxtl").xor(true)
2021-03-12 08:00:38,686 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 08:00:38,686 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 08:00:38,903 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:38,904 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 08:00:39,121 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:39,121 [main:117] - GENERATED CALL = (Kla2().fu4()).equals("ttyjo").equals("mtwam")
2021-03-12 08:00:39,121 [main:114] - replacement of prope11 != "OK" of type Boolean is Kla2().fu4()
2021-03-12 08:00:39,336 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:00:39,337 [main:66] - Compilation checking started
2021-03-12 08:00:40,286 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (Kla2().fu4()) return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:40,291 [main:107] - replacing (s, String)
2021-03-12 08:00:40,291 [main:50] - replacing s String
2021-03-12 08:00:40,291 [main:54] - Getting value of type String
2021-03-12 08:00:40,507 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:00:40,520 [main:58] - GENERATED VALUE OF TYPE String = "ddkgu"
2021-03-12 08:00:40,520 [main:61] - GENERATED IS CALL =false
2021-03-12 08:00:41,129 [main:67] - randomType = Sequence<Float?>
2021-03-12 08:00:41,130 [main:106] - GETTING String from Foo
2021-03-12 08:00:41,137 [main:113] - Case = [public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 08:00:41,137 [main:149] - GENERATING call of type public final fun next(): kotlin.Int defined in Foo[SimpleFunctionDescriptorImpl@6b000338]
2021-03-12 08:00:41,137 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 08:00:41,354 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:41,367 [main:117] - GENERATED CALL = (Foo(-655341081, {a: Int -> 120045518})).next().toString(1113120691)
2021-03-12 08:00:41,367 [main:114] - replacement of s of type String is "ddkgu"
2021-03-12 08:00:41,581 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(STRING_TEMPLATE)
2021-03-12 08:00:41,581 [main:66] - Compilation checking started
2021-03-12 08:00:42,218 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa")."ddkgu"
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (Kla2().fu4()) return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:42,222 [main:107] - replacing (EmptyCoroutineContext, EmptyCoroutineContext)
2021-03-12 08:00:42,222 [main:50] - replacing EmptyCoroutineContext EmptyCoroutineContext
2021-03-12 08:00:42,222 [main:54] - Getting value of type EmptyCoroutineContext
2021-03-12 08:00:42,439 [main:302] - generating value of type = EmptyCoroutineContext false depth = 0
2021-03-12 08:00:42,454 [main:58] - GENERATED VALUE OF TYPE EmptyCoroutineContext = 
2021-03-12 08:00:42,780 [main:67] - randomType = HashSet<UInt>
2021-03-12 08:00:42,996 [main:302] - generating value of type = HashSet<UInt> false depth = 0
2021-03-12 08:00:43,226 [main:43] - GENERATING CALL OF fun <E> HashSet(initialCapacity: kotlin.Int, loadFactor: kotlin.Float): HashSet<UInt> = TODO()
2021-03-12 08:00:43,241 [main:61] - WITHOUT TYPE PARAMS = fun <E> HashSet(initialCapacity: kotlin.Int, loadFactor: kotlin.Float): HashSet<UInt> = TODO()
2021-03-12 08:00:44,048 [main:302] - generating value of type = Int true depth = 3
2021-03-12 08:00:44,061 [main:302] - generating value of type = Float true depth = 3
2021-03-12 08:00:44,073 [main:95] - GENERATED = HashSet<UInt>(248437748, 0.819175f)
2021-03-12 08:00:44,166 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:00:44,173 [main:106] - GETTING EmptyCoroutineContext from Kla0
2021-03-12 08:00:44,176 [main:106] - GETTING EmptyCoroutineContext from UByte
2021-03-12 08:00:44,197 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:00:44,205 [main:106] - GETTING EmptyCoroutineContext from Function1<Int, Int>
2021-03-12 08:00:44,214 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:00:44,215 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:00:44,216 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:00:44,216 [main:106] - GETTING EmptyCoroutineContext from UByte
2021-03-12 08:00:44,217 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:00:44,246 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:00:44,247 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:00:44,248 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:00:44,248 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:00:44,249 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:00:44,250 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:00:44,250 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:00:44,251 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:00:44,251 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:00:44,252 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:00:44,253 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:00:44,254 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:00:44,254 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:00:44,255 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:00:44,256 [main:106] - GETTING EmptyCoroutineContext from Char
2021-03-12 08:00:44,273 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:00:44,274 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:00:44,274 [main:106] - GETTING EmptyCoroutineContext from Function1<Int, Int>
2021-03-12 08:00:44,275 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:00:44,276 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:00:44,276 [main:106] - GETTING EmptyCoroutineContext from UShort
2021-03-12 08:00:44,299 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:00:44,299 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:00:44,300 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:00:44,301 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:00:44,301 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:00:44,302 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:00:44,303 [main:106] - GETTING EmptyCoroutineContext from Float
2021-03-12 08:00:44,331 [main:106] - GETTING EmptyCoroutineContext from Kla2
2021-03-12 08:00:44,336 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:00:44,336 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:00:44,337 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:00:44,338 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:00:44,338 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:00:44,339 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:00:44,339 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:00:44,340 [main:106] - GETTING EmptyCoroutineContext from Function1<Int, Int>
2021-03-12 08:00:44,341 [main:106] - GETTING EmptyCoroutineContext from Byte
2021-03-12 08:00:44,371 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:00:44,371 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:00:44,372 [main:106] - GETTING EmptyCoroutineContext from Kla0
2021-03-12 08:00:44,373 [main:106] - GETTING EmptyCoroutineContext from Function1<Int, Int>
2021-03-12 08:00:44,373 [main:111] - Cant find and generate replacement for EmptyCoroutineContext type EmptyCoroutineContext
2021-03-12 08:00:44,373 [main:107] - replacing ("UNCHECKED_CAST", String)
2021-03-12 08:00:44,373 [main:50] - replacing "UNCHECKED_CAST" String
2021-03-12 08:00:44,373 [main:54] - Getting value of type String
2021-03-12 08:00:44,588 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:00:44,600 [main:58] - GENERATED VALUE OF TYPE String = "rrzry"
2021-03-12 08:00:44,601 [main:61] - GENERATED IS CALL =false
2021-03-12 08:00:45,925 [main:67] - randomType = HashMap<Array<Kla2>, LinkedHashMap<Byte, ULong>>
2021-03-12 08:00:46,141 [main:302] - generating value of type = HashMap<Array<Kla2>, LinkedHashMap<Byte, ULong>> false depth = 0
2021-03-12 08:00:46,377 [main:43] - GENERATING CALL OF fun <K, V> hashMapOf(): HashMap<Array<Kla2>, LkedHashMap<Byte, ULong>> = TODO()
2021-03-12 08:00:46,391 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> hashMapOf(): HashMap<Array<Kla2>, LkedHashMap<Byte, ULong>> = TODO()
2021-03-12 08:00:46,629 [main:95] - GENERATED = hashMapOf<Array<Kla2>, LinkedHashMap<Byte, ULong>>()
2021-03-12 08:00:46,792 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 08:00:46,792 [main:78] - Generated call from random type = (hashMapOf<Array<Kla2>, LinkedHashMap<Byte, ULong>>()).size.toString(f.next())
2021-03-12 08:00:46,793 [main:106] - GETTING String from Int
2021-03-12 08:00:46,825 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]]
2021-03-12 08:00:46,825 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 08:00:46,825 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Short.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@789e3c10]
2021-03-12 08:00:47,050 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:47,062 [main:117] - GENERATED CALL = (Kla3().prope6).toShort().toString(-2081971455)
2021-03-12 08:00:47,063 [main:113] - Case = [public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 08:00:47,063 [main:149] - GENERATING call of type public abstract fun toLong(): kotlin.Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@2ffa1f25]
2021-03-12 08:00:47,063 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 08:00:47,280 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:47,292 [main:117] - GENERATED CALL = (Kla3().prope6).toLong().toString(-1605043060)
2021-03-12 08:00:47,292 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 08:00:47,292 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 08:00:47,293 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 08:00:47,509 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:47,521 [main:117] - GENERATED CALL = (Kla3().prope6).toInt().toString(447128386)
2021-03-12 08:00:47,521 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]]
2021-03-12 08:00:47,521 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 08:00:47,740 [main:302] - generating value of type = Long true depth = 0
2021-03-12 08:00:47,752 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Long.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@77799ca1]
2021-03-12 08:00:47,752 [main:117] - GENERATED CALL = (Kla3().prope6).div(3496504428152868319).toString(Foo(416482559, {a: Int -> 23}).state)
2021-03-12 08:00:47,752 [main:113] - Case = [@kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 08:00:47,753 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 08:00:47,753 [main:117] - GENERATED CALL = (Kla3().prope6).toString(Foo(-655341081, {a: Int -> 120045518}).state)
2021-03-12 08:00:47,753 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]]
2021-03-12 08:00:47,753 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 08:00:47,753 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 08:00:47,753 [main:117] - GENERATED CALL = (Kla3().prope6).toChar().lowercase()
2021-03-12 08:00:47,753 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]]
2021-03-12 08:00:47,753 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 08:00:47,753 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Char.titlecase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@12aa431c]
2021-03-12 08:00:47,753 [main:117] - GENERATED CALL = (Kla3().prope6).toChar().titlecase()
2021-03-12 08:00:47,754 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 08:00:47,754 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 08:00:47,754 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 08:00:47,754 [main:117] - GENERATED CALL = (Kla3().prope6).compareTo((Foo(-655341081, {a: Int -> 120045518}).state)).toString((Foo(416482559, {a: Int -> 23}).state))
2021-03-12 08:00:47,754 [main:113] - Case = [public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac], @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]]
2021-03-12 08:00:47,754 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 08:00:47,754 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public inline operator fun kotlin.Char.plus(other: kotlin.String): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3d595dca]
2021-03-12 08:00:47,971 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:00:47,983 [main:117] - GENERATED CALL = (Kla3().prope6).toChar().plus("npobw")
2021-03-12 08:00:47,984 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]]
2021-03-12 08:00:47,984 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 08:00:47,984 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun kotlin.Byte.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1e0c9336]
2021-03-12 08:00:48,201 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:48,213 [main:117] - GENERATED CALL = (Kla3().prope6).toByte().toString(625921721)
2021-03-12 08:00:48,214 [main:114] - replacement of "UNCHECKED_CAST" of type String is (Kla3().prope6).toShort().toString(-2081971455)
2021-03-12 08:00:48,428 [main:33] - Trying to replace Element(STRING_TEMPLATE) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:00:48,428 [main:66] - Compilation checking started
2021-03-12 08:00:49,073 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress((Kla3().prope6).toShort().toString(-2081971455))
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (Kla2().fu4()) return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (prope13 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:49,077 [main:107] - replacing (prope13, Int)
2021-03-12 08:00:49,077 [main:50] - replacing prope13 Int
2021-03-12 08:00:49,077 [main:54] - Getting value of type Int
2021-03-12 08:00:49,292 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:49,305 [main:58] - GENERATED VALUE OF TYPE Int = -1967865395
2021-03-12 08:00:49,305 [main:61] - GENERATED IS CALL =false
2021-03-12 08:00:49,633 [main:67] - randomType = HashSet<UByte>
2021-03-12 08:00:49,848 [main:302] - generating value of type = HashSet<UByte> false depth = 0
2021-03-12 08:00:50,078 [main:43] - GENERATING CALL OF fun <T> hashSetOf(elements: UByte): HashSet<UByte> = TODO()
2021-03-12 08:00:50,092 [main:61] - WITHOUT TYPE PARAMS = fun <T> hashSetOf(elements: UByte): HashSet<UByte> = TODO()
2021-03-12 08:00:50,326 [main:302] - generating value of type = UByte true depth = 3
2021-03-12 08:00:50,338 [main:95] - GENERATED = hashSetOf<UByte>(25.toUByte())
2021-03-12 08:00:50,432 [main:149] - GENERATING call of type @kotlin.js.JsName protected open fun toArray(): kotlin.Array<kotlin.Any?> defined in kotlin.collections.HashSet[DeserializedSimpleFunctionDescriptor@13c73b8e]
2021-03-12 08:00:50,432 [main:78] - Generated call from random type = (hashSetOf<UByte>(25.toUByte())).toArray().lastIndex
2021-03-12 08:00:50,433 [main:106] - GETTING Int from Boolean
2021-03-12 08:00:50,441 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateLeft(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@2c61e062]]
2021-03-12 08:00:50,441 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:50,657 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:00:50,669 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateLeft(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@2c61e062]
2021-03-12 08:00:50,670 [main:117] - GENERATED CALL = (Kla2().fu3()).compareTo(true).rotateLeft((Foo(655341081, {a: Int -> -655341081}).next()))
2021-03-12 08:00:50,670 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@63d279b5]]
2021-03-12 08:00:50,670 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:50,670 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@63d279b5]
2021-03-12 08:00:50,670 [main:117] - GENERATED CALL = (Kla2().fu3()).compareTo(prope1.fu4()).and((f).next())
2021-03-12 08:00:50,670 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5], public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]]
2021-03-12 08:00:50,670 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@5c6204e5]
2021-03-12 08:00:50,886 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:00:50,886 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:50,887 [main:117] - GENERATED CALL = (Kla2().fu3()).equals("uctfl").compareTo(Kla2().fu1())
2021-03-12 08:00:50,887 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7bf4ba17]]
2021-03-12 08:00:50,887 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:50,887 [main:149] - GENERATING call of type public final fun inv(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7bf4ba17]
2021-03-12 08:00:50,887 [main:117] - GENERATED CALL = (Kla2().fu3()).compareTo(prope1.fu4()).inv()
2021-03-12 08:00:50,887 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]]
2021-03-12 08:00:50,887 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:50,887 [main:117] - GENERATED CALL = (Kla2().fu3()).compareTo(Kla2().fu4())
2021-03-12 08:00:50,887 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@1ece8c98]]
2021-03-12 08:00:50,887 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:50,887 [main:149] - GENERATING call of type public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@1ece8c98]
2021-03-12 08:00:51,104 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:51,117 [main:117] - GENERATED CALL = (Kla2().fu3()).compareTo(Kla1().fu2()).coerceIn((f.next()), 1831059760)
2021-03-12 08:00:51,117 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fd6caab]]
2021-03-12 08:00:51,117 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:51,332 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:00:51,344 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fd6caab]
2021-03-12 08:00:51,559 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:51,572 [main:117] - GENERATED CALL = (Kla2().fu3()).compareTo(false).or(1475517195)
2021-03-12 08:00:51,572 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public fun kotlin.Int.coerceAtLeast(minimumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@7fd1342c]]
2021-03-12 08:00:51,572 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:51,572 [main:149] - GENERATING call of type public fun kotlin.Int.coerceAtLeast(minimumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@7fd1342c]
2021-03-12 08:00:51,786 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:51,798 [main:117] - GENERATED CALL = (Kla2().fu3()).compareTo(prope1.fu4()).coerceAtLeast(1290385738)
2021-03-12 08:00:51,798 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@799f23e6]]
2021-03-12 08:00:51,798 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:52,014 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:00:52,026 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@799f23e6]
2021-03-12 08:00:52,027 [main:117] - GENERATED CALL = (Kla2().fu3()).compareTo(false).plus((Foo(416482559, {a: Int -> 23}).state).toByte())
2021-03-12 08:00:52,027 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4fa2ec50]]
2021-03-12 08:00:52,027 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:52,242 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:00:52,254 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4fa2ec50]
2021-03-12 08:00:52,254 [main:117] - GENERATED CALL = (Kla2().fu3()).compareTo(true).unaryMinus()
2021-03-12 08:00:52,254 [main:114] - replacement of prope13 of type Int is -1967865395
2021-03-12 08:00:52,497 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(PREFIX_EXPRESSION)
2021-03-12 08:00:52,497 [main:66] - Compilation checking started
2021-03-12 08:00:53,436 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (Kla2().fu4()) return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (-1967865395 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            prope10.prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:53,440 [main:107] - replacing (prope10, Kla12)
2021-03-12 08:00:53,441 [main:50] - replacing prope10 Kla12
2021-03-12 08:00:53,441 [main:54] - Getting value of type Kla12
2021-03-12 08:00:53,659 [main:302] - generating value of type = Kla12 false depth = 0
2021-03-12 08:00:53,671 [main:112] - generating klass Kla12 text = class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (-1967865395 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 08:00:53,671 [main:58] - GENERATED VALUE OF TYPE Kla12 = Kla12()
2021-03-12 08:00:53,671 [main:61] - GENERATED IS CALL =true
2021-03-12 08:00:54,372 [main:67] - randomType = LinkedHashMap<Kla8, Kla11>
2021-03-12 08:00:54,589 [main:302] - generating value of type = LinkedHashMap<Kla8, Kla11> false depth = 0
2021-03-12 08:00:54,821 [main:43] - GENERATING CALL OF fun <K, V> linkedMapOf(): LkedHashMap<Kla8, Kla11> = TODO()
2021-03-12 08:00:54,835 [main:61] - WITHOUT TYPE PARAMS = fun <K, V> linkedMapOf(): LkedHashMap<Kla8, Kla11> = TODO()
2021-03-12 08:00:55,071 [main:95] - GENERATED = linkedMapOf<Kla8, Kla11>()
2021-03-12 08:00:55,187 [main:106] - GETTING Kla12 from Boolean
2021-03-12 08:00:55,195 [main:106] - GETTING Kla12 from Boolean
2021-03-12 08:00:55,196 [main:106] - GETTING Kla12 from Boolean
2021-03-12 08:00:55,196 [main:106] - GETTING Kla12 from Foo
2021-03-12 08:00:55,204 [main:106] - GETTING Kla12 from Boolean
2021-03-12 08:00:55,204 [main:106] - GETTING Kla12 from Function1<Int, Int>
2021-03-12 08:00:55,213 [main:106] - GETTING Kla12 from Byte
2021-03-12 08:00:55,242 [main:106] - GETTING Kla12 from Foo
2021-03-12 08:00:55,243 [main:106] - GETTING Kla12 from Foo
2021-03-12 08:00:55,243 [main:106] - GETTING Kla12 from UByte
2021-03-12 08:00:55,265 [main:106] - GETTING Kla12 from Boolean
2021-03-12 08:00:55,265 [main:106] - GETTING Kla12 from Boolean
2021-03-12 08:00:55,266 [main:106] - GETTING Kla12 from Int
2021-03-12 08:00:55,294 [main:106] - GETTING Kla12 from Foo
2021-03-12 08:00:55,295 [main:106] - GETTING Kla12 from Int
2021-03-12 08:00:55,296 [main:106] - GETTING Kla12 from Int
2021-03-12 08:00:55,296 [main:106] - GETTING Kla12 from Kla2
2021-03-12 08:00:55,302 [main:106] - GETTING Kla12 from Int
2021-03-12 08:00:55,302 [main:106] - GETTING Kla12 from Float
2021-03-12 08:00:55,329 [main:106] - GETTING Kla12 from Boolean
2021-03-12 08:00:55,330 [main:106] - GETTING Kla12 from Boolean
2021-03-12 08:00:55,330 [main:106] - GETTING Kla12 from Int
2021-03-12 08:00:55,331 [main:106] - GETTING Kla12 from Function1<Int, Int>
2021-03-12 08:00:55,331 [main:106] - GETTING Kla12 from Function1<Int, Int>
2021-03-12 08:00:55,332 [main:106] - GETTING Kla12 from Int
2021-03-12 08:00:55,333 [main:106] - GETTING Kla12 from Kla0
2021-03-12 08:00:55,336 [main:106] - GETTING Kla12 from Char
2021-03-12 08:00:55,353 [main:106] - GETTING Kla12 from Kla0
2021-03-12 08:00:55,353 [main:106] - GETTING Kla12 from Int
2021-03-12 08:00:55,354 [main:106] - GETTING Kla12 from Foo
2021-03-12 08:00:55,354 [main:106] - GETTING Kla12 from Int
2021-03-12 08:00:55,355 [main:106] - GETTING Kla12 from Boolean
2021-03-12 08:00:55,356 [main:106] - GETTING Kla12 from Int
2021-03-12 08:00:55,356 [main:106] - GETTING Kla12 from Boolean
2021-03-12 08:00:55,357 [main:106] - GETTING Kla12 from Int
2021-03-12 08:00:55,357 [main:106] - GETTING Kla12 from UShort
2021-03-12 08:00:55,379 [main:106] - GETTING Kla12 from Int
2021-03-12 08:00:55,380 [main:106] - GETTING Kla12 from Boolean
2021-03-12 08:00:55,380 [main:106] - GETTING Kla12 from Int
2021-03-12 08:00:55,381 [main:106] - GETTING Kla12 from Foo
2021-03-12 08:00:55,381 [main:106] - GETTING Kla12 from Foo
2021-03-12 08:00:55,382 [main:106] - GETTING Kla12 from Foo
2021-03-12 08:00:55,382 [main:106] - GETTING Kla12 from Boolean
2021-03-12 08:00:55,383 [main:106] - GETTING Kla12 from UByte
2021-03-12 08:00:55,384 [main:106] - GETTING Kla12 from Foo
2021-03-12 08:00:55,384 [main:106] - GETTING Kla12 from Boolean
2021-03-12 08:00:55,385 [main:106] - GETTING Kla12 from Foo
2021-03-12 08:00:55,385 [main:106] - GETTING Kla12 from Int
2021-03-12 08:00:55,386 [main:106] - GETTING Kla12 from Boolean
2021-03-12 08:00:55,387 [main:106] - GETTING Kla12 from Function1<Int, Int>
2021-03-12 08:00:55,387 [main:106] - GETTING Kla12 from Boolean
2021-03-12 08:00:55,388 [main:106] - GETTING Kla12 from Foo
2021-03-12 08:00:55,388 [main:114] - replacement of prope10 of type Kla12 is Kla12()
2021-03-12 08:00:55,604 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:00:55,605 [main:66] - Compilation checking started
2021-03-12 08:00:56,570 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if (prope11 != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (Kla2().fu4()) return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (-1967865395 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            Kla12().prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:56,574 [main:107] - replacing (prope11, String)
2021-03-12 08:00:56,574 [main:50] - replacing prope11 String
2021-03-12 08:00:56,574 [main:54] - Getting value of type String
2021-03-12 08:00:56,791 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:00:56,803 [main:58] - GENERATED VALUE OF TYPE String = "myxcq"
2021-03-12 08:00:56,803 [main:61] - GENERATED IS CALL =false
2021-03-12 08:00:56,828 [main:67] - randomType = Int
2021-03-12 08:00:57,044 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:57,087 [main:149] - GENERATING call of type public open fun toChar(): kotlin.Char defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6228deac]
2021-03-12 08:00:57,087 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi @kotlin.internal.InlineOnly public inline fun kotlin.Char.lowercase(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@3f076098]
2021-03-12 08:00:57,088 [main:78] - Generated call from random type = (-390334721).toChar().lowercase()
2021-03-12 08:00:57,088 [main:106] - GETTING String from Function1<Int, Int>
2021-03-12 08:00:57,097 [main:113] - Case = [public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@206509a5], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 08:00:57,097 [main:149] - GENERATING call of type public abstract operator fun invoke(p1: kotlin.Int): kotlin.Int defined in kotlin.Function1[FunctionInvokeDescriptor@206509a5]
2021-03-12 08:00:57,097 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 08:00:57,097 [main:117] - GENERATED CALL = (Foo(1397637829, {a: Int -> -710498597}).f).invoke((Foo(416482559, {a: Int -> 23}).state)).toString((f).next())
2021-03-12 08:00:57,098 [main:114] - replacement of prope11 of type String is (Foo(1397637829, {a: Int -> -710498597}).f).invoke((Foo(416482559, {a: Int -> 23}).state)).toString((f).next())
2021-03-12 08:00:57,313 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:00:57,313 [main:66] - Compilation checking started
2021-03-12 08:00:58,246 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if ((Foo(1397637829, {a: Int -> -710498597}).f).invoke((Foo(416482559, {a: Int -> 23}).state)).toString((f).next()) != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (Kla2().fu4()) return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = 0
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (-1967865395 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            Kla12().prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:00:58,253 [main:107] - replacing (0, Int)
2021-03-12 08:00:58,253 [main:50] - replacing 0 Int
2021-03-12 08:00:58,253 [main:54] - Getting value of type Int
2021-03-12 08:00:58,489 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:58,501 [main:58] - GENERATED VALUE OF TYPE Int = -1460421090
2021-03-12 08:00:58,501 [main:61] - GENERATED IS CALL =false
2021-03-12 08:00:59,118 [main:67] - randomType = List<Int?>
2021-03-12 08:00:59,119 [main:106] - GETTING Int from Boolean
2021-03-12 08:00:59,127 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7ad8c23d]]
2021-03-12 08:00:59,127 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:59,128 [main:149] - GENERATING call of type public final operator fun dec(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7ad8c23d]
2021-03-12 08:00:59,128 [main:117] - GENERATED CALL = (Kla1().fu2()).compareTo(Kla1().fu2()).dec()
2021-03-12 08:00:59,128 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@1ece8c98]]
2021-03-12 08:00:59,128 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:59,128 [main:149] - GENERATING call of type public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@1ece8c98]
2021-03-12 08:00:59,346 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:00:59,358 [main:117] - GENERATED CALL = (Kla1().fu2()).compareTo(Kla1().fu1()).coerceIn(1809428979, Foo(1397637829, {a: Int -> -710498597}).state)
2021-03-12 08:00:59,359 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@55e60c72]]
2021-03-12 08:00:59,359 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:59,359 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@55e60c72]
2021-03-12 08:00:59,359 [main:117] - GENERATED CALL = (Kla1().fu2()).compareTo(Kla2().fu3()).div((Foo(416482559, {a: Int -> 23}).state).toByte())
2021-03-12 08:00:59,359 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@75eb3fad]]
2021-03-12 08:00:59,359 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:59,576 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:00:59,589 [main:149] - GENERATING call of type public final operator fun inc(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@75eb3fad]
2021-03-12 08:00:59,589 [main:117] - GENERATED CALL = (Kla1().fu2()).compareTo(false).inc()
2021-03-12 08:00:59,589 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6988916a]]
2021-03-12 08:00:59,589 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:59,589 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6988916a]
2021-03-12 08:00:59,590 [main:117] - GENERATED CALL = (Kla1().fu2()).compareTo(prope1.fu4()).compareTo((Foo(416482559, {a: Int -> 23}).state).toByte())
2021-03-12 08:00:59,590 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4fa2ec50]]
2021-03-12 08:00:59,590 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:59,590 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@4fa2ec50]
2021-03-12 08:00:59,590 [main:117] - GENERATED CALL = (Kla1().fu2()).compareTo(Kla1().fu2()).unaryMinus()
2021-03-12 08:00:59,590 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateLeft(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@2c61e062]]
2021-03-12 08:00:59,590 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:00:59,826 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:00:59,839 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateLeft(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@2c61e062]
2021-03-12 08:00:59,839 [main:117] - GENERATED CALL = (Kla1().fu2()).compareTo(false).rotateLeft(Foo(1397637829, {a: Int -> -710498597}).next())
2021-03-12 08:00:59,839 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7b0a48e6]]
2021-03-12 08:00:59,839 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:01:00,058 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:01:00,071 [main:149] - GENERATING call of type public final infix fun xor(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@7b0a48e6]
2021-03-12 08:01:00,071 [main:117] - GENERATED CALL = (Kla1().fu2()).compareTo(true).xor((f.next()))
2021-03-12 08:01:00,071 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@62f7e5f9]]
2021-03-12 08:01:00,071 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:01:00,290 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:01:00,303 [main:149] - GENERATING call of type public final infix fun ushr(bitCount: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@62f7e5f9]
2021-03-12 08:01:00,521 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:01:00,533 [main:117] - GENERATED CALL = (Kla1().fu2()).compareTo(true).ushr(-363221737)
2021-03-12 08:01:00,533 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@206be60b]]
2021-03-12 08:01:00,533 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:01:00,534 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalStdlibApi public fun kotlin.Int.rotateRight(bitCount: kotlin.Int): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@206be60b]
2021-03-12 08:01:00,534 [main:117] - GENERATED CALL = (Kla1().fu2()).compareTo(Kla1().fu2()).rotateRight(Kla3().prope6)
2021-03-12 08:01:00,534 [main:114] - replacement of 0 of type Int is (Kla1().fu2()).compareTo(Kla1().fu2()).unaryMinus()
2021-03-12 08:01:00,751 [main:33] - Trying to replace Element(INTEGER_CONSTANT) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:01:00,752 [main:66] - Compilation checking started
2021-03-12 08:01:01,844 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if ((Foo(1397637829, {a: Int -> -710498597}).f).invoke((Foo(416482559, {a: Int -> 23}).state)).toString((f).next()) != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (Kla2().fu4()) return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { it?.methodName?.startsWith(method) == true }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = (Kla1().fu2()).compareTo(Kla1().fu2()).unaryMinus()
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (-1967865395 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            Kla12().prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:01:01,848 [main:107] - replacing (it?.methodName?.startsWith(method) == true, Boolean)
2021-03-12 08:01:01,848 [main:50] - replacing it?.methodName?.startsWith(method) == true Boolean
2021-03-12 08:01:01,848 [main:54] - Getting value of type Boolean
2021-03-12 08:01:02,068 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:01:02,080 [main:58] - GENERATED VALUE OF TYPE Boolean = false
2021-03-12 08:01:02,080 [main:61] - GENERATED IS CALL =false
2021-03-12 08:01:02,106 [main:67] - randomType = Long
2021-03-12 08:01:02,325 [main:302] - generating value of type = Long true depth = 0
2021-03-12 08:01:02,365 [main:149] - GENERATING call of type public abstract fun toFloat(): kotlin.Float defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@201822d7]
2021-03-12 08:01:02,365 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Float[DeserializedSimpleFunctionDescriptor@4e4fe7ba]
2021-03-12 08:01:02,584 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:01:02,584 [main:78] - Generated call from random type = (-9210069358667535787).toFloat().equals("nknjw")
2021-03-12 08:01:02,585 [main:106] - GETTING Boolean from UByte
2021-03-12 08:01:02,607 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toDouble(): kotlin.Double defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@4c261976], public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]]
2021-03-12 08:01:02,607 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toDouble(): kotlin.Double defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@4c261976]
2021-03-12 08:01:02,608 [main:149] - GENERATING call of type public fun kotlin.Double.isInfinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@3ebaecc4]
2021-03-12 08:01:02,608 [main:117] - GENERATED CALL = ((5.toUByte())).toDouble().isInfinite()
2021-03-12 08:01:02,608 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toFloat(): kotlin.Float defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@2bb8bce5], public fun kotlin.Float.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@73343438]]
2021-03-12 08:01:02,608 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toFloat(): kotlin.Float defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@2bb8bce5]
2021-03-12 08:01:02,608 [main:149] - GENERATING call of type public fun kotlin.Float.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@73343438]
2021-03-12 08:01:02,608 [main:117] - GENERATED CALL = ((5.toUByte())).toFloat().isFinite()
2021-03-12 08:01:02,608 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline operator fun div(other: kotlin.UByte): kotlin.UInt defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@364b9340], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@75a90360]]
2021-03-12 08:01:02,608 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun div(other: kotlin.UByte): kotlin.UInt defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@364b9340]
2021-03-12 08:01:02,828 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 08:01:02,840 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.UInt[DeserializedSimpleFunctionDescriptor@75a90360]
2021-03-12 08:01:03,060 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:01:03,061 [main:117] - GENERATED CALL = ((5.toUByte())).div(101.toUByte()).equals("voxdo")
2021-03-12 08:01:03,061 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toShort(): kotlin.Short defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@6d92d846], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7b609fa2]]
2021-03-12 08:01:03,061 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toShort(): kotlin.Short defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@6d92d846]
2021-03-12 08:01:03,061 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@7b609fa2]
2021-03-12 08:01:03,283 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:01:03,284 [main:117] - GENERATED CALL = ((5.toUByte())).toShort().equals("pnhcn")
2021-03-12 08:01:03,284 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@24ea92b5], public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]]
2021-03-12 08:01:03,284 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@24ea92b5]
2021-03-12 08:01:03,503 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:01:03,503 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@11f80670]
2021-03-12 08:01:03,741 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:01:03,753 [main:117] - GENERATED CALL = ((5.toUByte())).equals("mfxtn").and(false)
2021-03-12 08:01:03,754 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline fun toDouble(): kotlin.Double defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@4c261976], public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]]
2021-03-12 08:01:03,754 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline fun toDouble(): kotlin.Double defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@4c261976]
2021-03-12 08:01:03,754 [main:149] - GENERATING call of type public fun kotlin.Double.isFinite(): kotlin.Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor@4e690bc9]
2021-03-12 08:01:03,754 [main:117] - GENERATED CALL = ((5.toUByte())).toDouble().isFinite()
2021-03-12 08:01:03,754 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@24ea92b5], public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]]
2021-03-12 08:01:03,754 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@24ea92b5]
2021-03-12 08:01:03,973 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:01:03,973 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Boolean): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@232ab2c6]
2021-03-12 08:01:04,193 [main:302] - generating value of type = Boolean true depth = 0
2021-03-12 08:01:04,206 [main:117] - GENERATED CALL = ((5.toUByte())).equals("srnwm").or(false)
2021-03-12 08:01:04,206 [main:113] - Case = [public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@24ea92b5], public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]]
2021-03-12 08:01:04,206 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@24ea92b5]
2021-03-12 08:01:04,446 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:01:04,447 [main:149] - GENERATING call of type public open fun equals(other: kotlin.Any?): kotlin.Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@6519cd8a]
2021-03-12 08:01:04,669 [main:302] - generating value of type = Any false depth = 0
2021-03-12 08:01:04,669 [main:117] - GENERATED CALL = ((5.toUByte())).equals("yjpgu").equals("kocsw")
2021-03-12 08:01:04,669 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline operator fun rangeTo(other: kotlin.UByte): kotlin.ranges.UIntRange defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@36a24bcc], @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public operator fun kotlin.ranges.UIntRange.contains(value: kotlin.UByte): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@6b5517e7]]
2021-03-12 08:01:04,669 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun rangeTo(other: kotlin.UByte): kotlin.ranges.UIntRange defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@36a24bcc]
2021-03-12 08:01:04,891 [main:302] - generating value of type = UByte true depth = 0
2021-03-12 08:01:04,904 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.ExperimentalUnsignedTypes public operator fun kotlin.ranges.UIntRange.contains(value: kotlin.UByte): kotlin.Boolean defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@6b5517e7]
2021-03-12 08:01:04,904 [main:117] - GENERATED CALL = ((5.toUByte())).rangeTo(105.toUByte()).contains((5.toUByte()))
2021-03-12 08:01:04,904 [main:113] - Case = [@kotlin.internal.InlineOnly public final inline operator fun rangeTo(other: kotlin.UByte): kotlin.ranges.UIntRange defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@36a24bcc], public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.UIntRange[DeserializedSimpleFunctionDescriptor@6c5b718e]]
2021-03-12 08:01:04,904 [main:149] - GENERATING call of type @kotlin.internal.InlineOnly public final inline operator fun rangeTo(other: kotlin.UByte): kotlin.ranges.UIntRange defined in kotlin.UByte[DeserializedSimpleFunctionDescriptor@36a24bcc]
2021-03-12 08:01:04,904 [main:149] - GENERATING call of type public open fun isEmpty(): kotlin.Boolean defined in kotlin.ranges.UIntRange[DeserializedSimpleFunctionDescriptor@6c5b718e]
2021-03-12 08:01:04,904 [main:117] - GENERATED CALL = ((5.toUByte())).rangeTo(5.toUByte()).isEmpty()
2021-03-12 08:01:04,904 [main:114] - replacement of it?.methodName?.startsWith(method) == true of type Boolean is ((5.toUByte())).toDouble().isInfinite()
2021-03-12 08:01:05,122 [main:33] - Trying to replace Element(BINARY_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:01:05,123 [main:66] - Compilation checking started
2021-03-12 08:01:06,066 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if ((Foo(1397637829, {a: Int -> -710498597}).f).invoke((Foo(416482559, {a: Int -> 23}).state)).toString((f).next()) != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (Kla2().fu4()) return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { ((5.toUByte())).toDouble().isInfinite() }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = (Kla1().fu2()).compareTo(Kla1().fu2()).unaryMinus()
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if (prope13 != i) error("xbnkb" + prope13)
            prope15()
        }
        if (-1967865395 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            Kla12().prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:01:06,070 [main:107] - replacing (prope13, Int)
2021-03-12 08:01:06,071 [main:50] - replacing prope13 Int
2021-03-12 08:01:06,071 [main:54] - Getting value of type Int
2021-03-12 08:01:06,290 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:01:06,302 [main:58] - GENERATED VALUE OF TYPE Int = -1061700377
2021-03-12 08:01:06,302 [main:61] - GENERATED IS CALL =false
2021-03-12 08:01:06,352 [main:67] - randomType = Kla2
2021-03-12 08:01:06,571 [main:302] - generating value of type = Kla2 false depth = 0
2021-03-12 08:01:06,583 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 08:01:06,589 [main:149] - GENERATING call of type public open fun fu1(): kotlin.Boolean defined in Kla2[SimpleFunctionDescriptorImpl@5f329f0b]
2021-03-12 08:01:06,589 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:01:06,589 [main:78] - Generated call from random type = (Kla2()).fu1().compareTo(Kla2().fu1())
2021-03-12 08:01:06,589 [main:106] - GETTING Int from Int
2021-03-12 08:01:06,619 [main:113] - Case = [public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc], public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@63d279b5]]
2021-03-12 08:01:06,619 [main:149] - GENERATING call of type public abstract operator fun compareTo(other: kotlin.Int): kotlin.Int defined in kotlin.Comparable[DeserializedSimpleFunctionDescriptor@2bb8aafc]
2021-03-12 08:01:06,619 [main:149] - GENERATING call of type public final infix fun and(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@63d279b5]
2021-03-12 08:01:06,839 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:01:06,851 [main:117] - GENERATED CALL = (Kla3().prope6).compareTo(f.next()).and(-1076616748)
2021-03-12 08:01:06,851 [main:113] - Case = [public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e], @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@63b7dc64]]
2021-03-12 08:01:06,851 [main:149] - GENERATING call of type public open fun toByte(): kotlin.Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5b6e2a7e]
2021-03-12 08:01:06,852 [main:149] - GENERATING call of type @kotlin.SinceKotlin public final operator fun rem(other: kotlin.Byte): kotlin.Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor@63b7dc64]
2021-03-12 08:01:07,072 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 08:01:07,084 [main:117] - GENERATED CALL = (Kla3().prope6).toByte().rem(-101)
2021-03-12 08:01:07,084 [main:113] - Case = [public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39], public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a00dab7]]
2021-03-12 08:01:07,085 [main:149] - GENERATING call of type public open fun toShort(): kotlin.Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@5aa1ba39]
2021-03-12 08:01:07,085 [main:149] - GENERATING call of type public final operator fun unaryMinus(): kotlin.Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor@5a00dab7]
2021-03-12 08:01:07,085 [main:117] - GENERATED CALL = (Kla3().prope6).toShort().unaryMinus()
2021-03-12 08:01:07,085 [main:113] - Case = [public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@799f23e6]]
2021-03-12 08:01:07,085 [main:149] - GENERATING call of type public final operator fun plus(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@799f23e6]
2021-03-12 08:01:07,085 [main:117] - GENERATED CALL = (Kla3().prope6).plus((Foo(416482559, {a: Int -> 23}).state).toByte())
2021-03-12 08:01:07,085 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@35d0f108]]
2021-03-12 08:01:07,085 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 08:01:07,085 [main:149] - GENERATING call of type public final operator fun unaryPlus(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@35d0f108]
2021-03-12 08:01:07,085 [main:117] - GENERATED CALL = (Kla3().prope6).toInt().unaryPlus()
2021-03-12 08:01:07,085 [main:113] - Case = [public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d], @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4aa16b76]]
2021-03-12 08:01:07,085 [main:149] - GENERATING call of type public final operator fun div(other: kotlin.Long): kotlin.Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@2585729d]
2021-03-12 08:01:07,305 [main:302] - generating value of type = Long true depth = 0
2021-03-12 08:01:07,317 [main:149] - GENERATING call of type @kotlin.SinceKotlin @kotlin.WasExperimental public fun kotlin.Long.countOneBits(): kotlin.Int defined in kotlin[DeserializedSimpleFunctionDescriptor@4aa16b76]
2021-03-12 08:01:07,317 [main:117] - GENERATED CALL = (Kla3().prope6).div(-378550997430384709).countOneBits()
2021-03-12 08:01:07,317 [main:113] - Case = [public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@1ece8c98]]
2021-03-12 08:01:07,317 [main:149] - GENERATING call of type public fun kotlin.Int.coerceIn(minimumValue: kotlin.Int, maximumValue: kotlin.Int): kotlin.Int defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor@1ece8c98]
2021-03-12 08:01:07,318 [main:117] - GENERATED CALL = (Kla3().prope6).coerceIn((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())), (f).next())
2021-03-12 08:01:07,318 [main:113] - Case = [public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fd6caab]]
2021-03-12 08:01:07,318 [main:149] - GENERATING call of type public final infix fun or(other: kotlin.Int): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@3fd6caab]
2021-03-12 08:01:07,318 [main:117] - GENERATED CALL = (Kla3().prope6).or((Foo(655341081, {a: Int -> -655341081}).next()))
2021-03-12 08:01:07,318 [main:113] - Case = [public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740], public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6988916a]]
2021-03-12 08:01:07,318 [main:149] - GENERATING call of type public abstract fun toInt(): kotlin.Int defined in kotlin.Number[DeserializedSimpleFunctionDescriptor@635b5740]
2021-03-12 08:01:07,318 [main:149] - GENERATING call of type public final operator fun compareTo(other: kotlin.Byte): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@6988916a]
2021-03-12 08:01:07,558 [main:302] - generating value of type = Byte true depth = 0
2021-03-12 08:01:07,571 [main:117] - GENERATED CALL = (Kla3().prope6).toInt().compareTo(124)
2021-03-12 08:01:07,571 [main:113] - Case = [public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16107de0]]
2021-03-12 08:01:07,571 [main:149] - GENERATING call of type public open fun toInt(): kotlin.Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor@16107de0]
2021-03-12 08:01:07,571 [main:117] - GENERATED CALL = (Kla3().prope6).toInt()
2021-03-12 08:01:07,572 [main:114] - replacement of prope13 of type Int is (Kla2()).fu1().compareTo(Kla2().fu1())
2021-03-12 08:01:07,791 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:01:07,791 [main:66] - Compilation checking started
2021-03-12 08:01:08,716 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if ((Foo(1397637829, {a: Int -> -710498597}).f).invoke((Foo(416482559, {a: Int -> 23}).state)).toString((f).next()) != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (Kla2().fu4()) return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf")))

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { ((5.toUByte())).toDouble().isInfinite() }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = (Kla1().fu2()).compareTo(Kla1().fu2()).unaryMinus()
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if ((Kla2()).fu1().compareTo(Kla2().fu1()) != i) error("xbnkb" + prope13)
            prope15()
        }
        if (-1967865395 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            Kla12().prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:01:08,720 [main:107] - replacing (prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf"))), Unit?)
2021-03-12 08:01:08,721 [main:50] - replacing prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf"))) Unit?
2021-03-12 08:01:08,721 [main:54] - Getting value of type Unit?
2021-03-12 08:01:08,941 [main:302] - generating value of type = Unit false depth = 0
2021-03-12 08:01:09,178 [main:43] - GENERATING CALL OF fun repeat(times: kotlin.Int, action: (kotlin.Int)->kotlin.Unit): Unit = TODO()
2021-03-12 08:01:09,193 [main:61] - WITHOUT TYPE PARAMS = fun repeat(times: kotlin.Int, action: (kotlin.Int)->kotlin.Unit): Unit = TODO()
2021-03-12 08:01:10,026 [main:302] - generating value of type = Int true depth = 3
2021-03-12 08:01:10,039 [main:302] - generating value of type = Function1<Int, Unit> false depth = 3
2021-03-12 08:01:10,051 [main:302] - generating value of type = Unit false depth = 4
2021-03-12 08:01:10,067 [main:95] - GENERATED = repeat(1721558263, {a: Int -> println()})
2021-03-12 08:01:10,068 [main:58] - GENERATED VALUE OF TYPE Unit? = repeat(1721558263, {a: Int -> println()})
2021-03-12 08:01:10,068 [main:61] - GENERATED IS CALL =true
2021-03-12 08:01:10,506 [main:67] - randomType = Triple<Float, String, Kla2>
2021-03-12 08:01:10,728 [main:302] - generating value of type = Triple<Float, String, Kla2> false depth = 0
2021-03-12 08:01:10,963 [main:43] - GENERATING CALL OF fun <A, B, C> Triple(first: Float, second: String, third: Kla2): Triple<Float, String, Kla2> = TODO()
2021-03-12 08:01:10,977 [main:61] - WITHOUT TYPE PARAMS = fun <A, B, C> Triple(first: Float, second: String, third: Kla2): Triple<Float, String, Kla2> = TODO()
2021-03-12 08:01:11,251 [main:302] - generating value of type = Float true depth = 3
2021-03-12 08:01:11,264 [main:302] - generating value of type = String true depth = 3
2021-03-12 08:01:11,276 [main:302] - generating value of type = Kla2 false depth = 3
2021-03-12 08:01:11,288 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 08:01:11,289 [main:95] - GENERATED = Triple<Float, String, Kla2>(0.85970116f, "krknd", Kla2())
2021-03-12 08:01:11,302 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:11,309 [main:106] - GETTING Unit? from UShort
2021-03-12 08:01:11,331 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:11,359 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:11,360 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:11,361 [main:106] - GETTING Unit? from Char
2021-03-12 08:01:11,378 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:11,379 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:11,380 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:11,389 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:01:11,398 [main:106] - GETTING Unit? from Kla2
2021-03-12 08:01:11,403 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:11,404 [main:106] - GETTING Unit? from Kla0
2021-03-12 08:01:11,407 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:11,408 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:11,409 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:11,410 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:11,411 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:11,411 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:11,412 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:11,413 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:11,414 [main:106] - GETTING Unit? from UByte
2021-03-12 08:01:11,436 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:11,437 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:11,438 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:11,438 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:11,439 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:11,440 [main:106] - GETTING Unit? from Kla0
2021-03-12 08:01:11,441 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:11,442 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:01:11,442 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:11,443 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:11,444 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:11,445 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:11,446 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:11,446 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:11,447 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:11,448 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:01:11,449 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:11,450 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:11,451 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:01:11,451 [main:106] - GETTING Unit? from Float
2021-03-12 08:01:11,480 [main:106] - GETTING Unit? from Byte
2021-03-12 08:01:11,509 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:11,510 [main:106] - GETTING Unit? from UByte
2021-03-12 08:01:11,511 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:11,512 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:11,512 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:11,513 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:11,514 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:11,515 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:11,516 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:11,516 [main:114] - replacement of prope8?.resume(Kla4(((f).next()).toChar().plus("wgcyf"))) of type Unit? is repeat(1721558263, {a: Int -> println()})
2021-03-12 08:01:11,735 [main:33] - Trying to replace Element(SAFE_ACCESS_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:01:11,735 [main:66] - Compilation checking started
2021-03-12 08:01:12,661 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if ((Foo(1397637829, {a: Int -> -710498597}).f).invoke((Foo(416482559, {a: Int -> 23}).state)).toString((f).next()) != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (Kla2().fu4()) return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    repeat(1721558263, {a: Int -> println()})

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { ((5.toUByte())).toDouble().isInfinite() }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = (Kla1().fu2()).compareTo(Kla1().fu2()).unaryMinus()
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if ((Kla2()).fu1().compareTo(Kla2().fu1()) != i) error("xbnkb" + prope13)
            prope15()
        }
        if (-1967865395 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            Kla12().prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:01:12,666 [main:107] - replacing (value, Ty0)
2021-03-12 08:01:12,666 [main:50] - replacing value Ty0
2021-03-12 08:01:12,666 [main:54] - Getting value of type Ty0
2021-03-12 08:01:12,885 [main:302] - generating value of type = Ty0 false depth = 0
2021-03-12 08:01:12,900 [main:58] - GENERATED VALUE OF TYPE Ty0 = 
2021-03-12 08:01:13,531 [main:67] - randomType = Set<Foo>
2021-03-12 08:01:13,532 [main:106] - GETTING Ty0 from UByte
2021-03-12 08:01:13,554 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:01:13,562 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:01:13,563 [main:106] - GETTING Ty0 from Int
2021-03-12 08:01:13,593 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:01:13,602 [main:106] - GETTING Ty0 from Int
2021-03-12 08:01:13,602 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:01:13,603 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:01:13,603 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:01:13,604 [main:106] - GETTING Ty0 from Kla0
2021-03-12 08:01:13,608 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 08:01:13,618 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:01:13,618 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:01:13,619 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:01:13,619 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:01:13,620 [main:106] - GETTING Ty0 from Int
2021-03-12 08:01:13,621 [main:106] - GETTING Ty0 from Char
2021-03-12 08:01:13,638 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:01:13,639 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:01:13,639 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:01:13,640 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:01:13,640 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:01:13,641 [main:106] - GETTING Ty0 from Int
2021-03-12 08:01:13,641 [main:106] - GETTING Ty0 from Int
2021-03-12 08:01:13,642 [main:106] - GETTING Ty0 from Int
2021-03-12 08:01:13,643 [main:106] - GETTING Ty0 from Int
2021-03-12 08:01:13,643 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 08:01:13,644 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:01:13,644 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:01:13,645 [main:106] - GETTING Ty0 from Kla2
2021-03-12 08:01:13,651 [main:106] - GETTING Ty0 from Int
2021-03-12 08:01:13,652 [main:106] - GETTING Ty0 from Int
2021-03-12 08:01:13,652 [main:106] - GETTING Ty0 from Int
2021-03-12 08:01:13,653 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:01:13,654 [main:106] - GETTING Ty0 from Byte
2021-03-12 08:01:13,683 [main:106] - GETTING Ty0 from Int
2021-03-12 08:01:13,684 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:01:13,684 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:01:13,685 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:01:13,685 [main:106] - GETTING Ty0 from Boolean
2021-03-12 08:01:13,686 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 08:01:13,687 [main:106] - GETTING Ty0 from Int
2021-03-12 08:01:13,687 [main:106] - GETTING Ty0 from UByte
2021-03-12 08:01:13,688 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:01:13,688 [main:106] - GETTING Ty0 from Kla0
2021-03-12 08:01:13,689 [main:106] - GETTING Ty0 from UShort
2021-03-12 08:01:13,711 [main:106] - GETTING Ty0 from Function1<Int, Int>
2021-03-12 08:01:13,711 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:01:13,712 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:01:13,713 [main:106] - GETTING Ty0 from Float
2021-03-12 08:01:13,741 [main:106] - GETTING Ty0 from Int
2021-03-12 08:01:13,742 [main:106] - GETTING Ty0 from Foo
2021-03-12 08:01:13,742 [main:111] - Cant find and generate replacement for value type Ty0
2021-03-12 08:01:13,742 [main:107] - replacing (prope8?.resume("OK"), Unit?)
2021-03-12 08:01:13,742 [main:50] - replacing prope8?.resume("OK") Unit?
2021-03-12 08:01:13,742 [main:54] - Getting value of type Unit?
2021-03-12 08:01:13,960 [main:302] - generating value of type = Unit false depth = 0
2021-03-12 08:01:13,976 [main:58] - GENERATED VALUE OF TYPE Unit? = println()
2021-03-12 08:01:13,976 [main:61] - GENERATED IS CALL =true
2021-03-12 08:01:14,025 [main:67] - randomType = Kla12
2021-03-12 08:01:14,243 [main:302] - generating value of type = Kla12 false depth = 0
2021-03-12 08:01:14,255 [main:112] - generating klass Kla12 text = class Kla12 {
    private var prope13 = (Kla1().fu2()).compareTo(Kla1().fu2()).unaryMinus()
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if ((Kla2()).fu1().compareTo(Kla2().fu1()) != i) error("xbnkb" + prope13)
            prope15()
        }
        if (-1967865395 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}
2021-03-12 08:01:14,262 [main:149] - GENERATING call of type public final suspend fun fu20(): kotlin.Unit defined in Kla12[SimpleFunctionDescriptorImpl@151da2e8]
2021-03-12 08:01:14,262 [main:78] - Generated call from random type = (Kla12()).fu20()
2021-03-12 08:01:14,263 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:14,271 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:01:14,280 [main:106] - GETTING Unit? from Kla0
2021-03-12 08:01:14,283 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:14,291 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:14,292 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:01:14,293 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:14,294 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:14,295 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:14,296 [main:106] - GETTING Unit? from Kla0
2021-03-12 08:01:14,296 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:14,297 [main:106] - GETTING Unit? from Char
2021-03-12 08:01:14,315 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:14,316 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:14,317 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:14,318 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:14,318 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:14,319 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:14,349 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:14,350 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:14,350 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:14,351 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:14,352 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:14,353 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:14,354 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:14,354 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:14,355 [main:106] - GETTING Unit? from Float
2021-03-12 08:01:14,407 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:14,408 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:14,409 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:14,410 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:14,411 [main:106] - GETTING Unit? from UByte
2021-03-12 08:01:14,433 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:14,433 [main:106] - GETTING Unit? from UShort
2021-03-12 08:01:14,455 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:14,456 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:14,457 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:14,458 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:01:14,458 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:14,459 [main:106] - GETTING Unit? from Kla2
2021-03-12 08:01:14,465 [main:106] - GETTING Unit? from Function1<Int, Int>
2021-03-12 08:01:14,466 [main:106] - GETTING Unit? from Byte
2021-03-12 08:01:14,495 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:14,496 [main:106] - GETTING Unit? from UByte
2021-03-12 08:01:14,497 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:14,498 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:14,499 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:14,499 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:14,500 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:14,501 [main:106] - GETTING Unit? from Foo
2021-03-12 08:01:14,502 [main:106] - GETTING Unit? from Int
2021-03-12 08:01:14,503 [main:106] - GETTING Unit? from Boolean
2021-03-12 08:01:14,503 [main:114] - replacement of prope8?.resume("OK") of type Unit? is (Kla12()).fu20()
2021-03-12 08:01:14,719 [main:33] - Trying to replace Element(SAFE_ACCESS_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:01:14,719 [main:66] - Compilation checking started
2021-03-12 08:01:15,340 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if ((Foo(1397637829, {a: Int -> -710498597}).f).invoke((Foo(416482559, {a: Int -> 23}).state)).toString((f).next()) != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    (Kla12()).fu20()

    if (Kla2().fu4()) return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    repeat(1721558263, {a: Int -> println()})

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { ((5.toUByte())).toDouble().isInfinite() }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = (Kla1().fu2()).compareTo(Kla1().fu2()).unaryMinus()
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if ((Kla2()).fu1().compareTo(Kla2().fu1()) != i) error("xbnkb" + prope13)
            prope15()
        }
        if (-1967865395 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            Kla12().prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:01:15,344 [main:107] - replacing (s, String)
2021-03-12 08:01:15,344 [main:50] - replacing s String
2021-03-12 08:01:15,344 [main:54] - Getting value of type String
2021-03-12 08:01:15,564 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:01:15,576 [main:58] - GENERATED VALUE OF TYPE String = "iumaz"
2021-03-12 08:01:15,576 [main:61] - GENERATED IS CALL =false
2021-03-12 08:01:15,913 [main:67] - randomType = Kla9?
2021-03-12 08:01:16,131 [main:302] - generating value of type = Kla9 false depth = 0
2021-03-12 08:01:16,143 [main:112] - generating klass Kla9 text = class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}
2021-03-12 08:01:16,157 [main:149] - GENERATING call of type public fun kotlin.Any?.toString(): kotlin.String defined in kotlin[DeserializedSimpleFunctionDescriptor@7d7ab689]
2021-03-12 08:01:16,158 [main:78] - Generated call from random type = (Kla9())?.prope11?.toString()!!
2021-03-12 08:01:16,158 [main:106] - GETTING String from Boolean
2021-03-12 08:01:16,166 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 08:01:16,166 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:01:16,166 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 08:01:16,384 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:01:16,396 [main:117] - GENERATED CALL = (Kla2().fu4()).compareTo(Kla1().fu3()).toString(329113056)
2021-03-12 08:01:16,397 [main:114] - replacement of s of type String is (Kla9())?.prope11?.toString()!!
2021-03-12 08:01:16,613 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(POSTFIX_EXPRESSION)
2021-03-12 08:01:16,614 [main:66] - Compilation checking started
2021-03-12 08:01:17,254 [main:49] - Result = false
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").(Kla9())?.prope11?.toString()!!
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if ((Foo(1397637829, {a: Int -> -710498597}).f).invoke((Foo(416482559, {a: Int -> 23}).state)).toString((f).next()) != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (Kla2().fu4()) return "FAIL 2 $prope11"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    repeat(1721558263, {a: Int -> println()})

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { ((5.toUByte())).toDouble().isInfinite() }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = (Kla1().fu2()).compareTo(Kla1().fu2()).unaryMinus()
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if ((Kla2()).fu1().compareTo(Kla2().fu1()) != i) error("xbnkb" + prope13)
            prope15()
        }
        if (-1967865395 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            Kla12().prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:01:17,259 [main:107] - replacing (prope11, String)
2021-03-12 08:01:17,259 [main:50] - replacing prope11 String
2021-03-12 08:01:17,259 [main:54] - Getting value of type String
2021-03-12 08:01:17,477 [main:302] - generating value of type = String true depth = 0
2021-03-12 08:01:17,489 [main:58] - GENERATED VALUE OF TYPE String = "invzm"
2021-03-12 08:01:17,489 [main:61] - GENERATED IS CALL =false
2021-03-12 08:01:17,539 [main:67] - randomType = Kla5
2021-03-12 08:01:17,757 [main:302] - generating value of type = Kla5 false depth = 0
2021-03-12 08:01:17,769 [main:112] - generating klass Kla5 text = class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}
2021-03-12 08:01:17,986 [main:194] - Type params = []
2021-03-12 08:01:18,233 [main:149] - GENERATING call of type public final suspend fun fu13(): kotlin.String defined in Kla5[SimpleFunctionDescriptorImpl@30b64bfc]
2021-03-12 08:01:18,233 [main:149] - GENERATING call of type public fun kotlin.String.decapitalize(): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@1dfdfaa2]
2021-03-12 08:01:18,233 [main:78] - Generated call from random type = (Kla5()).fu13().decapitalize()
2021-03-12 08:01:18,234 [main:106] - GETTING String from Boolean
2021-03-12 08:01:18,244 [main:113] - Case = [public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b], @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]]
2021-03-12 08:01:18,244 [main:149] - GENERATING call of type public open fun compareTo(other: kotlin.Boolean): kotlin.Int defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor@4c7df19b]
2021-03-12 08:01:18,244 [main:149] - GENERATING call of type @kotlin.SinceKotlin public fun kotlin.Int.toString(radix: kotlin.Int): kotlin.String defined in kotlin.text[DeserializedSimpleFunctionDescriptor@79fa88fb]
2021-03-12 08:01:18,470 [main:302] - generating value of type = Int true depth = 0
2021-03-12 08:01:18,482 [main:117] - GENERATED CALL = (Kla2().fu3()).compareTo(Kla2().fu4()).toString(-141816163)
2021-03-12 08:01:18,482 [main:114] - replacement of prope11 of type String is (Kla5()).fu13().decapitalize()
2021-03-12 08:01:18,702 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(DOT_QUALIFIED_EXPRESSION)
2021-03-12 08:01:18,703 [main:66] - Compilation checking started
2021-03-12 08:01:19,620 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if ((Foo(1397637829, {a: Int -> -710498597}).f).invoke((Foo(416482559, {a: Int -> 23}).state)).toString((f).next()) != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (Kla2().fu4()) return "FAIL 2 $(Kla5()).fu13().decapitalize()"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    repeat(1721558263, {a: Int -> println()})

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { ((5.toUByte())).toDouble().isInfinite() }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = (Kla1().fu2()).compareTo(Kla1().fu2()).unaryMinus()
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if ((Kla2()).fu1().compareTo(Kla2().fu1()) != i) error("xbnkb" + prope13)
            prope15()
        }
        if (-1967865395 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            Kla12().prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:01:19,624 [main:107] - replacing (EmptyCoroutineContext, EmptyCoroutineContext)
2021-03-12 08:01:19,624 [main:50] - replacing EmptyCoroutineContext EmptyCoroutineContext
2021-03-12 08:01:19,624 [main:54] - Getting value of type EmptyCoroutineContext
2021-03-12 08:01:19,849 [main:302] - generating value of type = EmptyCoroutineContext false depth = 0
2021-03-12 08:01:19,864 [main:58] - GENERATED VALUE OF TYPE EmptyCoroutineContext = 
2021-03-12 08:01:20,578 [main:67] - randomType = Triple<Kla2, Kla7, Short>
2021-03-12 08:01:20,795 [main:302] - generating value of type = Triple<Kla2, Kla7, Short> false depth = 0
2021-03-12 08:01:21,028 [main:43] - GENERATING CALL OF fun <A, B, C> Triple(first: Kla2, second: Kla7, third: Short): Triple<Kla2, Kla7, Short> = TODO()
2021-03-12 08:01:21,043 [main:61] - WITHOUT TYPE PARAMS = fun <A, B, C> Triple(first: Kla2, second: Kla7, third: Short): Triple<Kla2, Kla7, Short> = TODO()
2021-03-12 08:01:21,280 [main:302] - generating value of type = Kla2 false depth = 3
2021-03-12 08:01:21,293 [main:112] - generating klass Kla2 text = class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}
2021-03-12 08:01:21,293 [main:302] - generating value of type = Kla7 false depth = 3
2021-03-12 08:01:21,305 [main:112] - generating klass Kla7 text = class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}
2021-03-12 08:01:21,305 [main:302] - generating value of type = Short true depth = 3
2021-03-12 08:01:21,321 [main:95] - GENERATED = Triple<Kla2, Kla7, Short>(Kla2(), Kla7(), -1841)
2021-03-12 08:01:21,338 [main:106] - GETTING EmptyCoroutineContext from Function1<Int, Int>
2021-03-12 08:01:21,347 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:01:21,355 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:01:21,356 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:01:21,363 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:01:21,364 [main:106] - GETTING EmptyCoroutineContext from Float
2021-03-12 08:01:21,391 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:01:21,420 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:01:21,420 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:01:21,421 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:01:21,422 [main:106] - GETTING EmptyCoroutineContext from Function1<Int, Int>
2021-03-12 08:01:21,422 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:01:21,423 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:01:21,424 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:01:21,424 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:01:21,425 [main:106] - GETTING EmptyCoroutineContext from UShort
2021-03-12 08:01:21,447 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:01:21,447 [main:106] - GETTING EmptyCoroutineContext from Function1<Int, Int>
2021-03-12 08:01:21,448 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:01:21,449 [main:106] - GETTING EmptyCoroutineContext from Char
2021-03-12 08:01:21,466 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:01:21,466 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:01:21,467 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:01:21,468 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:01:21,468 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:01:21,469 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:01:21,469 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:01:21,470 [main:106] - GETTING EmptyCoroutineContext from UByte
2021-03-12 08:01:21,492 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:01:21,493 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:01:21,493 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:01:21,494 [main:106] - GETTING EmptyCoroutineContext from Kla0
2021-03-12 08:01:21,498 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:01:21,498 [main:106] - GETTING EmptyCoroutineContext from Function1<Int, Int>
2021-03-12 08:01:21,499 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:01:21,499 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:01:21,500 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:01:21,501 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:01:21,501 [main:106] - GETTING EmptyCoroutineContext from UByte
2021-03-12 08:01:21,502 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:01:21,502 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:01:21,503 [main:106] - GETTING EmptyCoroutineContext from Kla2
2021-03-12 08:01:21,509 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:01:21,510 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:01:21,510 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:01:21,511 [main:106] - GETTING EmptyCoroutineContext from Kla0
2021-03-12 08:01:21,511 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:01:21,512 [main:106] - GETTING EmptyCoroutineContext from Byte
2021-03-12 08:01:21,560 [main:106] - GETTING EmptyCoroutineContext from Int
2021-03-12 08:01:21,561 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:01:21,562 [main:106] - GETTING EmptyCoroutineContext from Boolean
2021-03-12 08:01:21,562 [main:106] - GETTING EmptyCoroutineContext from Foo
2021-03-12 08:01:21,562 [main:111] - Cant find and generate replacement for EmptyCoroutineContext type EmptyCoroutineContext
2021-03-12 08:01:21,562 [main:107] - replacing (this, Kla9)
2021-03-12 08:01:21,562 [main:50] - replacing this Kla9
2021-03-12 08:01:21,562 [main:54] - Getting value of type Kla9
2021-03-12 08:01:21,783 [main:302] - generating value of type = Kla9 false depth = 0
2021-03-12 08:01:21,796 [main:112] - generating klass Kla9 text = class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
this.prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}
2021-03-12 08:01:21,796 [main:58] - GENERATED VALUE OF TYPE Kla9 = Kla9()
2021-03-12 08:01:21,796 [main:61] - GENERATED IS CALL =true
2021-03-12 08:01:22,107 [main:67] - randomType = Kla7
2021-03-12 08:01:22,326 [main:302] - generating value of type = Kla7 false depth = 0
2021-03-12 08:01:22,338 [main:112] - generating klass Kla7 text = class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}
2021-03-12 08:01:22,346 [main:106] - GETTING Kla9 from Byte
2021-03-12 08:01:22,375 [main:106] - GETTING Kla9 from Foo
2021-03-12 08:01:22,382 [main:106] - GETTING Kla9 from Int
2021-03-12 08:01:22,410 [main:106] - GETTING Kla9 from Float
2021-03-12 08:01:22,437 [main:106] - GETTING Kla9 from Boolean
2021-03-12 08:01:22,445 [main:106] - GETTING Kla9 from Boolean
2021-03-12 08:01:22,446 [main:106] - GETTING Kla9 from Int
2021-03-12 08:01:22,446 [main:106] - GETTING Kla9 from Int
2021-03-12 08:01:22,447 [main:106] - GETTING Kla9 from Foo
2021-03-12 08:01:22,447 [main:106] - GETTING Kla9 from Boolean
2021-03-12 08:01:22,448 [main:106] - GETTING Kla9 from Boolean
2021-03-12 08:01:22,448 [main:106] - GETTING Kla9 from Int
2021-03-12 08:01:22,449 [main:106] - GETTING Kla9 from Int
2021-03-12 08:01:22,450 [main:106] - GETTING Kla9 from Boolean
2021-03-12 08:01:22,450 [main:106] - GETTING Kla9 from Function1<Int, Int>
2021-03-12 08:01:22,460 [main:106] - GETTING Kla9 from Int
2021-03-12 08:01:22,461 [main:106] - GETTING Kla9 from Kla2
2021-03-12 08:01:22,466 [main:106] - GETTING Kla9 from Foo
2021-03-12 08:01:22,466 [main:106] - GETTING Kla9 from Foo
2021-03-12 08:01:22,467 [main:106] - GETTING Kla9 from Boolean
2021-03-12 08:01:22,468 [main:106] - GETTING Kla9 from Boolean
2021-03-12 08:01:22,468 [main:106] - GETTING Kla9 from Foo
2021-03-12 08:01:22,469 [main:106] - GETTING Kla9 from Foo
2021-03-12 08:01:22,469 [main:106] - GETTING Kla9 from Char
2021-03-12 08:01:22,487 [main:106] - GETTING Kla9 from Int
2021-03-12 08:01:22,487 [main:106] - GETTING Kla9 from UByte
2021-03-12 08:01:22,508 [main:106] - GETTING Kla9 from Int
2021-03-12 08:01:22,509 [main:106] - GETTING Kla9 from UShort
2021-03-12 08:01:22,530 [main:106] - GETTING Kla9 from Boolean
2021-03-12 08:01:22,530 [main:106] - GETTING Kla9 from Kla0
2021-03-12 08:01:22,534 [main:106] - GETTING Kla9 from Boolean
2021-03-12 08:01:22,534 [main:106] - GETTING Kla9 from Function1<Int, Int>
2021-03-12 08:01:22,535 [main:106] - GETTING Kla9 from Boolean
2021-03-12 08:01:22,535 [main:106] - GETTING Kla9 from Foo
2021-03-12 08:01:22,536 [main:106] - GETTING Kla9 from Foo
2021-03-12 08:01:22,537 [main:106] - GETTING Kla9 from Int
2021-03-12 08:01:22,537 [main:106] - GETTING Kla9 from Foo
2021-03-12 08:01:22,538 [main:106] - GETTING Kla9 from UByte
2021-03-12 08:01:22,538 [main:106] - GETTING Kla9 from Boolean
2021-03-12 08:01:22,539 [main:106] - GETTING Kla9 from Foo
2021-03-12 08:01:22,539 [main:106] - GETTING Kla9 from Boolean
2021-03-12 08:01:22,540 [main:106] - GETTING Kla9 from Int
2021-03-12 08:01:22,541 [main:106] - GETTING Kla9 from Foo
2021-03-12 08:01:22,541 [main:106] - GETTING Kla9 from Boolean
2021-03-12 08:01:22,542 [main:106] - GETTING Kla9 from Int
2021-03-12 08:01:22,542 [main:106] - GETTING Kla9 from Kla0
2021-03-12 08:01:22,543 [main:106] - GETTING Kla9 from Boolean
2021-03-12 08:01:22,543 [main:106] - GETTING Kla9 from Function1<Int, Int>
2021-03-12 08:01:22,544 [main:106] - GETTING Kla9 from Boolean
2021-03-12 08:01:22,545 [main:106] - GETTING Kla9 from Int
2021-03-12 08:01:22,545 [main:106] - GETTING Kla9 from Function1<Int, Int>
2021-03-12 08:01:22,546 [main:106] - GETTING Kla9 from Int
2021-03-12 08:01:22,546 [main:114] - replacement of this of type Kla9 is Kla9()
2021-03-12 08:01:22,764 [main:33] - Trying to replace Element(REFERENCE_EXPRESSION) on Element(CALL_EXPRESSION)
2021-03-12 08:01:22,764 [main:66] - Compilation checking started
2021-03-12 08:01:23,714 [main:53] - Result = true
Text:

import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.CoroutineStackFrame
class Foo(
        var state : Int,
        val f : (Int) -> Int){

    fun next() : Int {
        val nextState = f(state)
        state = nextState
        return state
    }
}

fun box(): String {
    val f = Foo(23, {x -> 2 * x})
    return if (f.next() == 46) "OK" else "fail"
}

interface Kla0 {
    fun fu1(): Boolean
    fun fu2(): Boolean
    fun fu3(): Boolean
    fun fu4(): Boolean
}

class Kla1 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = (f.next()).toChar().isDefined(); true }
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert((Foo(-655341081, {a: Int -> 120045518}).next()).toChar().isDigit())
        }
        prope4()
        return (Foo(46, {a: Int -> -519820721})).equals("uowxm").not()
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { Kla1().fu2()}
        val prope4 = fun() {
            assert(prope3())
        }
        prope4()
        return (Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3())
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (f.next()).div((141840546.toUInt())?.toDouble()).isNaN()
        val prope3 = { true}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(true) { (Foo(-655341081, {a: Int -> (f).next()}).state).compareTo(Foo(-655341081, {a: Int -> 23}).state).toString(Foo(Foo(655341081, {a: Int -> -655341081}).next(), {a: Int -> (f).next()}).state) }
        }
        prope4()
        return prope2
    }

    override fun fu4(): Boolean {
        var prope2 = (Foo(Foo(-655341081, {a: Int -> 120045518}).state, {a: Int -> 23}).next()).equals("phnso").and(false)
        val prope3 = { false}
        val prope4 = fun() {
            val f = Foo(23, {x -> 2 * x})
assert(prope3()) { "meyol"}
        }
        { print("zvmtb")}()
        return prope2
    }
}

class Kla2 : Kla0 {
    override fun fu1(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (Foo(f.next(), {a: Int -> -1126701799}))?.equals("wvwqe").or(equals("gdldf"))
        val prope3 = { equals("chvog")}
        val prope4 = { require((Foo(23, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).next()}).f).equals("qrxpj").and(Kla2().fu3()), { "afdkd"})}
        prope4()
        return prope2
    }

    override fun fu2(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = (141840546.toUInt())?.toDouble().isNaN()
        val prope3 = { prope2 = true; false }
        val prope4 = { println("yiivr")}
        prope4()
        return prope2
    }

    override fun fu3(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { f.next() == 46}
        val prope4 = { repeat(655341081, {a: Int -> require(equals("uowxm"), { "mynyf"})})}
        { print("zdbjr")}()
        return (Foo(23, {a: Int -> 120045518}).f).equals("chvog").or(true)
    }

    override fun fu4(): Boolean {
        val f = Foo(23, {x -> 2 * x})
var prope2 = false
        val prope3 = { prope2 = true; false }
        val prope4 = { check(false)}
        { println()}()
        return prope2
    }
}

fun fu0(v: Boolean): Kla0 {
    val f = Foo(23, {x -> 2 * x})
val prope0 = Kla0::class.java.classLoader
    prope0.setPackageAssertionStatus((Foo(655341081, {a: Int -> -655341081}).next()).toChar().plus("ftdyx"), v)
    val prope1 = prope0.loadClass((f.next()).div((f.next()).div(5498065849600101788)).toString(f.next()))
    return Kla1()
}

fun box980(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
    if (Kla2().fu1()) return "FAIL 0"
    if (Kla2().fu3()) return "FAIL 1"
    if (prope1.fu2()) return "FAIL 2"
    if ((Foo(-655341081, {a: Int -> 120045518}).state).toFloat().isNaN()) return (f).next().toString(Foo(-655341081, {a: Int -> 120045518}).next())
    prope1 = Kla1()
    if (!Kla2().fu1()) return "FAIL 4"
    if ((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy").not()) return "wexjk"
    try {
        Kla1().fu2()
        return (f.next()).toChar().uppercase()
    } catch (ignore: AssertionError) {
    }
    try {
        prope1.fu4()
        return (5.toUByte()).toUShort().toString(Foo(-655341081, {a: Int -> -469178626}).state)
    } catch (ignore: AssertionError) {
    }

    return (f).next().toString(Foo(655341081, {a: Int -> -655341081}).next())
}

val prope5 by lazy { 1 }

class Kla3 {
    val prope6 by lazy { -655341081}
}

fun box834(): String {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
val prope7 by lazy { 3 }

    if ((Foo(655341081, {a: Int -> -655341081}).next()).compareTo((f.next())).inv() != 1) throw AssertionError()
    if ((Foo(655341081, {a: Int -> 655341081})).equals("fkmpu")) throw AssertionError()
    if ((Foo(416482559, {a: Int -> -655341081})).f.equals("nckoa")) throw AssertionError()

    return (Foo(416482559, {a: Int -> 23}).state).toByte().toString(-223322045)
}

fun fu5(prope8: suspend () -> Unit) {
    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope8.startCoroutine(Kla8)
}

@Suppress("UNSUPPORTED_FEATURE")
inline class Kla4(val s: String)

var prope8: Continuation<Any>? = null

suspend fun <Ty0> fu6(): Ty0 = suspendCoroutine {
    @Suppress("UNCHECKED_CAST")
    prope8 = it as Continuation<Any>
}

class Kla5() {

    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu10(ss: Kla4): Kla4 = Kla4("qevti")

    suspend fun <Ty0> fu11(t: Ty0): Ty0 = t

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return fu9(Kla4("eohor"))
    }

    suspend fun fu13() = Kla4("pmsta").s
}

class Kla6 {

    suspend fun fu9(value: Kla4): Kla4 = value

    suspend fun fu10(s: String): Kla4 = Kla4((Foo(1397637829, {a: Int -> -710498597}).state).toChar().uppercase())

    suspend fun fu11(): String = (Kla6()).fu11().drop(1591122681)

    suspend fun fu12(): Kla4 {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
return Kla4("ocnfy")
    }

    suspend fun fu13() = Kla4("tfgaa").s
}

class Kla7 {
    suspend fun <Ty0> fu9(value: Ty0): Ty0 = value

    suspend fun fu12(): Kla4 {
        return fu9(fu6<Kla4>())
    }

    suspend fun fu13() = fu12().s
}

fun box481(): String {

    val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
var prope11 = (f.next()).toInt().toString(Foo(416482559, {a: Int -> 23}).state)
    fu5 {
        prope11 = Kla5().fu13()
    }
    println("fktzz")

    if ((Foo(1397637829, {a: Int -> -710498597}).f).invoke((Foo(416482559, {a: Int -> 23}).state)).toString((f).next()) != "OK") return "FAIL 1 $prope11"

    prope11 = "FAIL2"

    fu5 {
        prope11 = Kla6().fu13()
    }
    prope8?.resume("OK")

    if (Kla2().fu4()) return "FAIL 2 $(Kla5()).fu13().decapitalize()"

    prope11 = "scvwa"

    fu5 {
        prope11 = "blkpg"
    }
    repeat(1721558263, {a: Int -> println()})

    return prope11
}

fun <Ty0> fu7(x: (Ty0) -> Unit): Continuation<Ty0> = object: Continuation<Ty0> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
x(prope11.getOrThrow())
    }
}

fun fu8(x: (Throwable) -> Unit): Continuation<Any?> = object: Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
null
    }
}

open class Kla8(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation<Any?> {
    companion object Kla14 : Kla8()
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
"uzone"
    }
}

class Kla9 : Continuation<Any?> {
    override val context = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Any?>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
Kla9().prope11 = runCatching<Any?>({ "gfgoz"}).getOrThrow()
    }

    var prope11: Any? = null
}

abstract class Kla10<in Ty0> : Continuation<Ty0> {
    override val context: CoroutineContext = EmptyCoroutineContext
    override fun resumeWith(prope11: Result<Ty0>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (((Foo(416482559, {a: Int -> 23}).state).toByte()).div(0.4132480619111175).isFinite()) {
            resume(prope11.getOrThrow())
        } else {
            fu14(prope11.exceptionOrNull()!!)
        }
    }

    abstract fun fu14(exception: Throwable)
    abstract fun resume(value: Ty0)
}

class Kla11 {
    private val prope12 = arrayListOf<StackTraceElement?>()

    suspend fun fu16() = suspendCoroutineUninterceptedOrReturn<Unit> {a: Continuation<Unit> -> check(false, { "iqgeu"})}

    fun fu16(prope8: Continuation<*>) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
if (prope8 !is CoroutineStackFrame) error("Continuation " + prope8 + " is not subtype of CoroutineStackFrame")
        prope12.clear()
        var prope16: CoroutineStackFrame? = prope8
        while (prope16 != null) {
            prope12.add(prope16.getStackTraceElement())
            prope16 = prope16.callerFrame
        }
    }

    fun fu17(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { ((5.toUByte())).toDouble().isInfinite() }?.let { error((prope1.fu4()).compareTo((Foo(-655341081, {a: Int -> Foo(-655341081, {a: Int -> 120045518}).state}).f).equals("mhigy")).toString(Foo(1397637829, {a: Int -> -710498597}).state) + " has state-machine " +
                prope12.joinToString(separator = ((f)).next().toString(Foo(1397637829, {a: Int -> -710498597}).state))) }
    }

    fun fu18(method: String) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope12.find { false} ?: error("tail-call optimization hit: method " + (5.toUByte()).toByte().toString(Foo(1397637829, {a: Int -> -710498597}).next()) + " has no state-machine " +
                prope12.joinToString(separator = "\n"))
    }
}

val prope9 = Kla11()

class Kla12 {
    private var prope13 = (Kla1().fu2()).compareTo(Kla1().fu2()).unaryMinus()
    var prope14 = false

    var prope15: () -> Unit = {}

    fun fu19() {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope13 = ((f.next())).toShort().toInt()
        prope14 = (Pair<Float, String?>(0.4163946f, "eegmu"))?.equals("jqhes").or(Kla1().fu3())
        prope15 = {}
    }

    suspend fun fu20() = suspendCoroutine<Unit> { prope8 ->
        prope13++
        prope15 = { require(false)}
    }

    fun fu21(numberOfSuspensions: Int, checkFinished: Boolean = (Foo(1397637829, {a: Int -> -710498597}).next()).equals(null).or(Kla2().fu1())) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
for (i in (Kla2().fu1()).compareTo(false).until((Foo(416482559, {a: Int -> 23}).state).toByte())) {
            if ((Kla2()).fu1().compareTo(Kla2().fu1()) != i) error("xbnkb" + prope13)
            prope15()
        }
        if (-1967865395 != (Kla1().fu1()).compareTo(true).xor(Foo(1397637829, {a: Int -> -710498597}).next()))
            error("geedb" + (Kla4("qcyax")).s.length)
        if ((Kla1().fu3()).equals("pqxbu").and(Kla1().fu2())) error("Wrong state-machine generated: it is finished early")
        prope15()
        if ((Kla13).equals("zjzbk").or(Kla2().fu4())) error("Wrong state-machine generated: it is not finished yet")
    }
}

val prope10 = Kla12()

object Kla13: Kla10<Unit>() {
    override val context: CoroutineContext
        get() = EmptyCoroutineContext

    override fun resume(value: Unit) {
        val f = Foo(23, {x -> 2 * x})
var prope1 = fu0((f).next().equals("gdldf"))
prope10.prope15 = {
            Kla12().prope14 = (Foo(1397637829, {a: Int -> -710498597}).f).equals("oscja").and(Kla2().fu3())
        }
    }

    override fun fu14(exception: Throwable) {
        throw exception
    }
}


2021-03-12 08:01:23,719 [main:107] - replacing (Kla5(), Kla5)
2021-03-12 08:01:23,719 [main:50] - replacing Kla5() Kla5
2021-03-12 08:01:23,719 [main:54] - Getting value of type Kla5
